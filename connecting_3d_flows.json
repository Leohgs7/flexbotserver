[
    {
        "url": "https://docs.flexsim.com/en/25.2/ConnectingFlows/Overview3DFlows/Overview3DFlows.html",
        "title": "Overview of 3D Object Flows",
        "content": "What Are Flows? In the previous chapter about 3D objects, you learned about the three basic types of 3D objects : Flow items - The items or materials that will flow through your simulation model. Flow items can represent materials, products, customers, orders, information, etc. Fixed resources - Objects that remain fixed or stationary in your model as they interact with flow items. Fixed resources can represent workstations, storage centers, processing stations, etc. Task executers - Objects that move around the model performing various tasks such as transporting flow items, operating machines, etc. In this chapter, you'll learn more about how these objects interact together in a simulation model to create a flow . Generally speaking, flows are the movement of items throughout the simulation from the beginning to end: Some practitioners might also refer to this process as item routing , which is the logic that determines how items move from one station to another in a business system. If you're familiar with Lean philosophy, you'll know that business systems can be improved by studying and optimizing the flow of items (or customers) throughout the business system. Business systems can be said to be more \"lean\" when they create smooth and continuous flows wherever possible. Lean systems eliminate waste created by overproduction, bottlenecks, and idleness. Therefore, learning different ways of creating flows between 3D objects in FlexSim will enable you to study and analyze different potential real life flow schemes, improving your business system's efficiency. Key Terms Before learning about flows, you should be aware of a few key terms and concepts that are frequently used when discussing flows: Upstream and Downstream From a certain perspective, you could think of flows as a stream of items. In the same way that water flows down a river or a brook, items can flow through a business system as they are transferred from one 3D object to another. For that reason, you might occasionally see the terms upstream and downstream to refer to different objects that are either further up or down the flow. For example, in the following image, three sources create flow items and transfer those items to conveyors. Then the combiner receives the flow items and packs them into a tote. In that sense, the three sources could be said to be upstream , while the combiner could be said to be downstream : Pushing and Pulling The terms pushing and pulling refers to the exchange of flow items between two objects. It describes whether the downstream object or the upstream object controls the flow of items. An upstream object pushes flow items when it is sending the flow item to the next available downstream object, which means the upstream object controls the flow. An downstream object pulls flow items when it is taking a flow item from an upstream object, which means the downstream object controls the flow. For example, the following simulation model has objects that both push and pull: In this example, the source creates three different types of flow items and pushes them to the first queue. The source can immediately push them to the queue because the queue can accept flow items at any point in time. The three processors then pull the items from the queue as soon as two conditions are met: The processor is empty and ready to process another item A flow item that meets its criteria is available in the queue In this case, each processor pulls items based on their item type. (Processor1 pulls type 1 items, Processor2 pulls type 2 items, etc.) Ultimately, the processors control the flow of items from the queue to the processors, which is why the processors could be said to pull the items from the upstream queue. You can build logic into your simulation model to determine whether an object should push or pull flow items. By default, most objects are set to push flow items rather than pull them, but these settings can be changed. Common Types of Flows FlexSim has the ability to build nearly every type of flow connection or any kind of flow logic. The following sections explain some of the more common types of flow connections used in simulation modeling. One-to-Many or Many-to-Many Connections With the exception of the one-to-one connection type described in the first section, most of the methods explained in the following sections apply to one-to-many or many-to-many connections. One-to-One The most basic type of flow connection is a single connection between one object and another. In this type of connection, an upstream object will either push a flow item to the next downstream object as soon as it is available to accept it or the downstream object will pull the flow item when it is ready for it: First Available When objects use the first available logic, flow items will move to the first downstream object that is available to receive the flow item. For example, if the first port (port 1) is available, the flow item will be sent there. If the first port is unavailable, the flow item will be sent to the second port, and so forth. If no ports are available, the flow item will wait until a port is available: Round Robin When objects use the round robin logic, flow items will be sent to each available downstream objects in turn. The first flow item will move to the first object, the second flow item will move to the second object, and so on: Random You could assign flow items to flow to downstream objects at random. You could possibly use a random statistical distribution to divert flow items to one object or another. FlexSim is capable of generating randomness using different distributions such as a coin flip (bernouilli), any number within a range of values, a certain percentage of objects to one object versus another, etc. In the following example, the first queue is set to randomly push 70% of flowitems to the second processor, 15% to the first processor, and 15% to the third processor: Conditional Objects can use conditional logic to determine which items should flow to certain downstream objects. For example, objects could be sent to a downstream object based on certain priorities, such as how long they've been waiting in a queue or by their item type. Objects with a specific value on a custom label could be sent to a specific downstream object (such as based on their weight, their size, or some other value on a label). The way that flow items get routed could also possibly depend on other external conditions in the simulation model such as the time of day or specific circumstances. Nearly any kind of condition can be simulated, so the possibilities are limitless. In the following example, each processor conditionally pulls items based on their item type. Processor1 pulls type 1 items, Processor2 pulls type 2 items, etc.: Sequential Objects can use global tables and lists to send flow items to objects in a specific order or sequence. For example, imagine you wanted to simulate a job shop in which items will be sent to one of four different stations (drilling, assembly, welding, pressing). Depending on the type of item it is, it will need to be sent to each station in a different order: You can use a combination of a global table and a list to create these kinds of complex sequential flows: Using Transports Objects typically flow from one fixed resource to another in a 3D model. Unlike fixed resources, task executers such as operators, robots, AGVs, etc. can move throughout the simulation model. For that reason, you can use task executers to transport flow items from one fixed resource to another, as shown in the following image: Overview of Flow Connection Tools FlexSim has a variety of tools you can use to create flows between 3D objects, as explained in the following sections: Ports You can create port connections directly between 3D objects in the simulation model. You can then use the properties on the 3D objects to control the flow between two objects using their ports. Port connections work well when you're just sending an item from one object to a single downstream object (such as a one-to-one connection type). Port connections between two objects can be created quickly and easily and come pre-programmed with basic flow logic. Port connections can also be ideal if you're sending an item from one object to one of many upstream or downstream objects using a basic routing method such as first available, round-robin, random and some kinds of conditional routing. See Key Concepts About Ports for more information. Lists An upstream object can push flow items onto a list and a downstream object can pull those items from the list. The downstream object can filter or prioritize certain list items over others. In the following example, the first queue pushes its flow items onto a list called Available Products. The items wait in the queue until they are pulled from the list by the processors. The processors pull items that match their item type query. For example, Processor1 will only pull type 1 items. Processor2 will only pull type 2 items, etc. Lists work well when it might become too unwieldy or difficult to use port connections, such as when you need to have many-to-many routing. Lists can also be ideal when you need to filter or prioritize flow items using a fairly complex set of rules. In these cases, using lists to create the criteria for sending and receiving items can be easier than using ports. See Key Concepts About Lists for more information. Conveyors You can use the conveyor objects to create a variety of conveyor systems including slug-building systems, power and free systems, and conditional routing systems. For example, the following conveyor system creates slugs of six objects before releasing them to the downstream objects: See Key Concepts About Conveyors for more information. Conveyor Systems Use Ports Conveyor objects need ports to connect to non-conveyor objects and to connect conveyor logic objects. Therefore, it's important to learn about ports if you want to use conveyors in your simulation model. Process Flow Process Flow is a tool that is primarily used to control the logic of the simulation model, but you can use it to move flow items between objects as well, if needed. The following example shows how you would create a basic flow between objects in process flow: The Process Flow tool is very versatile. As such, using the Process Flow tool is ideal if you need to create a custom flow between objects that difficult to create using one of the other methods. See Overview of the Process Flow Interface for more information. AGVs Automatic guided vehicles (AGVs) are portable robots designed to transport goods from one destination to another. AGV systems are now being used for a growing variety of applications in materials handling, manufacturing, and beyond. You could use the AGV objects and tools to if you would like to experiment with AGV transports. See Key Concepts About AGV Networks for more information."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/ConnectingFlows/Ports/KeyConceptsPorts/KeyConceptsPorts.html",
        "title": "Key Concepts About Ports",
        "content": "Introduction to Ports When you hear the term port , you might typically think of a docking station where freighter ships load and unload a shipment of goods. That's actually very similar to how ports function in FlexSim. In FlexSim, a port is a point on an object where flow items can be transferred from one object to another. A port connection is the connection between ports on two different objects. Ports create relationships between objects that allow them to communicate with each other and exchange flow items. The biggest advantage of using port connections is that they are quick and easy to create. Ports also have fairly straight-forward flow logic, which makes it easy for new users to understand how they work. However, if you want to create complicated, many-to-many flows between objects or if you want to create your own custom flow logic, it might be better to use lists or Process Flow. That being said, it's still beneficial to have a good understanding of how ports work because they form a good foundation for understanding flow logic in general. The rest of the sections in this topic will discuss the key concepts you will need in order to understand how ports function. Types of Port Connections You will need to use different types of port connections depending on the kinds of objects you're connecting, such as whether you're connecting fixed resources or task executers. (See Types of 3D Objects for more information about these terms.) The two most common types of port connections are input/output and center port connections. The following sections explain the difference between these types of port connections. Alternate Terms for Port Connections Occasionally, FlexSim users might refer to an input/output port connection as an A-connect and a center port connection as an S-connect . These terms are sometimes used because the A key is used as a shortcut to create input/output port connections and the S key is used as a shortcut for creating center port connections. See Adding and Removing Ports for more information. Input/Output Ports (A-Connects) Input/output ports are the most common types of port connections. These ports are usually used to connect two fixed resources together so that they can exchange flow items. The output port of an upstream object is connected to the input port of a downstream object. An output port is where the flow item exits the object and an input port is where the flow item enters the object. Input/output ports are graphically represented as a small red or green triangle. Input ports will look like an arrow pointing in toward the object. Output ports will look like an arrow pointing away from the object. Center Ports (S-Connects) Center ports are usually used to connect task executers to fixed resources, but they can connect any two objects that need to reference each other. When the center ports of two objects are connected, it creates an abstract reference point between those two objects. Center ports enable objects to communicate or interact in complex ways: Transporting flow items - Fixed resources can use the task executers connected to their center ports to transport flow items to a downstream fixed resource. Setting up and processing - Some fixed resources have setup and processing times (processors, combiners, separators, multi-processors). These objects can require the presence of a task executer connected to their center ports during setup and processing times. General reference - Objects can have center port connections in order to communicate with or reference each other. In FlexSim, center ports are graphically represented as a red square: Extended Connections FlexSim has another type of connection known as an extended connection. Only network node and traffic control objects can use extended connections. You might possibly use extended connections to build travel networks, but you will probably only use them in rare circumstances. For that reason, this chapter will focus primarily on input/output and center port connections. Port Rankings You need to understand how ports are ranked in FlexSim if you want to use ports to create certain types of flows such as round robin, random, conditional, etc. See Common Types of Flows for more information. Every time you create a port connection between two objects, FlexSim automatically assigns a rank to that connection. The first port connection you make will have a rank of 1, the second will have a rank of 2, etc. For example, the queue in the following image has three output ports. The output port going to Processor1 is ranked 1, the output port to Processor2 is ranked 2, and the output port to Processor3 is ranked 3. Notice that the output ports are visually arranged on the queue according to their ranking order: You could also view the port rankings by clicking on the queue to bring up Properties. In the Ports panel, select Output Ports to view the rankings: See Changing Port Rankings for more information. Open and Closed Ports Another important concept you should understand about ports is how to know when a port is open or closed and why. Simply put, an open port is ready to push or pull flow items. A closed port is not ready to push or pull flow items. During a simulation run, open ports are green and red ports are closed: In the example in the previous image, the first processor's input port is closed because it is processing a flow item and cannot accept any more items. The second processor's input port is open because it is available to process flow items."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/ConnectingFlows/Ports/AddingRemovingPorts/AddingRemovingPorts.html",
        "title": "Adding and Removing Ports",
        "content": "Adding Ports The easiest way to create port connections between two objects is to use the connection icons on the orb of the selected object. The triangle icon creates output port connections and the square icon creates center port connections. To create port connections click on the icon and then drag to another object. Connection Mode Another way to create port connections is to turn on connection mode in FlexSim. When you are in connection mode, your mouse pointer will change to a plus sign with a chain link symbol next to it. While in connection mode, you can connect two objects together: One way to turn on connection mode is to use the Connect Objects button: Click the Connect Objects button on the toolbar to open a menu. Select the type of port connection you want to make from the menu to turn on connection mode. See Types of Port Connections for information these options. When you are in connection mode, your mouse pointer will change to a plus sign with a chain link symbol next to it: Once you are in connection mode, you can connect two objects together. Click the first object you want to connect in your model. You will notice as you move your mouse that a yellow line will appear between the object you clicked and your cursor. Click a second object to create the port connection between the two objects. NOTE: If you are making an input/output port connection, FlexSim will create an output port on the first object you click and an input port on the second object you click. You will still be in connection mode even after you connect two objects together. You can continue connecting objects together if needed. You can use a few different methods to turn off connection mode when you are using the Connect Objects tool: Press the Esc key. Right-click the mouse. Click the Pointer button on the toolbar. Keyboard Shortcuts You can also use keyboard shortcuts to turn connection mode on or off. You will use a different keyboard shortcut based on the type of port connection you want to make between two objects: Input/Output Connections: Press and hold down the A key. Center Port Connections: Press and hold down the S key. Extended Connections: Press and hold down the D key. Connection mode will automatically turn off as soon as you stop pressing the shortcut key. Continue pressing and holding down the key if you want to continue connecting more objects together. Removing Ports The easiset way to remove port connections is to select the connection by clicking on it and then pressing the delete key. Disconnection Mode Another way to remove port connections is to turn on disconnection mode. One way to turn on disconnection mode is to use the Disconnect Objects tool: Click the Disconnect Objects menu on the toolbar to open a menu. Select the type of port connection you want to remove from the menu. When you are in disconnection mode, your mouse cursor will change to a plus sign with a broken chain link symbol next to it: Once you are in disconnection mode, you can remove a connection between two objects. Click the first object you want to disconnect. You will notice as you move your mouse that a yellow line will appear between the object you clicked and your cursor. Click the object to which it is connected. The port connection will disappear. You will still be in disconnection mode even after you remove the connection between two objects. You can continue disconnecting objects together if needed. You can use a few different methods to turn off disconnection mode when you are using the Disconnect Objects tool: Press the Esc key. Right-click the mouse. Click the Pointer button on the toolbar. Keyboard Shortcuts You can also use keyboard shortcuts to turn disconnection mode on or off. You will use a different keyboard shortcut based on the type of port connection you want to make between two objects: Input/Output Connections: Press and hold down the Q key. Center Port Connections: Press and hold down the W key. Extended Connections: Press and hold down the E key. Disconnection mode will automatically turn off as soon as soon as you stop pressing the shortcut key. Continue pressing and holding down the key if you want to continue removing port connections. Shortcuts FlexSim has some additional shortcuts and tricks that you can use to create port connections, even between multiple objects at a time. Quick Library You can automatically add 3D objects to a model using the Quick Library. (See Adding 3D Objects to a Model for more information.) Fortunately, you can also create port connections between the objects that you create using the Quick Library: Create a port connection as usual, but instead of connecting to an existing object end the connection at a blank space in the model where you want to place the new object. Click the icon for the object you want to add. Connecting One Object to Multiple Objects To connect one object to several other objects at the same time: Hold down the shift key and draw a box around the downstream objects to select the objects you want to connect. Create a connection from the upstream object to any one of the downstream objects. All downstream objects will automatically be connected to the upstream at the same time. Disconnecting from Multiple Objects You can use this same method to disconnect an object from multiple other objects. Connecting the Same Type of Object You can add several copies of the same object to a model and connect them at the same time: While pressing and holding the R key, click an object in the Library to enter object creation mode. While continuing to hold the R key, click a blank space in the 3D model to add an object. Continue to hold the R key as you click blank spaces in the model to add any additional objects."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/ConnectingFlows/Ports/CreatingPortLogic/CreatingPortLogic.html",
        "title": "Creating Port Logic",
        "content": "Introduction to Port Logic This topic will explain how to edit the properties on fixed resources in the 3D model to create different types of flow logic. Before reading this topic, make sure you are familiar with the concepts explained in these topics: Overview of 3D Object Flows Key Concepts About Ports You will primarily use the properties under the Input and Output sections of the Properties window to control the flow between fixed resources. You can access these by clicking on a fixed resource to open its properties in the Properties window on the right. Changing the Type of Flow If your simulation model has a fixed resource that is connected to multiple downstream objects, you might want to create logic on your ports that determine which downstream port will receive the outgoing flow item. FlexSim provides a variety of pre-programmed types of flows such as: First available - Flow items will move to the first downstream port that is available to receive the item. (This is the default setting.) Round robin - Flow items will be sent to each available downstream object in turn. The first flow item will move to the first port, the second flow item will move to the second port, and so on. Random - Flow items are sent to a downstream port at random, perhaps using a statistical distribution or a distribution defined by percentages. Conditional - Flow items are sent to a specific port when certain conditions are met or are sent to another port under a different set of conditions. Sequential - Flow items can be sent to ports based on the steps outlined in a global table. See Common Types of Flows for more detailed explanations and demonstrations of these flows. Editing the Send to Port Property You will primarily use the Send to Port property under the Output section of the Properties window to control how a fixed resource decides which downstream port should receive a flow item. To choose one of the common types of flows: Click the upstream fixed resource to open its properties on the right. Under the Output section, click the arrow next to the Send to Port box. This menu lists many of the common types of flows you could choose. Try experimenting with a few of the options to get comfortable with this property. About the Send to Port Property If you'll recall from the Key Concepts About Ports topic, each port is assigned a ranking. Every time you create a port connection between two objects, FlexSim automatically assigns a rank to that connection. The first port connection you make will have a rank of 1, the second will have a rank of 2, etc. When a fixed resource is ready to release an item, it will evaluate the Send to Port property and return a port number. Whichever port number it returns will determine which port will receive the flow item. For example, imagine your simulation model has a processor with five output ports to five different queues and you want the processor to send them to a random queue using a statistical distribution. In that scenario, you would set the Send to Port option to random. When the processor finishes processing a flow item, it will call the Send to Port function to determine which port it should send the flow item to. Because the Send to Port property was set to random, the Send to Port function will use a random statistical distribution to return a number between 1 and 5. If it returns the number 3, it will send the flow item to port 3. If it returns a 5, it will send the flow item to port 5, and so forth. See Fixed Resource Concepts for more information. Using a Transport If needed, you can use a task executer to transport flow items from one fixed resource to another. (See Using Transports for a more detailed explanation and demonstration.) The Basic Method for Using a Transport To create flow logic where a fixed resource will use a transport: Add at least two fixed resources to the 3D model and connect them using input/output port connections (A-connects). See Adding Ports for more information. Add at least one task executer to the 3D model, possibly between the two fixed resources. Connect the upstream fixed resource to the task executer with a center port connection (S-connect). Click on the upstream fixed resource to open its properties on the right. Under the Output section, check the Use Transport box. By default, when you check this box, it will use the task executer connected to the fixed resource's first center port. About the Use Transport Property The Use Transport property tells FlexSim which task executer should transport the flow item. By default, when you check this box, it displays a FlexScript expression that says current.centerObjects[1] . What does this expression mean? The word current refers to the current object you are defining the property on. So, if you're defining this property on a processor, it refers to that processor. The phrase centerObjects is a piece of FlexScript code that tells the object to use the task executer that is connected to its center port. The number [1] in brackets tells it to use the object connected to the center port with a ranking of 1. If you were to change that number to a 2, it would use the task executer connected to the second port instead. You can change the Use Transport property so that it uses different logic to determine which task executer should be used. If you click the arrow next to the Use Transport box, you'll see a menu that lists several different options for selecting a task executer. Try experimenting with a few of the options to get comfortable with this property. About Priorities and Preemption You might have noticed that the Use Transport property has two additional properties: Priority and Preemption. These properties control whether the task executer should complete the transportation tasks before or after it works on other tasks. When you create a transport task for a task executer, you're really creating a task sequence that has three tasks: Load the flow item Travel to the downstream object Unload the flow item It's possible that a task executer might be assigned more than one task sequence at a time. For example, if an operator is transporting flow items for two different processors, it could receive transport task sequences from both processors at the same time. If needed, you can use the Priority property to tell the task executer which task sequence has a higher priority, meaning that the task executer should work on that task sequence before other tasks. In a similar vein, you can use the Preemption property to preempt a task executer, meaning that they will stop the current task they are working on and go work on the more important task sequence. Because the Priority and Preemption properties are important to task sequence logic, these properties will be discussed in the topic about Task Sequences . Making an Object Pull If needed, you can make a downstream object pull flow items from an upstream object. For example, you can make a processor pull a flow item based on certain conditions. (See Pushing and Pulling for more information.) Creating a Pull Strategy To make an object pull from an upstream object: Click the downstream object to open its properties on the right. Under the Input section, check the Pull Strategy checkbox. If you want to change which input ports the fixed resource will pull objects from, click the arrow next to the Pull Strategy box to open a menu. This menu lists many of the common types of flows you could choose. Try experimenting with a few of the options to get comfortable with this property. If you want to restrict the criteria for flow items that this fixed resource will pull, click the arrow next to the Pull Requirement box to open a menu. This menu lists many different types of flow item restrictions. Try experimenting with a few of the options to get comfortable with this property. About the Pull Strategy and Pull Requirement Properties The Pull Strategy property controls where the flow item will be pulled. In other words, it determines which input port the fixed resource will pull flow items from. The Pull Requirement property controls what type of flow items can be pulled from the upstream fixed resource. For example, you could require the fixed resource to only pull flow items with a particular item type or a matching label. When the fixed resource is ready to pull an item, FlexSim will evaluate the Pull Strategy to determine which port it should pull from. Then it will evaluate whether there is a flow item that matches its criteria or restrictions. It will attempt to pull from this port until a flow item matches its criteria. Changing Port Rankings To change an object's port rankings: Click the object to open its properties on the right. Under the Ports section: The top box lists the different types of port connections. (See Types of Port Connections for more information.) Select the type of port connections you want to re-rank. The list box below displays all of the ports of that type that are connected to this object. The ports are ranked with numbers and are listed in the order they are ranked. Click the port you want to re-rank to select it. Use the buttons on the right to rank the port up or down."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/ConnectingFlows/Lists/KeyConceptsLists/KeyConceptsLists.html",
        "title": "Key Concepts About Lists",
        "content": "Introduction to Lists Lists (which are also sometimes referred to as global lists ) are a tool that can be used to create more complex flows between 3D objects. However, you should be aware that lists have many other possible purposes in addition to controlling the flow of items in the 3D model: Connectionless routing - Lists can be used in place of ports to connect the flows of fixed resources. This is especially helpful in situations where it might become too unwieldy or difficult to use port connections, such as when you need to do many-to-many routing. Filtering flow items - Lists can filter and prioritize flow items using a fairly complex set of rules, such as how long the item has been waiting, the item's type, the value of a label on the item, etc. When a fixed resource is ready to pull an item from the list, the list will search for any items that match its search criteria and priorities. For example, a processor could pull items from a list that have a label named weight with a value over 50. The list could also prioritize flow items that have been waiting the longest amount of time or which are in the queue with the greatest amount of items. Task management - Lists can be used in place of a Dispatcher object to assign tasks to task executers. Lists can prioritize which task executer should receive a given task sequence or vice versa. Lists can also ensure that only task executers who meet certain criteria are assigned to work on a particular task sequence or vice versa. Prioritizing fixed resources - You can also put fixed resources onto a list and prioritize which fixed resources should process a flow item. In the following example, the first queue pushes its flow items onto a list called Available Products. The items wait in the queue until they are pulled from the list by the processors. The processors pull items that match its item type query. For example, Processor1 will only pull type 1 items. Processor2 will only pull type 2 items, etc. How Lists Work Perhaps you've been to a busy restaurant on a weekend. Typically when you arrive, a host puts your name on a waiting list. The host will monitor the restaurant for a table that matches the size of your party. Once your name is at the top of the list and the host sees there is a matching table, he or she will seat you at the table. That process is fairly similar to how lists work in FlexSim. The process begin when something pushes an item, task, or 3D object onto a list. For example, a queue could push flow items onto a list as flow items enter the queue. That item/task/object is then considered a list entry . The list can track data about each list entry, such as how long that item/task/object has been on the list, any labels that are associated with it, etc. You can use this data to create custom logic (referred to as a query ) that will determine which list entries should be pulled from the list first. Eventually, another object (such as a downstream fixed resource or a task executer) will attempt to pull an item/task/object from the list. This object might have additional criteria or restrictions about which type of item/task/object it needs. The list will determine which list entry is the best match for the fixed resource or task executer. When it finds a match, the fixed resource or task executer will pull the matching item/task/object from the list. How Lists Manage Imbalances If there are more items/tasks/objects on the list and there are not enough objects pulling from the list, the list entries will wait on the list until they can be pulled. But what if the opposite is true? What if there are more objects that want to pull from the list and there are not enough list entries to meet this demand? Returning again to the restaurant analogy, imagine that you go to the restaurant on a slow day. On slow days, there are many tables available. So in that scenario, a table needs a party. The restaurant host keeps a diagram of the tables that are ready for customers. When a customer arrives, the host determines which table should get the customer based on a few different priorities such as whether the table matches the party size and whether the server in the table's section is ready for a new table. In a similar vein, a fixed resource or task executer might attempt to pull from a list at a moment in time when there aren't any matching item/tasks/objects on the list. When that happens, the list will create a back order . A back order is an open request for a list entry that needs to be filled. When a new item/task/object is pushed on the list, the list will evaluate it to see whether it can fulfill any back orders. Too Many Imbalances Might Indicate Inefficiencies Keep in mind that if there are too many list entries or too many back orders on a list, that could be a sign that your business system is inefficient. You might want to gather statistics from lists to determine if there are too many surpluses or deficits. See Getting Data from Your Model for more information. Lists are Abstract, Logical Constructs One caution about lists is that you shouldn't think of a list too literally. Don't just assume that because your business system doesn't have some sort of formal mechanism like a list that you won't use them in your simulation model. Keep in mind that lists are abstract constructs that help recreate the implicit logic underlying your business system. For example, sometimes there are situations in business systems in which there are finite resources: maybe not enough employees are available to do all the tasks that need to be done at a given time, maybe not enough workstations are available for the items that need to be processed, etc. In those scenarios, some mechanism is usually in place to determine which tasks or items should take priority. If you are using any kind of logical system besides simple first-in-first-out logic (FIFO), lists can recreate this kind of logic in a simulation model. Another thing to keep in mind is that when an item/task/object is pushed on to a list, it is not literally put on a list. For example, you may have a queue object in your model push an item onto a list. This does not put the item physically or literally onto the list. The 3D item object remains in the queue. Instead, a reference to that item/task/object is added to the list, similar to a host putting your name on a list at a restaurant while you remain in the restaurant waiting area. What Gets Pushed Must Get Pulled One of the key concepts to keep in mind while you are designing lists is the concept that \"what gets pushed, must get pulled.\" If an item, task, or object gets pushed onto a list, there needs to be a way for that item, task, or object to get pulled from the list later during the simulation run. If you forget to design some event or mechanism that will pull items, tasks, or objects from a list, they will remain on the list indefinitely. So, every time you create functionality that will push something to a list, make sure you also create the functionality that will pull it from the list as well. List Features and Key Terms When you view a list's entries during a simulation run, it will look similar to the following image: List Entries When an item, task, or object is pushed on a list, it becomes an entry on that list. Values The value of a list entry is the primary identifier associated with a given list entry. Typically the value will be a reference to an item, task, or object that was pushed on the list. In the example in the previous image, the values are references to boxes inside of three different queues in the simulation model. However, depending on the way you set up your list, the value could also be a number, string, or node reference. Fields Fields specify which data should be tracked about each list entry. You can use this data to create custom logic (referred to as a query ) that will determine which list entries should be pulled from the list first. Queries can also restrict and filter which list entries should get pulled. In the example in the previous image, there are three fields: itemType - indicates the item type of each box age - tracks how long the boxes have been on the list queueSize - displays the total number of boxes that are currently in this box's containing queue In this example, you could possibly create a list query that prioritizes boxes that are in the longest queue and that have been on the list for the shortest/longest amount of time. The boxes that meet this criteria will get pulled from the list first. You could also restrict a query so that only boxes with a specific item type get pulled. FlexSim is pre-built to track a variety of data, depending on the type of objects that are being pushed to the list. You can use this pre-built data or you can track data in a custom label. If you are comfortable with FlexScript, you can design your own custom expressions to create custom data. It's ultimately up to you to decide which fields you need and which data needs to be tracked so that you can create effective list queries. Field Values The field values display the current data for each field for a given list entry at a given point in time. In the example in the previous image, the age fields show the amount of simulation time units that the boxes have been on the list. According to this list, the box in the first queue has been waiting the longest, for 6.81 time units. Types of Lists When you first create a list, you need to decide which type of list you are going to create. There are five types of lists: Fixed Resource Lists Item Lists Task Sequence Lists Task Executer Lists General Lists You should select a type of list primarily based on what is getting pushed onto the list. For example, if you are pushing flow items to the list, you should choose an Item List. If you are pushing a task to the list, you should choose a Task Sequence List. If you're unsure what you want to push to a list, choose a General List. Do List Types Really Matter? One of the most important aspects of a building a list is to choose the list's fields because they will track data about each list entry. Fields are the building blocks that you will use to create queries to filter and prioritize list items. The type of list you select will affect the kinds of pre-built fields that are available for that type of list on the Fields tab of the List properties window. It will also affect the fields that are included on that list by default. You can easily add, delete, or customize any of the fields available in any list type. You shouldn't worry about which type of list you should choose. All lists ultimately have the same functionality, regardless of what type they are. Even if you choose the wrong type of list, you can change that list so that it can have any of the pre-built fields that are available on the other types of lists. Global and Local Lists Whether a list is considered a global or local list is determined by how accessible it is. Most lists will be globally accessible, meaning that all the objects in a given simulation model can push or pull items/tasks/objects to the list. By contrast, local lists are only accessible to a specific instance of an object in a simulation model. You can set up different instances of a simulation model using the Process Flow tool. For more information, see the following topics and tutorials: Process Flow Instances Advanced Process Flow Tutorials - Tutorial 4 Instances List Partitions If needed, you can divide a list into partitions. Partitions are a way of dividing lists into compartments based on some distinguishing factor, called its partition ID . For example, imagine your flow items all have a label named type on them. This label might have a value ranging between 1 and 10. The type label could potentially act as the partition ID. Items with a type 1 will go into partition 1, items with a type 2 will go into partition 2, etc. You can also create partitions based on a value in a custom label or a field in a list. The partition ID can be a number, a string, or a reference to an object or node in the tree. Partitions are dynamic in that, if you push a value onto a partition that does not yet exist, the partition will be created automatically. Just remember that the rule of \"what gets pushed, must get pulled\" also applies to pushing and pulling from partitions. If something in your simulation model pushes something onto a partition, something needs to pull it from that partition later during a simulation run."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/ConnectingFlows/Lists/WorkingWithLists/WorkingWithLists.html",
        "title": "Working With Lists",
        "content": "Planning a List Before creating a list, it might be helpful to think through some of the logistics of how your list will work in your simulation model: Why will you use a list? - Take a moment and think through the purpose of your list in your simulation model. Will you use it to prioritize flow items and create logic that will send specific flow items to specific fixed resources? Will you use it to manage and prioritize task sequences? Will you use it for connectionless routing? Thinking through what you want to do with the list will help you create a more effective list. What will go on the list? - Will your list contain flow items, tasks, or objects? Your answer will determine what type of list you should initially create. Although you can technically mix different types of objects on a list, it might be better to be disciplined and keep your list focused on one type of object. What will push and pull items from the list? - How will items, tasks, or objects get pushed onto the list? Which event in the simulation model will cause them to get pushed onto the list? Which event in the simulation model will cause items to get pulled from the list? Which criteria will be used to filter list entries and back orders? - Is the list going to use simple first in first out (FIFO) logic or will something else be needed to determine which list entries or back orders should take priority? Using the Toolbox You'll primarily use the Toolbox to create and manage lists. See Using the Toolbox for general information about working with tool components like lists. This topic will explain how to delete and rename lists and other related tasks. Creating a List To create a list: In the Toolbox, click the Add button to open a menu. Point to Global Lists and then select the type of list you want to create. (See Types of Lists for more information.) This will open the List Properties window. In the box at the top of the window, give this list a descriptive name to help you identify its purpose in your simulation model. Adding, Moving, and Deleting Fields Fields keep track of data about each entry on the list. They are the building blocks that you will use to create queries to filter and prioritize list items. (See Key Terms - Fields for more information.) For that reason, choosing the list's fields is one of the most important aspects of building a list. Be aware that you can use the pre-built fields or create custom fields of your own. Adding Fields To add fields: Open the List Properties window. On the Fields tab, click the Add button to open a menu. Select the type of field you want to add. The Add Fields menu is context-sensitive The options that are available from the Add Fields menu might change depending on what type of list you created. See Types of Lists for more information. The new field will appear at the bottom of the Fields tab. You can change the name of this field in the Expression Field box. If you want to create custom logic and you are comfortable with FlexScript, you can type a custom expression in the Expression box. You can also use the arrow next to this box to select pre-built expressions from a picklist menu. Moving Fields To move or reorganize the fields, simply drag the handle on the left of the field to re-position it: Deleting Fields To delete fields, click the Remove button next to the field. Connecting 3D Objects to a List You can use menu options (picklists) on various properties or triggers found in the properties window to connect a 3D object to a list. The method that you use to connect the 3D object will depend on whether you are pushing a flow item, task, or object to a list. The following sections will explain the most common methods. Pushing and Pulling Flow Items to a List Fixed resources can push or pull flow items to a list. You'll primarily use the Flow tab on the fixed resource's property window to push or pull flow items. To push flow items to a list: Click on the fixed resource to open its properties on the right. Under the Output section, click the arrow next to the Send To Port box to open a menu. Point to Use List , then select Push to Item List to open the list options. Click the arrow next to the List box to open a menu. Select the list to which you want to push the flow items. You Can Create a New List Directly in the Flow Tab If you click the Add New List option from this menu, it will automatically create a new list and open the List Properties window. You can use this method to create lists as an alternative to creating them in the Toolbox. To pull flow items from a list: Click on the fixed resource to open its properties on the right. Under the Input section, check the Pull box. Click the arrow next to the Pull Strategy box to open a menu. Point to Use List , then select Pull from Item List to open the list options. Click the arrow next to the List box to open a menu. Select the list from which you want to pull the flow items. Using Pull Requirement in a pull When you pull from a list in the Pull Strategy field the Pull Requirement field is ignored and only the query specified in the pull will be used to filter or sort what is pulled. However, you can set up the list and the query so that the Pull Requirement field is used. To do so, open the list's properties windows and on the Fields tab, click the Add button . Select meetsPullRequirement from the list. Now, in the Pull Strategy field of the pulling fixed resource set the query to the following: WHERE meetsPullRequirement Pushing Task Executers to a List You can push a task executer to a list whenever the task executer is free to be assigned to another task. The list can then prioritize and assign tasks to the available task executers. To push task executers to a list, you need to set the task executers so that they push themselves onto a list at the beginning of a simulation run and every time they are available to work on another task: Click on the task executer to open its properties on the right. Under the Triggers section, click the Add button to open a menu. Select On Resource Available . Click the Add button next to the On Resource Available trigger to open a menu. Point to Use List , then select Push to Task Executer List to open the list options. What is the On Resource Available Trigger? The On Resource Available trigger fires whenever the task executer is available to work on another task. When it fires, it will perform the action that you specify in this trigger's picklist. In this case, the task executer will push itself onto a list when it becomes available. Click the arrow next to the List box to open a menu. Select the list to which you want to push the task executer. Under the Task Executer section of the properties window near the bottom of the tab, make sure that the Fire OnResourceAvailable at Simulation Start box is checked. When this box is checked, the task executer will be pushed to the list immediately when the simulation starts. Pulling Task Executers from a List When a fixed resource has a task that needs to be completed, it can pull a task executer from a list: Click on the fixed resource to open its properties on the right. Check the box for the property for which you would like to use a task executer (such as Use Transport or Use Operator(s) for Process ). Find the box where you indicate the operator or task executer that should be used for the task. Click the arrow next to this box to open a menu. Point to Use List , then select Pull from Task Executer List to open the list options. Click the arrow next to the List box to open a menu. Select the list from which you want to pull the task executer. Pushing and Pulling Tasks or Fixed Resources to a List If you want to push and pull tasks or fixed resource from a list, you should consider using the Process Flow tool. See the following section about Using Lists in Process Flow for more information. Using Lists in Process Flow You can use the Process Flow tool to create custom list logic if you want to use lists in ways that haven't yet been pre-built into FlexSim. The Process Flow tool is especially effective for creating task sequences and working with lists that use abstract values such as numbers and strings. Additionally, Process Flow gives you more flexibility in controlling objects like task executers, when you need to do more than just pushing and pulling from lists. See Overview of the Process Flow Interface for more information about the Process Flow tool. Also, see Process Flow Tutorial 1 and Process Flow Tutorial 4 for examples of lists in process flow. Viewing Lists During a Simulation Run To open a list and view its entries during a simulation run: In the Toolbox, double-click the list to open the list properties window. In the General tab, click the View Entries and/or View Back Orders buttons. A separate window will open that displays the list's entries or back orders. You can dock this window for easier viewing during a simulation run, if needed. See Arranging Windows and Tabs for more information. Start the simulation. The list entries and back orders will dynamically update during the simulation run. Creating List Queries Although queries are optional, queries are the key to getting the most out of your lists. Queries are the custom logic that will determine which list entries should get pulled first from a list or which back orders should get fulfilled first. Queries can also filter or restrict which list entries will get pulled from a list. See List Features and Key Terms for examples of possible queries. Where Do You Add Queries? You don't add queries to the list itself in the list properties window. You add a query to the object or Process flow activity that is pulling from the list. For example, if you set a processor to pull flow items from a list, you would create a query by opening the processor's property window. On the Flow tab, you'd add the query to the Pull Strategy property: If you were to add a query in the Process Flow tool, you'd add the query to the Query property on a Pull From List activity: How to Write a Query List queries use SQL syntax. SQL is a programming language that has mostly been used for querying, filtering, and prioritizing data contained in tables and databases. Since this is very similar to how lists function in FlexSim, SQL is a good fit for querying lists. If you're already comfortable with SQL, you'll find it very easy to create queries. If you're not, then just be assured that you'll only need a very introductory level to SQL syntax in order to create most of the list queries you're interested in. You'll primarily use two clauses in this context to create a list query, as explained in the following table: Clause Purpose Example WHERE Use this clause to filter entries on the list, meaning only entries that meet a specific criteria will get pulled from the list WHERE weight > 20 In this example, the list will use a field that correlates with a label on the object that represents the object's weight. It will only allow objects with a value greater than 20 to be pulled from the list. ORDER BY Use this clause to prioritize entries on the list, meaning it will compare the attributes of two or more list entries and determine which entries will get pulled from the list first ORDER BY weight DESC In this example, the list will use the object's weight label to determine which entries will be pulled first from the list. The object with the highest weight will get pulled first and so on. See Introduction to SQL Queries for a deeper explanation of how to create SQL queries. Creating Queries Using Picklists Any time you see a property where you can enter a query, there is a picklist that can help you. Picklists can give you hints and suggestions about how to create a valid list query. To create a query using picklists: Find the property where you can enter a list query. (See Where Do You Add Queries? for more information.) Click the arrow next to the query box to open a picklist menu. Point to either WHERE or ORDER BY to open a sub-menu showing suggested list fields you could use in your query. Click the field you want to filter. The query box will then display a sample query based on your selection. Use this sample query as a jumping off point to create your own queries. You can edit the query until it has the correct filters and restrictions that you want to create. Example of a Query Imagine your simulation model has 3 queues and these queues are pushing flow items that have a label named type that can have a value of 1, 2, or 3. The queues push the items to an item list with the following fields: When a processor pulls an item from this list, it could possibly use the query: WHERE type == 2 ORDER BY age ASC The WHERE clause in this query filters the flow items by the type field. In this case, it restricts the processor so that it only pulls items with an item type that is equal to 2. Therefore, the processor will only pull items that have a 2. The ORDER BY clause then uses the age field to prioritize which items should get pulled from the list. The age field contains data about how long the flow item has been on the list. The ASC clause means ascending . It means that it will pull the items that have been waiting the least amount of time on the list. If you wanted to pull the oldest items first, you would use DESC (which means descending ) instead. In this example, the processor would pull /Queue3/Box~2 first because it has a type of 2 and has been on the list for less time than /Queue3/Box . Testing Queries Before applying a query to a list, you might want to test it to see if it's filtering and prioritizing the list entries correctly. To test a particular query: Open a list to view its entries. (See Viewing Lists During a Simulation Run for specific instructions.) Run the simulation model until there are several items on the list. Pause the simulation model. Click somewhere inside the list entry window. The Quick Properties panel will change to display the Test Pull Queries properties. In the Query box, type the query you want to test. When you press the enter key, the list will reorder itself based on the query you entered. The entries that will get pulled first are at the top of the list. Review the order of the entries to ensure it matches your expectations. Back Order Queue Strategies In the same way that you can use a query to prioritize which list entries should get pulled first, you can also prioritize back orders so that the list will fulfill back orders that have specific attributes first. For example, you could prioritize back orders based on a label on a fixed resource or based on some condition in the model. When you create a back order queue strategy, you might want to pay attention to when the list evaluates the list of back orders and re-organizes the list. You might want to be mindful of certain conditions in the simulation model that can cause the back orders to be evaluated in different ways. To create a back order queue strategy: In the Toolbox, double-click the list to open the list properties window and open the Back Orders tab. Type a query into the Back Order Queue Strategy box. If needed, you can use the rest of the properties on the Back Orders tab to change when the list will evaluate and re-organize the back orders list: Unique Pullers Only - This box is checked by default. When it is checked, only one back order from a pulling object will be available at a time. Allow Multiple Pushes Before Back Order Fulfillment - Use this check box if you want an object to push several entries onto a list before the back orders are evaluated and prioritized. For example, you might use this checkbox if you want a batch of items to get pushed onto a list before the back orders are fulfilled. Reevaluate All Values On Pushes - By default, back orders on the list will only evaluate new values that are pushed to the list. Use this check box if there are dynamic fields that might change while entries are on the list. Checking this box will re-evaluate the values of fields for all list entries any time something is pushed to the list. Back Order Reevaluation Events - Only add reevaluation events if you are using a WHERE clause in your back order queue strategy. Add these events to determine which events in the simulation will cause the back orders to be evaluated."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/ConnectingFlows/Lists/IntroSQLQueries/IntroSQLQueries.html",
        "title": "Introduction to SQL Queries",
        "content": "Overview of SQL Queries Before reading this topic, consider reading Key Concepts About Lists and Creating List Queries . List queries in FlexSim might have the following components: For example, a valid query might be something like this: WHERE queuesize > 10 In this example, the list will restrict the entries that get pulled from the list. It will only pull list entries that are in a queue containing more than 10 items. The following sections will explain the purpose of each component of this query: SQL Clause The SQL language uses clauses to represent some kind of logical rule that will be used to perform a search. Usually, the clause begins with a keyword that is formatted in all caps. Although SQL has many different clauses with different purposes, you will generally only need to use two clauses when creating list queries: WHERE - Use this clause to restrict which entries get pulled from the list. ORDER BY - Use this clause to sort and prioritize which entries will get pulled first from the list. See SQL Clauses for more detailed information on these two clauses. Field on the List Every list uses fields to track data about the list entries. When you created your list, you determined which fields your list would have and which data they would track. In the SQL query, you will indicate which field on the list should be used to filter or prioritize list entries. Operator (optional) Operators can be used to compare two values or create a new value. You'll typically only use operators with the WHERE clause, which filters or restricts list entries. If the result of the comparison is true, then the list entry will get pulled. If the result of the comparison is false, the list entry will not get pulled. Operators consist of the normal basic math operators (such as +, -, *, /, =, etc.) and some additional logical operators. In list queries, you'll typically use an operator to compare the value of a list to the value in your query. See Operators for more information about the operators you can use in your queries. Value (optional) You'll use a value along with an operator to compare this value to the value of the field on the list in a WHERE clause (not an ORDER BY clause). If the result of the comparison is true , it could potentially be pulled from the list. If the result is false , it will not be pulled from the list. SQL Clauses In SQL, you use what are called clauses to define queries. Each clause represents a rule that the query will use to perform its search. There are many different clauses available in standard SQL, but when using lists, you usually only need to know two: WHERE and ORDER BY. WHERE Clause The WHERE clause essentially defines what you want to pull from a list. When you pull from a list using a query with a WHERE clause, you are essentially saying, \"I want to pull something from the list where the entry meets this criterion.\" For example, if you have a processor that should only pull items that have an item with a label named type that has a value of 3, you could use the following query: WHERE type == 3 This WHERE clause defines a rule that you only want to pull items whose type label is equal to 3. More specifically, the type field on the list must have a value that is equal to 3. ORDER BY Clause The ORDER BY clause essentially defines how to prioritize what should be pulled when there are multiple potential candidates for pulling. When you pull from a list using a query with an ORDER BY clause, you are essentially saying, \"I want to pull something from the list, and if there are multiple possibilities, order them by this rule.\" For example, if you were using the age field to pull entries that have been on the list for the shortest amount of time, you could use the following query: ORDER BY age ASC This ORDER BY clause says that you want to prioritize the items on the list with the lowest age. More specifically, the pull query should sort list entries by the age field value in ascending order, and pull the first item in the resulting sorted list. The ASC keyword is optional and tells the list to sort the entries in ascending order (default). You could alternatively use the DESC keyword to sort in descending order. Combining Multiple Clauses and Rules You can combine many different rules and clauses to make more complex SQL queries if needed, as explained in the following sections. Ordering by Multiple Fields The ORDER BY clause can easily prioritize list entries by more than one field at a time. You can separate multiple fields using a comma. For example: ORDER BY type ASC, age DESC, queueSize DESC In this query: The list will first order the entries using the type field in ascending order (so items with a type of 1 will get pulled first, then items with a type of 2, etc.). After applying that first filter, if two entries have identical types, the list will then order the entries using the age field in descending order (so items that have been on the list the longest will get pulled first). Lastly, if two entries have identical types and ages, the list will sort the entries using the queueSize field in descending order (so items will get pulled from the largest queue first). Using Both WHERE and ORDER BY Clauses If you define a query that uses both the WHERE and ORDER BY clauses, the WHERE should come first, and the ORDER BY can be placed immediately after it, as in the following example: WHERE type == 3 ORDER BY age ASC This query says that it will only pull items with a type of 3, and if there are multiple that meet that criterion, it should take the one with the smallest age. Operators The following tables show the operators that you can use in pull queries. Comparison Operators Operator Definition Example = or == Equals comparison WHERE type == 2 < Less-than comparison WHERE type < 2 > Greater-than comparison WHERE type > 2 <= Less-than-or-equal comparison WHERE type <= 2 >= Greater-than-or-equal comparison WHERE type >= 2 <> or != Not-equal comparison WHERE type <> 2 BETWEEN Between a defined range (inclusive) WHERE type BETWEEN 2 AND 5 IN Value in a defined set WHERE type IN (1, 3, 5) Logical Operators Operator Definition Example AND or && Logical and WHERE type == 2 AND queueSize < 5 OR or || Logical or WHERE type == 2 OR queueSize < 5 Example of Logical Operators Imagine you need to have a simulation model with flow items that can have 1 of 3 item types. You may have a processor that is dedicated to more that one item type. For example, one processor only processes item types 1 and 3. You could use either of the following pull queries: WHERE type == 1 OR type == 3 WHERE type IN (1, 3) Math Operators Operator Definition Example + Addition ORDER BY distance + age - Subtraction ORDER BY distance - age * Multiplication ORDER BY distance * age / Division ORDER BY distance / age Expression Grouping Operator Definition Example () Grouping Parentheses WHERE (type < 2 OR type > 8) AND queueSize < 5 FlexScript Functions You can also use FlexScript function calls in your queries. This is often used to do math operations that are not in the standard set. For example, you may want to sort primarily by distance (find the item closest to where the pulling processor currently is), but only up to some threshold, and then sort by some other rule. Specifically, maybe you want to separate distance into partitions of 10 meters each. Items within the same partition would be pulled in LIFO order (age ASC). Here you would use the round() function to round the distance to every 10 meters, and then use age as the second order priority. ORDER BY round(distance / 10) ASC, age ASC SELECT Clause In some special circumstances you might also use the SELECT clause. See the Functional Reference for more information."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/ConnectingFlows/Conveyors/KeyConceptsConveyors/KeyConceptsConveyors.html",
        "title": "Key Concepts About Conveyors",
        "content": "Why Use Conveyors? Installing a conveyor system at a business facility generally involves significant costs. It can also be costly to change an existing conveyor system. With FlexSim, you can experiment risk-free until you find the ideal way to configure your conveyor system and maximize its throughput. FlexSim includes two main types of conveyors: discrete item conveyors and mass flow conveyors . Discrete item conveyors, which we usually just refer to as conveyors, simulate the movement of discrete flow items. Mass flow conveyors let you build high-volume high-speed manufacturing models, such as bottling or food production systems, by simulating flow rates and the movement of product densities through a system, instead of simulating individual items. Discrete Item Conveyor Features FlexSim's conveyor objects have several useful features: Photo Eyes, Decision Points, and Stations - You can use photo eyes , decision points , and stations to place routing/decision/control logic anywhere in your conveyor system. From simple movement/rotation logic to area restriction or triggering sophisticated process flows, executing logic at defined points in your conveyor system is incredibly easy. Flexible Movement Controls - FlexSim's conveyor system has many possible options for controlling how items transfer between the conveyors, including speed, delay time, and pop-up distance. You can also adjust a roller skew angle on a conveyor, so that items will accumulate on one side of the conveyor if needed. You can also tilt, translate, and rotate items while moving along the conveyor. Item Orientation - You can define any orientation for items on a conveyor. This orientation will automatically persist across multiple sections, and will update its calculations to match the object's orientation when the item transfers through side transfers. Power and Free - With the conveyor system you can simulate power and free systems, which simulate fixed interval movement of items on a dog chain. Slug Building and Merge Control - You can create conveyors that will accumulate a slug of items on a conveyor and then release it once the slug is ready. Using this feature in conjunction with the merge controller object and/or the Process Flow tool, you can easily implement sawtooth merges without writing any custom code. Range-Based Transfer Points - Operators can pick up or drop off items from a range of possible transfer points along the conveyor rather than a single fixed point, making it easier to simulate picking operations. When picking items from a conveyor, operators will automatically predict a proper pick up point on the conveyor based on item speed, operator speed, and distance. Mass Flow Conveyor Features FlexSim's mass flow conveyor objects have several useful features: High Speed Simulation - Since FlexSim's mass flow conveyors do not simulate individual items, they enable you to easily simulate the production of any number (hundreds, thousands, millions, ...) of bottles/cartons/cans, etc. In this design, run speed is only constrained by how often flow rates change, not by how many 'units' you are producing. Generally, given this, a whole day's production can be simulated in a few seconds or less. High Fidelity Graphics - While FlexSim's mass flow conveyors do not track individual items, the mass flow conveyor system includes an innovative rendering algorithm that will draw individual bottles/cartons/etc. flowing down the conveyor, even though they are not individually tracked. This graphic fidelity goes a long way in troubleshooting as well as selling your ideas to decision makers. Sophisticated Flow Rate Splitting - When you want to split flows between multiple conveyors, FlexSim's flow distribution algorithm works intuitively in that wider conveyors will naturally receive a larger proportion of flow. Additionally, you can custom configure priorities for splitting flows downstream. Multiple Configurable Bottle/Can/Carton Types - FlexSim's mass flow units let you configure the geometry of different types of product. When you then send these different types of product into your system, the conveyors automatically calculate flow densities, capacities, and flow rates based on these flow unit dimensions and attributes. Photo Eyes - You can use FlexSim's standard conveyor photo eye on mass flow conveyors. Here some of the properties you enter change, but the photo eye still allows you to trigger logic when certain flow rates occur, or when the system accumulates to some point. Easy Flow Generation - You can easily generate flow directly from an individual conveyor, or you can convert discrete items into mass flow rates using a mass flow entry transfer . Many conveyor model-building concepts work for both mass flow conveyors and regular conveyors. For example, the methods for creating and connecting conveyors are the same for both types of conveyors. However, for other concepts like creating conveyor logic , this user manual section deals primarily with regular discrete item conveyors. For information on mass flow conveyors, see the reference topic on Mass Flow Conveyors . Conveyor System Settings The Conveyor System properties window can be used to set the default properties for all conveyor objects in your simulation model. For example, you can create custom conveyor types and then use the conveyor system tool to ensure that each new conveyor you create is automatically assigned that type. You can also use the Conveyor System properties to change the visual settings for the conveyor system. See Reference - Conveyor System for more information."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/ConnectingFlows/Conveyors/OverviewConveyorObjects/OverviewConveyorObjects.html",
        "title": "Overview of Conveyor Objects",
        "content": "Library Objects Conveyor objects are found in the Conveyors group in the FlexSim Library. The following table will provide a high-level overview of these objects. The categories and objects are presented in the same order as they appear in the Library. Name and Icon Description Appearance Straight Conveyor The straight conveyor simulates the movement of items on a belt or accumulation conveyor. See Straight and Curved Conveyors for more information. Curved Conveyor The curved conveyor can join conveyors together, or you can use it to simulate a spiral elevating conveyor. See Straight and Curved Conveyors for more information. Straight Mass Flow Conveyor The mass flow corollary to a straight conveyor. See Mass Flow Conveyors for more information. Curved Mass Flow Conveyor The mass flow corollary to a curved conveyor. See Mass Flow Conveyors for more information. Join Conveyors Join conveyors acts more like a tool than an object. Use it to create a curved conveyor connecting two conveyor sections. See Join Conveyors for more information. Photo Eye Photo eyes are objects you place at various points in your conveyor system. They simulate light-beam-based photo sensors in that they trigger logic when their 'beam' is covered by flow items. You can define block times and clear times for detecting accumulation, or have the photo eyes fire logic on each flow item that blocks them. You can also make precise adjustments to the height and angle of the photo eye on the conveyor, to make it simulate an angle or elevated photo eye. See Photo Eye for more information. Decision Points - Decision points are similar to photo eyes, but are triggered by each passing item, instead of being based on the simulated blocking of a light beam. While there is significant overlap as to when you use decision points versus photo eyes, in general you use a decision point when you need logic to fire on every passing flow item, and you use a photo eye when you want to simulate the covering/uncovering of a photo sensor. Stations - Stations are similar to decision points and photo eyes in that you place them at certain points in your conveyor system. Stations are specifically for stopping and 'processing' an item on a conveyor. Processing may involve a simple imposed delay time, or you may require an operator for processing. In this way stations are similar to the library's Processor object. Decision Points Decision points are similar to photo eyes, but are triggered by each passing item, instead of being based on the simulated blocking of a light beam. While there is significant overlap as to when you use decision points versus photo eyes, in general you use a decision point when you need logic to fire on every passing flow item, and you use a photo eye when you want to simulate the covering/uncovering of a photo sensor. See Decision Point for more information. Stations Stations are similar to decision points and photo eyes in that you place them at certain points in your conveyor system. Stations are specifically for stopping and 'processing' an item on a conveyor. Processing may involve a simple imposed delay time, or you may require an operator for processing. In this way stations are similar to the library's Processor object. See Station for more information. Motor Motors can be used to control whether the conveyor systems are on or off at a given time. The motor can also be used to sync dog gaps on a power and free chain loop when simulating a power and free conveyor system. See Motor for more information. Merge Controller The merge controller is an object that can control how different conveyor lanes merge together. Use the merge controller to define a lane release strategy for the merge. See Merge Controller for more information. Additional Conveyor Objects In addition to these objects which are available in the FlexSim Library, there are three additional conveyor objects you should be aware of: transfers, entry transfers, and exit transfers. These objects are not available in the FlexSim library but are automatically created whenever you connect conveyors to other objects. See Working With Transfer Objects for more information."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/ConnectingFlows/Conveyors/WorkingWithConveyors/WorkingWithConveyors.html",
        "title": "Working With Conveyor Objects",
        "content": "Introduction to Working With Conveyor Objects For the most part, conveyor objects are similar to fixed resources and can be added, moved, resized, etc. using the same methods you would use for other 3D objects. (See the chapter on Using 3D Objects for more information.) However, there are some key differences when working with conveyor objects: Starts and Ends - Conveyors have two ends, respectively called the start and the end in FlexSim. Although these two ends are connected, they can be moved, rotated, and resized independently. The start is where flow items enter the conveyor and the end is where flow items leave the conveyor. Moving Conveyors - You can move or resize a conveyor as a single unit, but you can also move or resize the start and end of a conveyor as separate units. Rotation - Conveyors cannot be rotated on their X, Y, or Z axes, but you can change the height (Z axis) of either the start or end of the conveyors. Curved Conveyor Radius and Angles - In addition to the usual X, Y, and Z axes, the curved conveyor has controls that allow you to edit its radius, start angle, and sweep angle. Editing Controls - The editing controls also look and function differently on a conveyor. When a conveyor is highlighted, it will have a set of resizing arrows on both its start and end, as shown in the images below. The curved conveyor also has an additional green resizing arrow for adjusting its radius, start angle, and sweep angle. Each conveyor also has a direction indicator, which is a large unfilled arrow that shows you the direction the conveyor belt will move while operating. The rest of the sections in this topic will provide more detail about these differences. Adding Conveyors to a Simulation Model Many of the conveyor objects can be added to the model the same way you would add any other object from the FlexSim Library: you simply click on the object in the Library and drag it into your simulation. (See Adding 3D Objects to a Model for more information.) However, the straight conveyor, the curved conveyor, and the join conveyors each behave a little differently when added to a model. For instance, most of the other objects in the FlexSim Library have a default length, height, and width when you first add them to a simulation model. The straight and curved conveyor objects will have a default size if you click and drag them into the model. However, you also have the option to define the length and/or radius of the conveyors when you first insert them in your model, which will be discussed in the following sections. The Join Conveyors Object The unique properties of the join conveyors object will be discussed in more detail in the section about Connecting Conveyors . Adding Conveyor Objects with Default Dimensions If you want to add a straight or curved conveyor that has the default size, height, and width, simply click on the object in the Library and drag the conveyor into the model. This is essentially the same method for adding an object that you would normally use to add any other FlexSim object from the Library. Adding Conveyor Objects with Custom Dimensions The process for adding a conveyor object that has a custom length and/or radius is slightly different, but still relatively straightforward. To add a custom straight or curved conveyor to a simulation model: In the Library under the Conveyors group, click either the Straight Conveyor or the Curved Conveyor object to enter into conveyor building mode . When you are in conveyor building mode, your mouse pointer will change to a plus sign with either a Straight Conveyor icon or a Curved Conveyor icon next to it, as shown in the following image: Once in building mode, find the position in your simulation model where you want to place the start of the conveyor. When you click on that position in the model and start moving the mouse pointer in a different direction, you'll notice that it begins creating a conveyor object. Reposition the mouse pointer until the conveyor end is at the approximate length, angle, and radius you want it to be relative to the start. Click the mouse again to finish building the conveyor. Exiting Conveyor Building Mode You can continue to create more conveyors while you are in building mode or you can exit building mode by pressing the Esc key or right-clicking your mouse. You'll know you have exited building mode because your mouse pointer will look like a normal cursor again. Connecting Conveyors When you create a connection between a conveyor and another object, you make it possible for these objects to interact together. The most common way that objects interact in FlexSim is to transfer items from one object to another or send messages to another object. The process for connecting conveyors is relatively similar to the process you would use to connect any other object from the FlexSim Library. However, there are a few differences to be aware of. The following sections will discuss some of the different methods for connecting conveyor objects. Connecting Two Conveyors Conveyors will automatically snap together if they are close enough. To snap two conveyors together: Click on one conveyor and drag it close to the edge of the other conveyor. When the edges of the two conveyors get close enough, they will snap together. After you release the mouse button, a transfer will appear that connects the two conveyors together. The transfer will look like a small square box that overlaps the edges of the two conveyors: Transfer Settings You can customize how the two conveyors transfer objects together by changing the transfer's properties. See Working with Transfer Objects for more information. Using the Join Conveyors Object Even though the Join Conveyors object is in the FlexSim library, it actually functions more like a tool than a 3D object. You can use the Join Conveyors tool to connect two conveyors with a curved conveyor: In the FlexSim Library under the Conveyors group, click on the Join Conveyors object. You will then enter into conveyor joining mode . When you are in conveyor joining mode, your mouse pointer will change to a plus sign with a Join Conveyors icon next to it. Once in joining mode, click on the center of the first conveyor you'd like to join. After clicking on the conveyor, you'll notice that a yellow line will follow your mouse as it moves, similar to the line that appears when you are connecting two FlexSim objects. Click on the second conveyor you'd like to join. You'll then notice a new curved conveyor will appear between the two conveyors. Two transfer points will also appear on both ends of the new conveyor. Connecting Conveyors to Other FlexSim Objects You can connect conveyors to other FlexSim objects such as fixed resources the same way you would normally connect objects in FlexSim. (See Overview of 3D Object Flows for more information.) The primary way to connect conveyor objects to other objects is to create a port connection. However, unlike connecting normal FlexSim objects to each other, when you make a standard port connection (an 'A' connect) a conveyor to another FlexSim object, it will create a new entry transfer or an exit transfer, an in-between object that is associated with a specific point or range on the conveyor. An exit transfer is created when you connect a conveyor to another FlexSim object. An entry transfer is created when you connect a FlexSim object to a conveyor. Connecting Motors and Merge Controllers The motor and merge controller conveyor objects will usually only be connected to either a straight or curved conveyor. When connecting the motor and merge controller to a conveyor, you should use an input/output port connection (an 'A' connect). NOTE: This will not act like an input/output port but will merely serve as a reference point between the objects. You might possibly want to make a port connection between the motor and merge controller objects and a non-conveyor object such as a task executer. In that case, you should create a center port connection (an S-connect). A center port connection will allow the motor or merge controller to send messages to other non-conveyor objects. Moving and Resizing Conveyors Like other 3D objects, conveyor objects can be moved or resized using either the Quick Properties pane or your mouse. (See Moving, Rotating, Resizing 3D Objects for more information.) However, the key way in which conveyors are different is that they have resizing arrows at the start and end of the conveyor. Curved conveyors have an additional green resizing arrow that can be used to change the radius of curved conveyors: The following sections will explain the differences for using either a mouse or Quick Properties to move or resize conveyors. Using the Mouse to Move or Resize a Conveyor In order to use your mouse to move or resize a conveyor, you must first click once on the conveyor to highlight it. After you've taken that step, use the steps listed in following table: Task Process Demonstration To move the entire conveyor Click anywhere on the conveyor (except on the resizing arrows) and drag the conveyor to the desired position. To move either the start or end of the conveyor Click the resizing arrow on either the start or end of the conveyor. Drag the start or end to the desired position. To change the height (Z-axis) of the entire conveyor Click anywhere on the conveyor (except on the resizing arrows), and holding down both the left and right mouse buttons, move the mouse up or down until the conveyor is at its desired height. To change the height (Z-axis) of either the start or end of the conveyor Click the resizing arrow on either the start or end of the conveyor, and holding down both the left and right mouse buttons, move the mouse up or down until the start or end is at its desired height. To change the length of the conveyor Click the resizing arrow on either the start or end of the conveyor. Drag the start or end to the desired length. Additional Resizing Options for Curved Conveyors Everything in the preceding table applies to curved conveyors, but you can also use the green resizing arrow to change its length. See Changing the Radius and Angle of Curved Conveyors for more information. Using Properties to Move or Resize a Conveyor You might want the location, rotation, and size of the conveyor to be more precise in your model. In that case, it's generally a good practice to use your mouse to move or resize your conveyor until it is in the approximate position or size you want it to be. Then you can use the Properties pane to make it more precise. When you highlight a conveyor by clicking on it, the right pane displays the Properties for that specific conveyor. The controls that appear in Properties will vary depending on whether you clicked a straight or curved conveyor. Both kinds of conveyors have boxes that adjust the position and size of the start and end of the conveyor, as illustrated in the following image. However, curved conveyors have additional boxes that adjust the radius, start angle, and sweep angle. The following image shows the Quick Properties for a curved conveyor: Start adjusts the X, Y, or Z position of the conveyor's start. End adjusts the conveyor's end. A conveyor's length is based on the position of the start relative to the end. For example, if a conveyor is parallel with the X-axis on the grid with its start at the 0.0 position and the end is in the 10.0 position, the conveyor will be 10 units long. The same is true for the other axes. Experiment with some of the Properties to get your conveyor exactly the way it should be. Changing the Radius and Angle of Curved Conveyors Curved conveyors have three additional properties: Radius - The radius of the conveyor relative to the midpoint of the hypothetical circle around which the conveyor is drawn. Changing the radius will affect the length of the conveyor because it makes this hypothetical circle larger. Start Angle - The angle of the start end of the conveyor relative to the simulation model grid. For example, if the start angle is set to 90, the edge of the conveyor's start direction will be perpendicular to the x-axis of the model. Sweep Angle - The angle of the end of the conveyor relative to the start angle. For example, if the start angle is set to 45 and the sweep angle is set to 90, the edge of the conveyor's end direction will be 135 degrees offset from the x-axis of the model. You can use either the mouse or the Properties pane to change the radius, start angle, and sweep angle of curved conveyors. To change the radius, start angle, or sweep angle of a curved conveyor, you must first click once on the conveyor to highlight it. After you've taken that step, use the steps listed in following table: Task Process Demonstration To change the radius Click the green resizing arrow in the middle of the curved conveyor and drag the mouse to the desired radius. To change the start angle Click the red resizing arrow on the start end of the curved conveyor and drag the mouse until the edge of the start is at the desired angle. To change the sweep angle Click the red resizing arrow on the end of the curved conveyor and drag the mouse until the edge of the end is at the desired angle. Reversing the Direction of a Conveyor Every conveyor has a large arrow on it that indicates which direction flow items will travel on the conveyor: To change the direction that items travel on a conveyor: Click the conveyor to highlight it. In the Properties pane, under the Conveyor group, click the button. The direction indicator on the conveyor will now point in the opposite direction. Can Conveyors Be Reversed During a Simulation Run? To dynamically reverse a conveyor's direction during a simulation run, set the conveyor's targetSpeed property to a negative number. For more information, refer to the Conveyor FlexScript documentation. Copying Conveyors Conveyors can be copied and pasted using many of the same methods you would use to copy and paste other 3D objects. See Copying and Pasting 3D Objects and Properties for more information. However, if you know that you're going to build many similar conveyors with similar properties and logic, you should create a specific conveyor type for your conveyor. That way when you build any other conveyors, you can assign it to that particular conveyor type and it will immediately import the pre-defined settings you saved. See the next section for more information."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/ConnectingFlows/Conveyors/WorkingWithTransfers/WorkingWithTransfers.html",
        "title": "Working With Transfer Objects",
        "content": "Introduction to Transfer Objects Whenever you connect a conveyor to another conveyor or to a fixed resource in the 3D model, FlexSim will automatically create a transfer between those objects. (See Connecting Conveyors for more information.) There are three kinds of transfer objects, as explained in the following table: Name Description Appearance Transfers Transfers are connections from one conveyor to another. They can affect how an item is transferred between conveyors, especially when merging lanes together. Entry Transfers Entry transfers are connections from a non-conveyor object (such as a source or other fixed resource) to a conveyor object. They can affect how an item is transferred to a conveyor. Exit Transfers Exit transfers are connections from a conveyor to a non-conveyor object (such as a sink or other fixed resource). Exit transfers have the ability to send for a transport (a task executer) to pick up items and deliver them to another object. Task executers can pick up items from a particular point on the exit transfer or a range of possible points along an exit transfer. Moving Entry or Exit Transfers Flow items will enter or exit a conveyor from the place in the conveyor where the entry or exit transfer is positioned. You can move an entry or exit transfer by dragging it to a different position on the conveyor, as shown in the following image: Expanding the Range of a Transfer You can expand the range of entry and exit transfers if needed. The most common reason for expanding an exit transfer is to increase the range of possible pickup or drop-off points that a task executer can use to pick up items along a conveyor. To expand the range of a transfer: Create a port connection (A-connect) from a conveyor to a fixed resource, such as a sink. An exit transfer will appear at the end of the conveyor. It will look like a white box with a port connected to the fixed resource. Click on the exit transfer and drag it to the desired position on the conveyor. Two red sizing arrows appear on both sides of the exit transfer when you click on it. Click either red sizing arrow and drag it away from the exit transfer until it reaches the desired size (range). Using a Transport with Exit Transfers Exit transfers have the ability to send for a transport, or in other words a task executer, to pick up items and deliver them to another object. Task executers can pick up items from a particular point on the conveyor or a range of possible points along the conveyor, as shown in the two following images. The following image shows an exit transfer with a single possible pickup point: The following image shows an exit transfer with a wide range of possible pickup points: The task executer will begin traveling toward the exit transfer as soon as the center of an item arrives at the edge of the exit transfer on the conveyor. If the exit transfer has a wide range of possible pickup points, the task executer can pick it up anywhere along the exit transfer, as shown in the following image: You also have the option of allowing the task executer to use continuous pickup point prediction , which means that the task executer will recheck the position of the item as it moves down the conveyor and alter its course to a different pickup point based on how the item is predicted to move along the conveyor. To use a transport to pick up items and deliver them to another object: Create a center port connection (S-connect) from the exit transfer to a task executer, such as an operator. Click the exit transfer to open the Exit Transfer Properties on the right. Check the Use Transport check box. By default, the exit transfer will request a transport from the task executer because they share a center port connection. You can adjust these settings if desired. A task executer can modify its course while it is traveling to the item pickup point if there is a wide range of possible pickup points. The task executer can estimate and change where it can pick up an item based on the item's movement along the conveyor. To use this feature, check the Continuous Pickup Point Prediction check box. You can adjust how frequently the task executer updates its predictions by changing the value in the Prediction Adjustment Interval text box. The value you enter corresponds to the units of measurement for time that you used when you first created your simulation model. Click OK to save the settings. When you reset and run your model, the task executer will pick up the item from the conveyor and deliver it to a fixed resource. Side Transfers and Inline Transfers When you are transferring from one conveyor to another, the angle of the transfer affects the logic of the transfer. If you are merging a slug of items, the angle could affect whether the conveyor treats the transfer as a side transfer or an inline transfer. The following table explains some of the differences between side transfers and inline transfers: Side Transfer Inline Transfer Default Definition Any transfer angle that is greater than 45 will be treated like a side transfer by default. Any angle that is less than 45 will be treated as an inline transfer by default. Item Orientation The orientation of the flow items will change after the transfer. The item's leading edge in the upstream conveyor becomes the side edge on the downstream conveyor and vice versa. The orientation of flow items remain the same after the transfer. Gapping When a conveyor is transferring items from the side of the conveyor, it will add gaps between flow items. The width (transverse size) of an item on the upstream conveyor becomes the length (inline size) of the item on the downstream conveyor. No gaps will be added between flow items. Items will transfer more smoothly from one conveyor to another because the angle of entry is smaller and more closely matches the direction of the merging conveyor. Movement While the item is being transferred, its movement is in-line with one of the conveyors, but is stopped relative to the other conveyor. On an inline transfer, the movement of the item is in-line with both the upstream conveyor and the downstream conveyor throughout the transfer of the item. Understanding the Physics of Side Transfers Sometimes the gapping behavior of side transfers is confusing to users. Take the example of an item being pushed/merged onto a conveyor from the side. While the item is being pushed onto the conveyor, it is moving with the direction of the upstream conveyor that is pushing it on, but it is essentially stopped relative to the conveyor it's merging onto. Once it has finished being pushed on, it will then take the convey direction of the downstream conveyor. This difference is what causes gaps to be created when merging slugs. To change whether FlexSim treats a transfer as a side transfer or inline transfer, you'll need to change the angle threshold in the transfer properties. The property that handles this setting is the Max Angle property. The step-by-step process for changing the angle threshold is covered in Conveyors Tutorial 1.3 - Adding and Removing Gaps ."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/ConnectingFlows/Conveyors/CreatingConveyorLogic/CreatingConveyorLogic.html",
        "title": "Creating Conveyor Logic",
        "content": "Introduction to Conveyor Logic This topic will explain how to create different types of flow logic using conveyor objects. It will cover the most common conveyor systems that you might want to create. Before reading this topic, make sure you are familiar with the concepts explained in Key Concepts About Conveyors . Using Conveyor Logic Objects Decision points, stations, and photo eyes are the primary conveyor objects that are involved in controlling conveyor logic. For the sake of brevity, this guide will refer to these three types of objects as conveyor logic objects . To use these objects, first you need to add one of them to a conveyor. Make sure that the object is at the point on the conveyor where you want something to happen to a flow item (such as diverting the item to a different conveyor line, delaying and processing the item, changing a label on a item, etc.). Next, open the object's properties and apply the logic you want to the appropriate trigger. All three of the conveyor logic objects come with a set of pre-programmed picklist options that simulate some of the most common logic. You can use these picklists, or you can write your own custom logic with FlexScript. For example, imagine you need to simulate a flipper on a conveyor that will mechanically rotate items 90 degrees so that they are aligned the correct direction. You could simulate this logic using a decision point and set its On Arrival trigger to use the Rotate Item logic: You can also create port connections between decision points, photo eyes, and stations so that they can reference each other, possibly sending flow items or information to each other. For example, imagine you wanted to randomly divert 30% of flow items to a separate conveyor. You could simulate this logic using two decision points. One is on the main conveyor line and another is on the diverting conveyor line. You would then create port connections (A-connects) between the two decision points. Next, you'd set the On Arrival trigger on the first decision point to use the Send Item logic to divert 30% of the flow items to the second decision point: Want to Create This Simulation Model? You'll create this conditional sorting conveyor system and other simulation models in the Conveyors Tutorial . Which Conveyor Logic Object Should I Use? The conveyor logic objects all have the same basic logical functionality: they all have triggers that are capable of executing pre-programmed or custom logic when a flow item passes over them. However, there are small differences between decision points, stations, and photo eyes that are good to be aware of: Triggers - The names of the triggers are slightly different for some of the objects. These triggers also fire at different times during a simulation. Decision points and stations have On Arrival and On Continue triggers while photo eyes have On Block and On Clear triggers. Process Times - Decision points and stations are nearly identical, but stations add some additional functionality that make them similar to the 3D processor object. You can add a processing time, require an operator, and specify the conditions under which an item should or should not be processed at the station. Stations also have an additional On Process Finish trigger. Gapping Logic - Photo eyes have the ability to respond to conditions in which they are blocked or clear, such as when there is a backup of flow items on the conveyor. You can also set the conditions that determine how long the photo eye needs to be covered or uncovered before it can be considered blocked or cleared. You can also set things like the angle of the photo eye and the visual colors of the photo eye when it is in a blocked or cleared state. Use the appropriate conveyor logic object based on the functionality needed in your conveyor system. Additional Conveyor Logic Objects The merge controller and motor objects are also important to conveyor logic, but they will be explained in more detail in the following sections. Merge controllers are used primarily when merging slug-building conveyors (see Merging for more information). Motors are useful for power and free systems and for connecting multiple conveyors so that they all operate at the same speed and can be turned on or off simultaneously (see Power and Free Systems for more information). Overview of Trigger Picklist Options The following table provides a general overview of some of the pre-programmed picklist options that are available on the triggers for conveyor logic objects: Name Description Send Item Can send items to different destinations (such as different conveyor lines) based on criteria you specify. See the section on Sorting for more information. Stop/Resume Can set conditions that can make a conveyor motor stop or restart. See the section on Stopping or Starting a Motor . Stop Item and Delay Can stop and/or delay an item Area Restriction Can create an area that only allows a fixed number of items to flow through a restricted area on the conveyor at a time. See Area Restriction for more information. Movement Can rotate, tilt, or move items at a particular point on a conveyor. See Flow Item Movement for more information. Set Conveyor Speed Can change the speed of the conveyor based on certain conditions Sorting Conveyor systems use sorting (sortation) when items need to be transported to different destinations based on certain criteria. To simulate sortation conveyor systems in FlexSim, you'll need to use a conveyor logic object (a decision point, station, or photo eye). These objects have a pre-programmed picklist option called Send Item that can sort items based on certain criteria and then send them to various destinations through its port connections. The Send Item picklist option has two properties that determine how it should sort items: Condition - This property decides \"Should I divert this item?\" and sorts items based on particular conditions. Destinations - This property decides \"If the condition is met, which destination should I send the item to?\" and sorts items to multiple possible destinations based on criteria you define. This property usually points to another conveyor logic object or transfer that is connected to its output port(s). You can use a combination of different settings in these two properties to build complex sorting logic into your conveyors. The following sections describe some of the common sortation systems that you can build in FlexSim. Want to Create These Sortation Systems? You'll create all of the following sortation systems in the Conveyors Tutorial . Conditional Sorting Conveyors can sort flow items based on a simple true or false condition. If a flow item meets the condition in the Send Item Condition property, it will get diverted to the conveyor logic object's output port. For example, in the conveyor system shown in the following image, 30% of the flow items will meet the condition and will be diverted to an alternate conveyor line. The On Arrival trigger for the first decision point is assigned the Send Item picklist behavior. The Condition property is set to randomly return a true value 30% of the time. When it returns a true value, it sends the flow item to the diverting conveyor line. Destination-Based Sorting Conveyors can also sort flow items based on the destination. The Send Item Destination property returns a reference to an object. This object should be a conveyor logic object or an exit transfer on the item's current conveyor. For example, in the conveyor system shown in the following image, flow items are sent to the conveyor that matches the number in the type label on the flow item. There are five different flow item types (each with a different color). The On Arrival trigger for the first decision point is assigned the Send Item picklist behavior. The Destination property is will evaluate the type label on the item and send it to the output port that matches that number. Fixed Resource Sorting In the same way that you can sort items using the Send Item picklist to send items to a conveyor, you can also send items to a downstream fixed resource. For example, the conveyor system shown in the following image is similar to the simulation model in the previous section. However, the last conveyor has a decision point that sends items to the queue connected to a particular exit transfer based on their type label. Merging Merge conveyors can organize items flowing from multiple infeed conveyor lines. The most common purpose of merging is to combine items from multiple conveyor lines into a single line, which then sends the items downstream for further processing. This section will describe how to use FlexSim conveyor objects to create various kinds of merges. It will also discuss accumulation methods that could possibly be used when merging items. Want to Create These Merging Systems? You'll create all of the following merging systems in the Conveyors Tutorial . Basic Merging You can create simple merges by snapping conveyor lines together and using conveyor logic objects. Slug Building The conveyor industry uses the term slug to refer to a queue of accumulated items on a conveyor that will eventually be released downstream as a single group. Building slugs of items can maintain high rates of throughput while keeping equipment speeds as slow as possible. You can design a conveyor that builds slugs and waits to release them based on a specific set of criteria such as: What percentage of the conveyor must be filled before a slug is ready for release The number of items that must be on a conveyor before a slug is ready for release The amount of time that must elapse in building the slug before a slug is ready for release For example, in the following image, each conveyor in this system is set to build a slug of at least four items before it can be released: In the properties for your conveyor: Check the Slug Builder check box to enable slug building. Then, in the Ready Criteria , check the boxes next to the conditions you would like the conveyor to use when determining a slug is complete and ready for release. Sawtooth Merging Using the Merge Controller The merge controller object can be used to reduce the gaps and prevent collisions between slugs as they move onto the merging conveyor. Its logic is defined by its two main properties: 1) Release Strategy, and 2) the Lane Clear Table. These two properties determine how it will prioritize merging lanes. The Release Strategy has two pre-programmed options: round robin logic or first available logic. If you are comfortable with FlexScript, you can also create your custom release strategy. The Lane Clear Table prevents merge jams and shortens the gaps between slug releases. The rows and columns are automatically be generated based on the objects the merge controller is connected to, but you can edit the table to change the order in which rows and columns are listed. The X's in the columns define which decision point (or other conveyor logic) needs to be cleared before the merge controller can release a slug from a particular lane. In the following image, the merge controller communicates with decision points to close the gaps in between slug releases: Sawtooth Merging Using Process Flow You can use a template Process Flow to create logic that will close the gaps in between slugs even more. The following image is an example of a merging conveyor system that uses process flow to determine the ideal release rate: To add this process flow to your model, press the Process Flow button on the main toolbar, then choose Add an Object Process Flow > Gap-Optimizing Merge Controller . Then attach an existing merge controller to that process flow. Here is the process flow that manages this merge: Power and Free Systems Power and free conveyor systems are implemented in many manufacturing environments. In these systems, dogs travel at fixed intervals along a looping chain. These dogs pick up carrier trolleys in the system as they pass them. FlexSim simulates power and free systems by tracking the location of dogs on a conveyor or conveyor system. The point at which an item can move on the conveyor is defined by the location of the next passing dog. When an item is ready to move, it catches a dog. Often the movement of items has a caterpillar-like accumulation effect. Want to Create This Power and Free Conveyor System? You'll create this power and free system in the Conveyors Tutorial . In the properties for your conveyor: Check the Fixed Interval Movement (Power and Free) checkbox to enable power and free behavior. If needed, change any of the other power and free properties (such as which item is the leading edge or the spacing in between the dogs). Using a Motor to Sync Dogs Although you are not required to use a motor in a power and free system, using a motor is recommended. Motors can help sync the dog positions across multiple conveyors in a power and free system. For example, if the motor's first connected conveyor is 10.2 meters long, and the dog gap is 1.0 meters, then it will set the dog position to start at 0.0 on the first conveyor and at 0.8 on the second connected conveyor (the remaining distance to the next dog after the end of the first conveyor). The motor prevents the conveyors from creating irregular gaps or stops when transferring items between conveyors. To use a motor with a power and free system: Connect a motor to all of the power and free conveyors in the order that items will flow from one conveyor to another. Motor Connection Order When using a motor to connect power and free conveyors, it is important to ensure that you connect the conveyors in the correct order or else the dog positioning will be incorrect. You can adjust the port rankings in the motor's properties window under the General tab. Click the motor to open its properties window on the right. Check the Sync Power and Free Dog Positions box under the Motor section. If you are using the motor to sync the dog positions across an entire loop, check the Adjust Dog Gap for Continuous Loop box. Creating Overhead Conveyors To create an overhead power and free system you'll need to translate the z-axis of the item: Put a conveyor logic object (a decision point, station, or photo eye) at the beginning of the first conveyor in the power and free system. Click on the conveyor logic object to open its properties window on the right. In the Triggers section, click the Add button to open a menu of possible triggers. Select either On Arrival or On Block . Click the Add button next to the newly added trigger to open a menu. Select Movement then, Translate Item . Set the Conveyor Up setting to a negative number, such as -item.size.z or -2 , and it will hang below the conveyor while moving. Raise the Conveyor Height You might also want to raise each conveyor's Z-axis so that they are higher off the ground. Stopping or Starting a Motor Conveyor logic objects (decision points, photo eyes, stations) can be set to stop, delay, and/or start a conveyor's motor when certain conditions are met. For example, if a photo eye is blocked, it can stop the motor until the photo eye is clear again. Any conveyors that are connected to the motor will be stopped until the motor resumes. You can use the Stop Motor or the Stop Motor and Delay picklist behavior option on a conveyor logic object to stop a conveyor. Just make sure you also add a condition under which the motor will restart again using the Resume Motor picklist behavior. In order to effectively stop a motor, ensure the following conditions are met: Connect the motor to the conveyor logic object(s) with a center port connection (an S-connect). Connect the motor to all the conveyors it should control (with A-connects). Add the Stop Motor or Stop Motor and Delay picklist behavior to the appropriate triggers on a conveyor logic object. Determine which conditions should cause the motor to stop and add those to the Condition property. Make sure that there is a condition under which the motor will restart again. Use the Resume Motor picklist behavior on the appropriate trigger to create this condition. Flow Item Movement You can use a conveyor logic object (decision point, station, or photo eye) to move or change a flow item when it passes over it. The triggers on conveyor logic objects have pre-programmed picklist behaviors to help with many of the common movement actions you might want to do. Use the Movement submenu on a trigger if you want to change the item's location or orientation (rotation, tilt angle, etc.). The Movement submenu has two options: Rotate Item and Translate Item. The Rotate Item picklist rotates the item as it passes over the logic conveyor object. The Translate Item picklist moves the item's position relative to the conveyor. See Creating Overhead Conveyors for step-by-step instructions about using the Translate Item option. The Rotate Item and Translate Item options use kinematics-based offsets. When you use one of these picklist options, be aware they don't change the item's properties, logic, or orientation (with some exceptions, as noted below). Their logic is mostly just visual. Keep in mind: You will likely not want to translate the item along the conveyor-forward axis (forward or backward along the conveyor) because it might make other conveyor logic fire at strange points visually. That's because the item has been visually offset forward or backward from the location where the conveyor is actually tracking it. If items are offset on the conveyor-left axis, and they pass over photo eyes with an offset angle applied, they will still cover/clear the photo eye as if they were in the center of the conveyor. However, there are some exceptions to this visual-only rule: When an item starts a side transfer, the transfer logic will take the item's conveyor-left offset into account in determining how far the item must move to complete the transfer. If a photo eye's height is non-zero, then when an item's front edge reaches the photo eye, the cover logic will take the item's current conveyor-up offset into account in determining whether the item covers the photo eye. Area Restriction Area restriction can be used to restrict access to a particular conveyor or a segment of a conveyor. For example, you could create an area that only allows one flow item into the area at a time, as shown in the following image: To create an area restriction system: Add at least two conveyor logic objects (such as decision points or photo eyes) to the conveyor system. The upstream conveyor logic object(s) will designate the entrance to the restricted area and the downstream conveyor logic will designate the exit for the restricted area. Create an input/output port connection (A-connect) from the upstream conveyor logic object to the downstream one. Add an appropriate trigger to the conveyor logic object (such as an On Arrival or On Block trigger.) On the newly added trigger for the upstream conveyor logic object(s), add the Acquire Restricted Area picklist option. Add another trigger to the downstream conveyor logic object. Then, add the Release Restricted Area picklist option to that trigger. What Goes In Must Come Out Always remember that if you use logic that puts a flow item in a restricted area, you need to also have logic that indicates when that flow item has left the restricted area. Otherwise the restricted area will never be released and will jam up the conveyor. To prevent this problem, make sure you always both an Enter Restricted Area and a Release Restricted Area picklist together in the conveyor system. You can work through a few examples of area restriction in Conveyors Tutorial 1.2 - Merging, Area Restriction, and Slug Building and Conveyors Tutorial 1.3 - Adding and Removing Gaps . Adding and Removing Gaps You may or may not want gaps between your flow items when you merge one conveyor lane into another. Adding Gaps The Area Restriction picklist can actually be effective for adding gaps to a conveyor line. It can be used to add both fixed and variable gapping to flow items. See Area Restriction for more information. Removing Gaps Usually the primary reason why you want a conveyor system is to reduce gaps between flow items, which increases your system's overall throughput. If you want to remove gaps in between merging flow items, you can do one or all of the following steps: Change the conveyor angles - Change the angle of the feeding conveyor relative to the merging conveyor, possibly using the Join Conveyor tool to create curved conveyor sections between these conveyors. Adjust the transfer settings - Adjust the angle settings for the transfer between the conveyors to increase or decrease the threshold at which the angle is considered a side or inline transfer. See Side and Inline Transfers for more information. Use more decision points with a merge controller - Increasing the number of decision points along the merging conveyor line can increase the rate at which a merge controller releases slugs. Use the process flow template - The merge controller process flow template can decrease gaps and improve throughput dramatically. The step-by-step process for removing these gaps will be explained in Conveyors Tutorial 1.3 - Adding and Removing Gaps . This tutorial has additional tips and techniques you can use to affect gapping in conveyors."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/ConnectingFlows/Warehousing/KeyConceptsWarehousing/KeyConceptsWarehousing.html",
        "title": "Key Concepts About Warehousing",
        "content": "What are FlexSim's Warehousing Tools? FlexSim has a robust set of tools for modeling warehousing facilities. These warehousing tools will help you analyze the many aspects that go into complex warehouse and storage design. With these tools you can create realistic multifaceted models for data analysis. Before creating a complex warehousing model however, it’s recommended that you simplify the model concept as much as possible early on. Warehousing models have many dimensions that can get very complicated very quickly. The first recommended step therefore, is to determine the question and specific data that you are trying to gather from your model. It is valuable to begin a warehouse simulation with a specific question because this will give your model direction in your design. Eliminate any details from the modeling process that don’t help to answer this question. If an element is not critical to examining the question you’re trying to answer, then you can save yourself extra work by abstracting and making educated assumptions about those elements. Some examples of incomplete or difficult questions might be: How do I optimize my throughput? How do I improve my order turnaround time? These questions are too open-ended and vague. They don’t define enough measures to determine what’s \"optimal.\" These types of questions often lead to overly complicated models that are challenging to parse through, because any element could potentially affect these vague measures. A good question, on the other hand, will include both a proposed change and a performance measure to compare against. Some examples of good questions to ask include: Will this proposed racking system be able to handle the picking throughput I need? Which of these two layouts renders the lowest turn-around time from order to shipment? Do we have enough racking in our facility to handle projected inventory levels? Most important is to figure out what data you need to extract from your model. Once you’ve determined the data that you need from your model, there are several areas of consideration about building a warehouse model: Laying out your warehouse, monitoring inventory, and retrieving product. For more detailed advice and information, please refer to the article detailing concepts of Project Goals and Scope . Laying Out Your Warehouse When designing a warehouse simulation, one of the key elements to determine is the layout of the warehouse itself. How and where are items going to be stored? Where do operators and transports need to be able to access? How are items going to be addressed and zoned? The Storage System Whenever you drag out a rack object into a model for the first time, you will notice that FlexSim will create a new object in your Tools folder. If you click on the Toolbox tab on the left panel of the screen, you can find the Storage System object listed there. This Storage System centralizes the logic of your racking and warehousing objects into a single hub. Labels, rack visualization, addressing schemes, and triggers can all be created and controlled from the Storage System object. This document will reference the Storage System tool in the sections below, but for a full complete reference to the Storage System and its features please refer to the Storage System Documentation . Bays, Levels, and Slots and the Dimensions Tab The organization of racks is setup in a matrix style grid or table made up of bays, levels, and slots. If you click on a rack object in the 3D view, you can open its properties in the Properties Window. Under the Storage Object section click the Edit Dimensions button and you will see the following table. (It might have some alterations based on which type of rack you clicked on, but the same basic system works across all rack types.) In this view you can see how the bays, levels and slots of a rack are organized. Bays represent the areas along the horizontal axis, levels are the spaces along the vertical axis, and slots refer to further divisions of space within each bay and level \"cell.\" For more detailed information please see the reference document on the Dimensions Tab of Storage Objects . Bay and Level Progression The Pick-Face of a rack is the side of the rack that Operators and Transports will load items from. In a typical warehousing environment this is where Pickers retrieve items from a rack’s shelves. This is where the term \"pick-face\" comes from; it’s the face of the rack that is picked from. You can consider the pick-face of a rack to be the \"front\" side of the rack for logical purposes. There you can see how bays and levels are counted. In the default settings, the bay’s count progresses, starting at 1, from left to right, one bay at a time. Levels are counted the same, starting from bottom up to the top. This count is what is referred to as Bay/Level Progression , and the count is what is referred to as Bay Stride . In the Address Mapping section, you can change how the rack will count its Bay and Levels, as well as the Rack to an Addressing Scheme . This document will go into more detail about Address Schemes later on. For more detailed information on setting Bay and Level Progression and Stride, please see the reference documentation on the Storage Object . Assigning and Finding Locations and Items Once you’ve determined the layout of your warehouse, the next step is to determine how you are going to assign locations to the items stored in the warehouse. There are multiple ways to do this. If you have an Order Table, or some kind of inventory spreadsheet that contains address information for product, you can set up an Addressing Scheme in Storage System properties window. Alternatively you can use some of the Storage.system commands to create rules or queries to determine the slot for an item. Addressing Schemes If you already have a table of inventory data with SKUs and address information (such as an Order Table, or an In-Bound Table for arrivals) then you can implement an Address Scheme from your Storage System tool in the toolbox. If you haven’t done so already, you can drag out any rack object into the model, to initialize the Storage System object in the toolbox. Once a rack is created in a model, the Storage System object will automatically be initialized in a model. You can open the Storage Systems properties window, by selecting the Toolbox tab, and double clicking on the Storage System listed in your tools. Once open, you can select the Address Schemes tab to bring up the information and details for creating Address Schemes. Here in the Address Schemes tab you will find multiple fields to help create and maintain multiple Addressing Schemes for your project. The top field displays the currently selected theme, and next to the field are multiple buttons for creating, copying, deleting, and reordering the Address Schemes. Generally speaking, a warehouse will only use a single addressing scheme. However, you can create as many Address Schemes as your model logic needs. This may be useful if, for example, you want to simulate a facility that has multiple separate buildings that each use completely different addressing schemes. The next field line has an Example of how your selected address scheme is written. Before you begin to define your own address scheme, it is important to understand the elements that make up the different parts of an address. From the largest grouping to the smallest, addresses may be made up of Zones, Aisles, Bays, Levels, and Slots. The Zone ID represents the largest categorization of location in the warehouse, usually meant to refer to an area in the warehouse that includes a group of racks. Aisle ID refers to the aisle that a group of racks could belong to. Bay ID refers to the bay in the rack, followed by Level ID . And Slot ID is the specific location that an item is going to be assigned to. You should notice that with the default scheme selected, the Example field will read as Z-A-1-1-1. This string of characters provides you with a sample of what an address String for this Address Scheme will look like. In this case the first character represents the Zone. Then a dash, followed by the second character representing the Aisle. Then further dashes separating the Bay, followed by the Level, and then finally the Slot. When searching for a location Slot by address, this string is an example of what will be passed into the search parameter. For more information please see the Address Scheme Tab in the Storage System documentation . Once you’ve either created or selected an Address Scheme, you can now assign Racks to be included in that scheme. You click on a Rack object to open its properties on the right, and under the Address Mapping section, you can select your Address Scheme from the corresponding dropdown menu. Once a scheme is selected, you can assign a Zone or Aisle ID. Getting Slots Using Addresses with FlexScript Once you have an addressing scheme set up, there are some simple FlexScript commands that you can use, to get a slot and assign an item to that slot. FlexSim has a Storage class used in FlexScript commands that deal with any of the Storage Objects and Warehousing tools. To learn more in depth about the Storage.System class and its functions and attributes, you can look at the Storage.System FlexScript API . Using the Storage.system.getSlot() method you can get a Slot based upon the address you pass in. The method expects a string, and it will match the characters of the string against any Address Scheme that has been set up in the model. If the address matches the scheme, it will locate that slot, and return that slot. From there the slot can be assigned to the item. The following Process Flow is an example of how you could get a slot, assign it to a label on the token , and then assign the retrieved slot to the item. Using an Assign Labels activity we can assign a label to a token. selecting from the picklist options on the value of the label, we can select the Get a Storage Slot by Address selection from the Warehousing menu. You will notice that the value field of the label now has the getSlot() command. It will by default enter a filler label as the parameter value; you can enter your address string or a label with the address string as the parameter value. Once you have a Slot assigned, it's a good idea to have a check making sure the slot was aquired. This can be done using a Decison activity. Simply use a conditional decision type, and have token.Slot (or whatever your Slot label is) as the condition. This will determine if the Slot was aquired. Finally, you then need to assign the aquired Slot to the item. If an item has a Slot assigned to it, the logic in the Racks will be able to determine how and where to place that item. To assign the slot to the item you can use a Custom Code activity. In the picklist options of the Custom Code activity, under the Control section, you will see a Warehousing subsection, select the Assign a Slot (direct) option. The activity will then provide you with two fields to define the Item and Slot respectively. In addition to Process Flow, you could also write a script to retrieve and assign the Storage Slot as well. The following script is an example of how you might get a Slot and assign it to an item using FlexScript. Storage.Slot slot = Storage.system.getSlot(\"1-A-1-3-2\"); if (slot && slot.hasSpace(item)) { Storage.Item storageItem = Storage.Item(item); storageItem.assignedSlot = slot; } token.Slot = slot; This script declares a \"slot\" variable of the System.Slot class. We assign it a value by using the Storage.system.getSlot() function, passing in a string that matches an Address Scheme in our system. The function will then find that slot based on the address and return it as a value. The next lines of code then ask if a slot was retrieved, and if it has space for our item using the slot.hasSpace() function. If so, the slot is assigned to the item. Assigning slots to items is a crucial step, because once the item has a slot assigned to it, if the item is then moved to the rack containing that slot, the item will be placed automatically into the corresponding assigned slot. Setting Up Labels on Slots Another way of assigning slots and slot values, is to use labels. In the Storage System object’s properties, you can click on the first tab named Slot Labels. This window will be blank by default, but by clicking on the green \"+\" sign you can add a label for all the slots in your Storage System. This would be a good way to attach a Type label to the slots, for example. Once a new label is created here, you will notice several fields that give you options for the newly created label. The first field is the name of the label, then you can select a Color Palette from your s election of Color Palettes in your model (See the Color Palette reference documentation for more information). The Indexed checkbox will allow you to select whether the label is indexed or not. (See the Slot Labels reference documentation for more information about indexing.) Finally, the last field will let you determine if the label has a Default Value . Finding and Assigning Slots from Labels If your racks and storage system are set up with labels, you can use one of the functions of the Storage class to now search for a Slot to assign to your item. Much like the ability to get a slot and assign it using the address system. The Storage class also has a function to find a slot through a query of the labels instead. Using SQL syntax, you can pass a query as a string into the Storage.system.findSlot() method to return a slot you can then assign to your item You can set this up in Process Flow much the same way you'd set up getting a slot using the Address method. Again use an Assign Labels activity and use the picklist options when assigning a value to your label. Select the Warehousing section and choose the Find a Storage Slot option. This will provide a gui where you can enter a query, and fields where you can identify objects in your query. If you were to query your Storage System for a Slot by type your query would look something like this: WHERE Type IS $1.Type You could then identify $1 as the token with the Type label. This query will return a Storage Slot where the Type label of the Slot matches the Type label on the token. As documented previously, you could then use a Decide activity to determine whether a slot was retrieved, and a Custom Code activity to assign the retrieved slot to the item. Just as with the getSlot() method, you could also use the findSlot() method using FlexScript. The script and query might looks something like this. Storage.Slot slot = Storage.system.findSlot(\"WHERE Type = $1.Type AND slot.hasSpace($1) ORDER BY RAND()\", 0, item); if (slot) { Storage.Item storageItem = Storage.Item(token.Item); storageItem.assignedSlot = slot; } token.Slot = slot; This script declares a variable \"slot\" to act as the slot we are trying to get. We assign it a value, by using the Storage.system.findSlot() function, and passing in a query. The first parameter in the function is a string of the query. This query asks the Storage System to find a slot where the Type label of the slot matches the Type label on the item, and to check if the slot has space for the item, then to randomly order any matching slots as the returned slot or slots. The next parameter in the function is a 0, this is a reserved parameter for FlexScript, and must be 0. Finally, the last parameter is the value that will be represented by $1 in the query, and every optional parameter after would be further represented by $2, $3, $4, etc. The next lines of the code ask if a slot was returned by the function, and if so, to assign the retrieved slot to item that is going to be stored. Assigning Slots to Items It's important to remember to assign the retrieved Storage Slot to your flow item, so that the Storage System can move the item to the correct location when the Item is placed inside one of the Racks. Find Slot Process Flow Activity Another approach to the above two examples is to use the Find Slot activity to get a slot as well as assign an item to that slot. Using the Find Slot activity, you can define multiple queries to find slots, using addresses, labels, properties and more. If a slot is not immediately found, the token will remain in the Find Slot activity and will listen to the On Exit of the Storage System. As items exit the storage system, the queries will be reevaluated until a matching slot is found. The Find Slot activity performs all of the steps listed in the above examples but within one activity. The following process flow is an example of how you could find a slot, assign it to an item and move that item into the storage object. Finding and Retrieving Items Just as you can use the Storage.system.findSlot() method to find slots and assign them to items, you can also search the storage system for items using Storage.system.findItem() . The parameter of the function expects a string query just as the function for finding slots does. However, whereas Storage.system.findSlot() returns a reference to a Storage.Slot , Storage.system.findItem() instead returns a reference to a Storage.Slot.Item . Once you've found an item in the storage system, you can execute logic to retrieve that item. Just as you would create a process flow for finding a slot, you can create a similar flow for finding an item. Create an Assign Labels activity as you would when finding a slot. In the Value field of the Assign Labels activity, use the picklist options to select the Warehousing section, and select the Find Storage Slot Item selection. This will bring up a field for writing a query, and fields for identifying terms within your query. If you were to write a query to search for an item by its Type label, the query might resemble something like this: WHERE Type = $1.Type The '$1' is being used to identify the token in the process flow in this case. This query will search all the items, in the storage system for an item with a Type label that matches the token's Type label. You could add to this query to further narrow your selection by location or distance, etc. Likewise, you can use this command within FlexScript. Here is an example script using the Storage.system.finditem() function. Storage.Slot.Item slotItem = Storage.system.findItem(\"WHERE Type = $1 ORDER BY RAND()\", 0, token.Type); token.Item = 0; if (slotItem) { slotItem.storageItem.assignedSlot = 0; token.Item = slotItem.item; } In this example code, we are declaring a variable called slotItem which is an instance of the Storage.Slot.Item class. We call the Storage.system.findItem() function, which runs the query and returns a matching slot item if it finds one. The next lines of code then assess whether a slot item was returned, and if so, it stores the slot item's associated item object on a token's Item label. From here we now have a reference to the found item through that Item label and can execute logic to retrieve the item or any other logic we want to apply. Find Item Process Flow Activity Another approach to the above example is to use the Find Item activity to get an item as well as mark that item as outbound. Using the Find Item activity, you can define multiple queries to find items using addresses, labels, properties and more. If an item is not immediately found, the token will remain in the Find Item activity and will listen to the On Entry of the Storage System. As new items enter the storage system, the queries will be reevaluated until a matching item is found. The Find Item activity performs all of the steps listed in the above example but within one activity. The following process flow is an example of how you could find an item, mark the item as outbound (clear the assigned slot) and move that item out of the storage object."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/ConnectingFlows/Warehousing/RackTypes/RackTypes.html",
        "title": "Types of Racks and Storage Options",
        "content": "What Types of Racks are Available? One of the key design choices is what types of racks and storage space you want to use in your model. FlexSim offers multiple different types of racks and storage options, that can be used in a variety of ways. Each of the different racks provide different visualization and interaction options with operators and transports. The different rack type options include: Rack The most basic and simple shelving structure. This is just a basic Rack with shelves. By default it will load in a First in First Out order. Floor Storage Storage space on the floor that utilizes the same matrix organizational tools for racks. This type of Storage Object is used often for large areas of pallets, or staging areas either in receiving or shipping. Any type of organized floor storage area would best be represented with this type of object. Gravity Flow Rack A rack that operates with rollers. Operators and Transports will load onto the back of the rack, while the pick-face of the rack is on the front. This type of rack will visualize objects rolling to the front pick-face of the rack. The nature of this Rack Type is to be a \"first in first out\" loading scheme. This type of rack also has a small animation of the items rolling to the front of the pick-face of the rack. Push Back Rack A rack that operates similarly to the Gravity Flow Rack but will be loaded both to and from the pick-face of the rack. This rack is meant to simulate the \"first in last out style\" of a Push Back Rack both visually and logically. Also like the Gravity Flow Rack, the Push Back Rack has animations for the items as they are pushed into the slots. One reason to use a Push Back Rack as opposed to a Gravity Flow Rack, is if your rack were against a wall, and required both loading and unloading from the pick-face. Drive-in Rack This rack visually represents the framework of a rack meant to allow forklift trucks to drive into the storage area to drop off pallets. Rack Visualization Each type of Rack has its own unique visuals. All of these components can be edited and altered to whatever your warehouse model requires. Whenever a new Rack or Storage Object is dragged out into the model, it creates a Storage System object in your Tools. When opening the Storage System object's properties window, you will see a Visualization tab. It is within this tab that all the visual elements of your racks can be edited. For more information, please see the Visualization Tab section in the Storage System documentation ."
    }
]