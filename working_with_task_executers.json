[
    {
        "url": "https://docs.flexsim.com/en/25.2/WorkingWithTasks/KeyConceptsAboutTaskLogic/KeyConceptsAboutTaskLogic.html",
        "title": "Key Concepts About Task Sequence Logic",
        "content": "Overview of Task Sequence Logic Systems As you'll recall from the chapter about Using 3D Objects , task executers are 3D objects that perform task sequences. They can move throughout the model, load and unload flow items, be utilized at fixed resource stations, etc. They are called task executers because they can be assigned task sequences to complete in the simulation model. Task sequence logic is any kind of logic that will involve task executers and task sequences. FlexSim provides you with several different options for defining task sequence logic, so that your solution can cater to specifically to your individual simulation problem. There are four primary facets to defining task sequence logic, as follows. Task Sequence Generation How are task sequences defined? Job Dispatching Who or what will perform what jobs? Item Flows and Routing Where do the items need to go? Transportation or Travel How do task executers move around? Each of these problems can be resolved according to your simulation's needs. Your simulation model might have a very simple answer to one or more of these problems, in which case it will be simple and straightforward to set up the logic. On the other hand, many simulation models require customized solutions to one or more of these problems. FlexSim's features give you ultimate flexibility in defining this customization. This topic will discuss each of these different problems in more depth and will explain which tools and processes you can use to solve them. If You Understand Task Sequence Logic, You Understand FlexSim FlexSim's task sequence logic capabilities are robust and feature-rich. Consequently, if you are new to FlexSim, they might be a little intimidating. However, the good news is that once you've mastered these principles, you can build nearly any kind of simulation model in FlexSim. If you can create task sequence logic, you can build any kind of logic in FlexSim. Task Sequence Generation Task Sequence Generation How are task sequences defined? One of the first problems you need to address when designing task sequence logic is the obvious question of how to define the task sequences to be worked on by task executers. A task sequence is a specific sequence to tasks that are to be performed together as part single \"job\" or unit of work. A task is a single instruction or action that is performed as part of a task sequence . An example task sequence, with its associated individual tasks, might be the following: Travel to a queue Load a flow item from the queue Travel to a processor Unload the item into the processor See Task Sequence Concepts for more information on task sequences. Viewing a TaskExecuter's Task Sequences You can view the state of a TaskExecuter's currently active task sequence and its task sequence queue by right-clicking on the object and selecting View Task Sequence Queue . 3D Object-Based Task Sequence Generation Transportation tasks tend to be the most common tasks. For that reason, the standard logic on 3D objects has some simple and straightforward ways to set up a transportation task. For example, after setting up your port connections, sometimes all you need to do is check the Use Transport button on a fixed resource's Output pane to set it up. The 3D object will automatically create a task sequence and dispatch it to the task executer or dispatcher connected to its center port. Processors also include an automatic task sequence generation mechanism. You can check the Use Operator(s) for Setup or Use Operator(s) for Process boxes in a processor/separator/combiner's Processor pane. This will cause an automatic task sequence to be generated that tells a task executer to travel to the processor and \"utilize\" while the item is processed. Process Flow-Based Task Sequence Generation You can also use a process flow to generate task sequences. The main difference is that, whereas when using 3D object logic the task sequences are defined automatically, in process flow you have full control over the sequence of tasks to perform. For example, the process flow equivalent of a simple transportation task sequence would look similar to the following image: Examples of Process Flow Task Sequence Generation The Process Flow tool has a library of commonly used task sequence activities that you can combine together to create any number of custom task sequences. One thing to keep in mind about the process flow tool is that usually most tasks can be represented by simple travel, delay, and acquire activities. For example, imagine you wanted to simulate an operator cleaning a machine during a machine changeover. You can simulate this as a series of travels and delays: Travel to Cleaning Supply Storage - The operator travels to the location where the cleaning supplies are kept Acquire Supplies - The operator acquire the supplies What Happens When You Acquire Something? Acquiring a resource allows for mutual exclusion of resources, which is helpful for simulating finite or restricted resources. Once you've acquired the supplies, other task executers cannot acquire the same supplies and must wait for you to release them. Travel to Machine - The operator then travels to the machine Delay for Cleaning - The operator delays at the machine, simulating the time it takes to clean the machine and prepare it for the changeover Travel Back to Cleaning Supply Storage - The operator returns to the location where the cleaning supplies are kept Release Supplies - The operator returns the supplies to the supply closet The following image shows how this task sequence logic would work during a simulation run: The task activities that are available in the Process Flow library cover most of the common tasks that are used in simulation modeling, such as loading, unloading, traveling, and delays. However, there are several more pre-programmed tasks that are available using the Custom Task activity in the library. If you want to use any of these custom tasks, you should refer to Task Sequences Quick Reference . The Quick Reference can provide you with detailed information about how you should fill in the properties for each custom task type. It also links to more in-depth guides for each task. Job Dispatching Job Dispatching Who or what will perform what jobs? When designing task sequence logic, you also need to think about how jobs will be dispatched. The following are some related questions: How will jobs be assigned to task executers? If there are two or more task executers, which task executer will perform the job? What will happen if there are not enough task executers to complete the jobs? Will some jobs take priority over others? Will a more important job be allowed to preempt (interrupt) another job? What happens if multiple task executers need to work together to accomplish a job (also known as a coordinated job)? What is a Job ? In describing these concepts, we intentionally use the more general term job instead of the more specific term task sequence . A job may indeed be represented by a specific task sequence in one model design. However, in other models, instead of task sequences, you may decide to have process flow tokens, entries on a list, items in a queue, etc., embody the representation of a job . Whatever implementation you decide to use, the core concept is the same. In dispatching, jobs are being matched to resources that can perform them. Core Dispatching Decisions The dispatching problem in FlexSim is broadly analogous to the well-known set of problem-solving techniques within the domain of scheduling . From a simulation perspective, the dispatching problem can generally be boiled down to two decisions that the simulation must make. They are: Dispatching Decisions Resource Selection When a new job (e.g. a task sequence) needs to be performed, how does the simulation select which available resource (e.g. task executer) should do that job. Job Selection When a resource (e.g. a task executer) becomes available to do work, how does it select which job (e.g. task sequence) to do next. While these two core questions are also applicable in non-task-executer-based scenarios (for example, fixed resources perform similar decisions as part of their send-to and pull logic), this topic will explore just the dispatching problem as it relates to task executers. Here we show different options, and explain how they each solve these two decisions. In making job dispatching decisions, it is important to understand how task executers handle task sequences. See How Task Executers Handle Tasks for an in-depth explanation of how this works. Resource with a lower-case \"r\" In this topic we generally use the term resource inline with its common usage in describing scheduling problems . This is not to be confused (unless expressed as such) with FlexSim's process flow Resource . Direct Task Sequence Dispatching Any kind of simulation model in which there is only one task executer will generally be very easy to set up. You can create center port connections to a task executer and use the Use Transport option on the upstream fixed resource. The table below shows how the two primary dispatching decisions are made in this scenario. Single-Resource Dispatching Resource Selection There is only one task executer who can do the job, so all task sequences (\"jobs\") are dispatched to that task executer. Job Selection When the task executer becomes available to do another task sequence, it uses its Queue Strategy to select a task sequence to perform next from its task sequence queue . Using more than one task executer is not much more difficult. You can connect the task executers to a dispatcher object, then send task sequences to that dispatcher through the Use Transport option. . Multi-Resource Dispatching Using a Dispatcher Resource Selection Task sequences are dispatched to the dispatcher's task sequence queue . The task executer is then chosen via the dispatcher's Pass To logic. Job Selection When one of the dispatcher's connected task executers becomes available to do another task sequence, it automatically notifies the dispatcher of its availability. The dispatcher will then use its Queue Strategy to select a task sequence to perform next from its (the dispatcher's) task sequence queue. These scenarios can also be integrated relatively easily with process flows that you define. If there are additional jobs that you'd like to define directly in process flow, you can use the Create Task Sequence activity to create task sequences and dispatch them to a dispatcher or task executer's task sequence queue. The advantage of using these scenarios is that it is very simple to set up. It is mostly done directly through 3D object properties. A potential disadvantage is that it's less visible. Job queueing is internal to the objects, so it's harder to see what is going on (although it is more visible if you define the task sequences in process flow, because you can see the tokens that are defining the task sequences). Additionally, intricate customization of the job selection and resource selection logic can sometimes be more difficult, because you're confined to using the Queue Strategy and Pass To pick options. Direct Task Sequence Dispatching Advantages Disadvantages Simple setup Configured directly in 3D object properties Integrates easily with process flow Job queues are less visible Intricate selection customization is more difficult Dispatching Using Process Flow Resources Another option is to use a process flow Resource to solve the dispatching problem. Here you define a Resource shared asset in process flow. You can associate the resource with a group of task executers. Then when you have a job to do, you use an Acquire Resource activity to select a task executer to use. Then you define a task sequence for the task executer to perform. Finally, you use a Release Resource activity to release the task executer back to the pool. Dispatching Using Process Flow Resources Resource Selection The set of available resources (task executers) is managed by the process flow Resource . Selection is done using the Query / Object / Array field of the Acquire Resource activity. Job Selection Job selection is performed when the task executer is released back to the Resource, when there are multiple other process flow tokens waiting to acquire it. The default is FIFO. However, you can customize this by clicking the Advanced button and defining the internal list's Back Order Queue Strategy . Since the Resource is the gatekeeper to acquiring task executers, an individual task executer's task sequence queueing logic is generally not a factor. The advantage of using this mechanism is that it can use the powerful selection and prioritization mechanism provided by FlexSim's SQL engine. Further, queueing of jobs is represented visibly by tokens stacking up in the process flow's Acquire Resource activity. A disadvantage is that, if there is other logic in the model that uses direct dispatching for the same set of task executers, that logic will dispatch directly to task executer/dispatcher task sequence queueing logic , and thus will be invisible to the Resource's selection logic. Further, when you use the powerful SQL selection mechanism of a Resource, you are really just using a List in disguise, and it might be worthwhile to use Lists directly for dispatching. Dispatching Using a Process Flow Resource Advantages Disadvantages Powerful selection using SQL pull queries Job queueing is visible in process flow Direct dispatching is invisible to the Resource In this configuration, the Resource is really just a List in disguise Dispatching Using Lists The most powerful option for dispatching in FlexSim is to use Lists. Lists allow you to customize how resource and job selection is done, with an incredible degree of flexibility and robustness. Lists utilize FlexSim's SQL parser for selection and prioritization. You can also access lists both from process flow as well as directly through 3D object properties, so they can integrate all different sources of logic. See Key Concepts About Lists for more information. While using Lists is incredibly powerful, it does require a good understanding of how lists work. Concepts such as back orders, pull queries, pullers, values, fields, etc. are required to take full advantage of their capabilities. As such, if direct dispatching is sufficient for the problem at hand, by all means use that solution. Nevertheless, lists provide an incredibly powerful alternative to direct dispatching. What Goes on the List? For dispatching, you will orient a list in one of two ways. Either the list will represent a list of resources (e.g. task executers, process flow tokens, etc.), or it will represent a list of jobs (e.g. task sequences, process flow tokens, items in a queue, etc.). A List of Resources When the list is a list of resources, the resources are pushed onto the list, and the jobs pull those resources from the list. This orientation is used when resource selection is the primary selection priority. When a job requests a resource, it can use a pull query to define constraints and priorities for which resource to select. If, in pulling from the list, the job does not find a suitable resource, then the job will be placed on the list's back order list. When a resource becomes available and is pushed back onto the list, it will fulfill one of the job back orders. Thus, job selection is done primarily using the list's Back Order Queue Strategy . Dispatching Using a List of Resources Resource Selection The set of available resources (task executers) is managed by pushing those resources onto the list. Resource selection is done when a job pulls from the list, wherein the pull query defines selection requirements and prioritization. Job Selection Job selection is performed when the resource is pushed back onto the list. If there are back orders, those back orders will be fulfilled based on the Back Order Queue Strategy . Since the List is the gatekeeper to acquiring resources, an individual task executer's task sequence queueing logic is generally not a factor. To implement this option, you can use a task executer's On Resource Available event to push the task executer onto the list. Additionally, you can use a fixed resource's Use Transport field to pull from the list. Or, you can manage all the list pushing and pulling in process flow, using a process flow List . A List of Jobs When the list is a list of jobs, the jobs are pushed onto the list, and the resources pull those jobs from the list. This orientation is used when job selection is the primary selection priority. When a resource requests a job, it can use a pull query to define constraints and priorities for which job to select. If, in pulling from the list, the resource does not find a suitable job, then the resource will be placed on the list's back order queue. When a new job arrives and is pushed onto the list, it will fulfill one of the resource back orders. Thus, resource selection is done primarily using the list's Back Order Queue Strategy . Dispatching Using a List of Jobs Resource Selection Resource selection is performed when a job arrives and is pushed onto the list. If there are resources waiting on list's back orders, those back orders will be fulfilled based on the Back Order Queue Strategy . Job Selection The set of active jobs is managed by pushing those jobs onto the list. Job selection is done when a resource pulls from the list, wherein the pull query defines selection requirements and prioritization. Since the List is the gatekeeper to acquiring resources, an individual task executer's task sequence queueing logic is generally not a factor. To implement this option, you can use a task executer's On Resource Available event to pull from the list of jobs. Additionally, you can use a fixed resource's Use Transport field to push a job to the list. Or, you can manage all the list pushing and pulling in process flow, using a process flow List . See Using Lists for Task Logic for an example of this scenario. In conclusion, using Lists is the most powerful option for doing dispatching in FlexSim. Dispatching Using a List Advantages Disadvantages Most capable dispatching option Powerful selection using SQL pull queries Job/Resource queueing is visible on the list Can integrate task sequence logic defined in 3D object properties with process flow logic Requires a working understanding of how lists work Item Flows and Routing Item Flows and Routing Where do the items need to go? Item flows and routing issues are related to task sequence logic if task executers are involved in the transportation of items from one fixed resource to another. The important thing to keep in mind is that the logic for item routing is handled through fixed resources---not through any logic on task executers themselves. In other words, the logic that determines how items flow from one object to another is primarily determined by logic on the fixed resource or through process flows that are listening to events on fixed resources. Examples of Simple Item Routing The simplest kind of item routing is when one fixed resource is passing flow items directly to a fixed resource that is adjacent to it. Port connections can handle this logic very easily. Ports can also handle one-to-many item routing without too many difficulties. Examples of Complex Item Routing Any many-to-many item routing system is likely to be a little more complex to design. Other examples of complex systems are ones in which there needs to be a special criteria or conditional logic by which an upstream object sends items to different downstream objects. Depending on your simulation model's needs, FlexSim has many different systems you can use to route items from one fixed resource to another, including lists, conveyors, and process flows. Consider reading the chapter about Connecting 3D Object Flows for more detailed information about how to build item routing logic using these different systems. Transportation or Travel Routing Transportation or Travel How do task executers move around? If task executers need to transport items or travel across long distances, you might need to create the logic that tells the task executer which path to take in order to get from one point to another. Examples of Simple Travel Routing By default, task executers will travel on the shortest path between two locations, even if there are other objects in that path. The default travel mechanisms might be all your system needs if task executers only need to travel short distances between objects. Examples of Complex Travel Routing If task executers have to travel distances that will not be in a simple straight line, you'll probably want to use one of FlexSim's travel systems to help task executers walk on more accurate paths. The good news is that each of these different travel systems operate on the same basic principles. Once you've learned how to use one of the travel systems, it's not terribly difficult to learn how to use the other systems since many of the same basic principles apply. See Key Concepts About Travel for a deeper explanation of the different advantages and disadvantages of the various travel systems. FlexSim has three different travel systems. One is the travel network system: Another is the A* navigation system: And the last system is for automatic guided vehicle (AGV) networks: Tutorials and Further Reading To learn more about tasks, consider completing the following relevant tutorials to get hands-on experience with the concepts discussed in this chapter: Task Logic Tutorial 1 - Task Logic Tools Task Logic Tutorial 2 - Coordinated Tasks Task Logic Tutorial 3 - Conditional Tasks Process Flow Tutorial 2 - Task Sequences Process Flow Tutorial 5 - Creating Logic for Custom Objects Consider also reading Reference - Task Executer Concepts for a more in-depth explanation about how task executers work. The rest of this chapter will discuss topics related to tasks in general and specific kinds of task executers."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/WorkingWithTasks/HowTaskExecutersHandle/HowTaskExecutersHandle.html",
        "title": "How Task Executers Handle Tasks",
        "content": "Introduction to How Task Executers Handle Tasks This topic will explain how task executers receive and execute task sequences. If you are using complex task logic in your simulation model, you might need to understand the concepts in this topic so that you are aware of how FlexSim handles task logic behind the scenes. This knowledge will help you understand and troubleshoot potential task logic problems---especially related to task dispatching logic and its related issues, such as task priorities and preemption. Task Sequences and Tasks Sometimes you might see the terms task and task sequence used interchangeably in this manual and in other FlexSim resources. While loose terminology usage isn't terribly problematic, there are very specific, and unique, technical meanings of the terms task and task sequence which are important to understand. Definitions Task - A single instruction or action that is performed by a task executer. Examples are load , unload , and travel . Task Sequence - A collection of one or more tasks that are meant to be performed in sequence, generally uninterrupted, by a task executer. In addition to containing a sequence of tasks to perform, a task sequence holds values for priority and preemption, and can also store user-defined label values. By default, a task executer will work on all the tasks in an entire task sequence from start to finish. Then, once the task executer has finished every task in the task sequence, it will finish/destroy the task sequence, and then look for a next task sequence to execute. Task Sequences vs. Tasks: What This Means for Dispatching Comprehending the difference between task sequences and tasks is important to understanding and controlling dispatching logic in FlexSim. If we think of a task as the most basic unit of work in FlexSim, a task sequence is the most basic unit of dispatching. Task sequences, not individual tasks, can be dispatched and moved around to different queues or lists. They can be prioritized and selected based on custom criteria, etc. Further, a task sequence enforces a specific ordering of task execution. Task Sequences vs. Tasks: Process Flow Confusion The Process Flow tool provides a very useful mechanism that lets you dispatch individual tasks directly to task executers. When you add a task sequence activity like Load , you can directly specify a task executer in the Executer / Task Sequence field. While this appears to dispatch a task directly to the task executer, what is really happening behind the scenes is the activity is creating a task sequence with a single task inside it, and dispatching that task sequence to the task executer. As described above, you can only dispatch task sequences , not tasks , to task executers. Often, using this process flow feature is not problematic. However, problems can arise specifically when you have other mechanisms (standard 3D object logic, other parts of process flow, etc.) that are also dispatching task sequences to the same object. Since this feature creates a task sequence with a single task, there is no constraint forcing the task executer to perform multiple tasks in the order that you define them in a process flow. It could perform one task from the process flow, then jump to another, completely separate task sequence, before performing the next task you give it. If or when these problems arise, you can use the Create Task Sequence activity to explicitly create a task sequence. Once created, you add tasks to the task sequence, instead of directly to the task executer. This will correlate each added task with that single task sequence, and thus enforce a specific ordering by which to perform the tasks. Once you're finished with the task sequence, add the Finish Task Sequence activity. This will finish the task sequence, releasing the task executer to other task sequences. How Task Executers Handle Task Sequences Task executers primarily keep track of two things: Active task sequence - The task sequence the task executer is currently working on. Task sequence queue - A queue of task sequences the task executer has been assigned to work on. You can view a Task Executer's active task sequence and task sequence queue by right-clicking on it and selecting View Task Sequence Queue . During a simulation run, when a task executer receives a task sequence: The new task sequence will be added to the task executer's task sequence queue. If the task executer does not currently have an active task sequence, it will select a task sequence from its queue. Usually, a task executer will complete task sequences in the order they are received. In other words, it will do the tasks using FIFO logic (first in, first out). However, if you use task sequences with different priorities, the task executer will complete the task sequences in the order of their priority instead. The selected task sequence will become the active task sequence. The task executer will complete the tasks in the task sequence, generally uninterrupted, in the order they were added to the task sequence. After the active task sequence is complete, the task executer will select another task sequence from the queue and the process will repeat itself. Exceptions to the \"Execute Uninterrupted\" Rule While, generally, a task executer will execute all of the tasks in a task sequence uninterrupted, there are some exceptions to this rule, as follows. Preemption - If, while executing a task sequence, the task executer receives another task sequence whose preemption value is set to preempt, the task executer will immediately stop executing its current task sequence, and start the new task sequence. See Task Sequence Priorities and Preemption for more information. Break Tasks - If the task executer reaches a break task in the task sequence, it can break away from the current task sequence to perform some other task sequence. This is used primarily for simulating multi-item capacity. The task executer will perform part of one task sequence that loads one item, then if it still has load capacity, it can break to another task sequence that loads another item, before finishing the original task sequence that tells it to unload the original item. Call-Subtasks Tasks - If the task executer reaches a call-subtasks task in the task sequence, it will break from the current task sequence, fully execute another task sequence, then return back to the original task sequence. While this can be useful when using the Task Sequence API , generally process flow will allow you to do everything you need without using call-subtasks. Dispatchers vs. Task Executers A dispatcher object is similar to a task executer, except that it does not have an active task sequence. It only has a task sequence queue. This is what distinguishes the Dispatcher class from the TaskExecuter and its sub-classes. Task Executer Events and Triggers Task executers have a specific series of events and triggers that they go through while working on tasks. (See Key Concepts About Events for information about events and triggers.) A few of the important events are: Trigger Explanation On Start Task Fires whenever the task executer begins performing a task On Finish Task Fires whenever the task executer finishes performing a task. On Resource Available Fires whenever the task executer has finished a task sequence, and is ready to execute another task sequence. On Load Fires when a task executer loads an item as part of a load task On Unload Fires when a task executer unloads an item as part of an unload task You can set custom animations or process flow activities to begin when any of these triggers are fired. You could also use triggers to design look-for-work systems in which task executers pull task sequences from a global list when their On Resource Available trigger fires. See Task Executer Concepts - Events for a more thorough explanation of the available events and triggers for task executers."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/WorkingWithTasks/CoordinatedTasks/CoordinatedTasks.html",
        "title": "Coordinated Tasks",
        "content": "Introduction to Coordinated Tasks Coordinated tasks are any tasks that require more than one task executer. Some common scenarios in which coordinated tasks are used: When more than one operator is needed to transport an item When multiple operators are needed for setup or for processing When an operator needs to hand off something to another operator When two or more operators need to work on separate tasks concurrently Nearly all coordinated task sequences require you to build custom task logic. The following image shows an example of a coordinated task sequence in which two operators are occasionally needed to transport heavy boxes: There's a Tutorial For That The example from the previous image comes from Task Logic Tutorial 2 - Coordinated Tasks . Consider doing this tutorial if you'd like an in-depth, hands-on approach to the concepts discussed in this topic. Tools Used to Create Coordinated Tasks The Process Flow tool is the ideal tool for building custom task sequences, including coordinated task sequences. The most common activities you will use to build coordinated tasks are the Coordination activities. These activities are specifically designed to coordinate tasks, processes, and logic that needs to happen simultaneously. See Process Flow - Coordination for more information. In some cases, it could also be helpful to coordinate task sequences using sub flows activities. See Sub Process Flows for more information. The list and resource shared assets can also manage the availability of task executers to work on tasks as well. See Key Concepts About Shared Assets for more information. Creating Coordinated Task Logic This section will provide an overview of the basic steps involved in building coordinated tasks. The following image shows an example of coordinated task logic and the different steps involved in the process: 1. Start the Coordinated Task In general, when creating coordinated tasks, the task that needs to be performed should correlate with a token in a process flow. You should start the coordinated task sequence with an activity that responds to an event in the 3D model that creates the need for a task. For example, you could use an Event-Triggered Source that listens for the event in the 3D model that triggers the need for the coordinated task sequence. 2. Split the Token Once the token is created in the task sequence, you should usually start with a Split activity that splits the token into however many task executers are needed for the task sequence. Keeping Your Process Flow Organized In general, it helps to create a separate container (a process flow shape) for each task executer that is needed for the coordinated tasks. To help avoid confusion, the containers should be parallel to each other and contain the tasks that are performed by that task executer alone. 3. Acquire the Task Executers Use an Acquire Resource or Pull from List to acquire task executers for each set of tasks. You'll need to acquire or pull each of the needed task executers separately, ideally on their own container track. 4. Build and Synchronize the Tasks Next, build out the actual tasks that are needed for the coordinated tasks. Usually the main task executer performs the actual tasks while any assisting task executers merely move along at the same time the main task executer moves in the 3D model. After each task, you should include a Synchronize activity to ensure that the task executers remain in sync with each other. Otherwise, their timing might begin to diverge and one task executer could get ahead of the other. Keeping Your Process Flow Organized As a best practice, consider making the Synchronize activity span across all the coordinated task containers since this activity is used by multiple task executers. 5. Release the Task Executers After the tasks that needed to be coordinated are complete, release the task executers. 6. Join or Destroy the Assisting Task Executer Tokens After releasing the task executers, you need to destroy the tokens that are associated with the assisting task executers. You could also use a Join activity to merge the tokens back into one token. However, be aware that the label information from the tokens for the assisting task executers might not be preserved. See Process Flow - Coordination for more information about the interaction of labels between parent, child, and sibling tokens. Tutorials and Further Reading To learn more about coordinated tasks, consider completing the following relevant tutorials to get hands-on experience with the concepts discussed in this chapter: Task Logic Tutorial 1 - Task Logic Tools Task Logic Tutorial 2 - Coordinated Tasks Consider also reading Process Flow - Coordination and Sub Process Flows for a more in-depth explanation about the process flow activities that are involved in building coordinated tasks."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/WorkingWithTasks/TaskPrioritiesPreemption/TaskPrioritiesPreemption.html",
        "title": "Task Priorities and Preemption",
        "content": "Overview By default, task executers handle tasks using FIFO logic (first in, first out). They simply complete tasks in the order in which they were received and added to the task executer's task queue. However, you can make task executers work on more important tasks before less important ones using priority levels, preemption, labels, lists and/or other conditional logic. Priority levels are numbers or labels you can assign to a task to make one task more important than another. Preemption determines whether a task executer will be interrupted from its current task to work on a more important task or not. It also affects what happens to the active task that was interrupted. For example, the preemption can determine whether the active task is restarted from the beginning after the preempting task is complete or whether the task should be deleted entirely. The following are examples of some scenarios in which priorities and preemption systems might be needed: Look For Work Systems - If you design a system in which task executers look for work to do by pulling tasks from a list, you can use priority levels to help the task executers decide which tasks to work on first. Machine Breakdowns - If a machine breaks down and a task executer is needed to repair it, that task executer's normal tasks could be interrupted while it works on the repairs. Emergencies or Urgent Request - If an emergency occurs that requires immediate attention or if an urgent request suddenly arrives, you'd need to use priorities and preemption to pull task executers away from their tasks to handle the emergency. The rest of this topic will explain important concepts and different methods for creating priority and preemption system. There's a Tutorial For That The Task Logic Tools tutorial goes into depth about how to create priority and preemption system using the different tools for creating task logic. Priorities With Standard 3D Logic The following sections will explain how to add task priorities if you are using standard 3D logic: How Priorities Work in Standard Logic By default, all task sequences have a priority value of 0 unless you assign a different priority level to them. Task sequecnes with larger priority numbers will be completed before task sequences with a lower priority number. For example, a task sequence with a priority of 10 will be completed before a task sequence with a priority of 1. The deeper meaning or strategy behind the priority numbers is entirely up to you. If you plan to use priority levels extensively in your simulation model, you might want to consider tracking and managing your priority levels. Consider writing down the levels and their meanings in your model's documentation for reference. Assigning Priorities If you are creating tasks using the standard logic on a 3D object, look for properties that assign priority and/or preemption values in the same area where you created the task: Priorities With Process Flow Activities You can't add priority levels or preemption values to individual process flow task activities. Instead you can use a Create Task Sequence activity to define a priority on a task sequence that you create. Alternately, you can handle prioritization within process flow, using lists, resources, etc. and only generate task sequences after job/resource selection has been accomplished. For example, imagine you were modeling a system in which task executers needed to transport rush order items before transporting other items. To create this kind of system, you could: Add an On Creation trigger to a source that assigns a label named RushOrder to flow items. A certain percentage of the flow items could be assigned a value of 1 to indicate that they are a rush order item. (All other items will be assigned a value of 0.) Change the Color of Items With Different Priorities Consider changing the color of high priority items so that they are more visible in the 3D model. You can do this by adding a Set Object Color picklist option to a trigger on the source. You can then set this trigger to change the color of a flow item based on the value of its RushOrder label. You could also use a Change Visual activity if you would prefer to change the color of objects using process flow instead. When items are ready for transport, they get pushed to a list. Task executers can query the list and pull items that have a RushOrder value of 1 and pull those items for transport first. Try completing Task Logic Tutorial 1.3 for a hands-on example of this system. Strategies for Mixing Methods If you have a model that uses both standard logic and process flow to assign tasks to task executers, you'll need to use priority and preemption strategies that are compatible with both systems. You can add priority and preemption to task sequences in process flow using a Create Task Sequence activity. Then, you can push the task sequence to a task sequence list. See Using Lists for Task Logic for an example of doing this. Alternately, you can dispatch the task sequence directly to a task executer or dispatcher, and allow the standard task sequence queue logic to be used. Preemption Preemption determines whether a task executer will be interrupted away from its active task to work on a preempting task. It also determines what will happen to the active task when an operator is preempted away from it. For example, the interrupted task could simply be re-added at the end of the task executer's task list. The task executer would then work on the interrupted task when it finished the preempting task. Alternatively, the active task could be entirely aborted so that it will never be worked on by the task executer. The following table explains the different available preemption options: Value Name Description 0 No preempt The task will not preempt a task executer. 1 Preempt only The task executer will preempt the currently active task sequence and put it back in its task sequence queue to be finished later. When a task sequence is preempted, it is automatically placed at the front of the task sequence queue. When the TaskExecuter eventually comes back to the original task sequence, the current task in that task sequence will be done over again, since it was not finished. 2 Preempt and abort active The task executer will stop the currently active task sequence and destroy it, so that it will never come back to that original task. 3 Preempt and abort all The task executer will stop the currently active task sequence, destroy it, and destroy all tasks in its task sequence queue. Multiple Preempting Task Sequences It's possible that a task executer could be working on a preempting task at the same time it receives another preempting task. When that happens, the task logic will use the following rules: Priority Levels - Task executers will use the priority value of the task sequence to determine which task sequence will take precedence. When the new task has a higher priority value - The task executer will preempt its current task sequence and execute the new one. When the new task has a lesser or equal priority value - The task executer will not preempt the active task sequence, but will queue up the new task sequence just like any other task sequence it receives. Queuing tasks - If the preempting tasks is added to the task executers task queue, it will not take the preempt value into account for its queueing logic unless you explicitly tell it to in the queue strategy. If you want the preempting task to be at the front of the queue, you could either assign a higher priority to the preempting task than all other task sequences or take preempting into account in the queue strategy."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/WorkingWithTasks/UsingListsForTaskLogic/UsingListsForTaskLogic.html",
        "title": "Using Lists for Task Logic",
        "content": "Overview As was discussed in the topic Key Concepts About Task Sequence Logic , using lists is one of the most powerful mechanisms for implementing job dispatching. This topic teaches you how to implement one specific example of dispatching using lists, namely using a task sequence list. This topic presents an example to solve the job dispatching problem. While this example uses process flow for the task sequence generation mechanism, it will also work with other task generation strategies. Job Dispatching Who or what will perform what jobs? In this scenario, the core dispatching decisions are solved by orienting a list as a list of jobs . In this case, a job is represented by a task sequence, as follows: Dispatching Using a List of Task Sequences Resource Selection Resource selection is performed when a task sequence is created and pushed onto the list. If there are resources waiting on the list's back orders, those back orders will be fulfilled based on the Back Order Queue Strategy . Job Selection The set of active jobs is managed by pushing task sequences onto the list. Job selection is done when a resource pulls from the list, wherein the pull query defines selection requirements and prioritization. Since the List is the gatekeeper to acquiring resources, an individual task executer's task sequence queueing logic is not a factor. The following is a high-level overview of how you would set up this kind of system: Create a global task sequence list - In the Toolbox, you'll create a task list that will store task sequences created by the process flow. Add triggers to task executers in the 3D model - You'll add the On Resource Available trigger to all the task executers. This trigger will fire whenever the task executer is free to work on a new task sequence. You'll add instructions that will tell the task executer to pull tasks from the global list when that trigger fires. Create task sequences in the process flow - You'll create a complete set of tasks and put them inside a task sequence. Then you'll dispatch the task sequence to the global list you created. Set up standard 3D task logic - You won't need to make any changes to how you assign standard 3D tasks to task executers. You can use the normal procedures for creating these types of tasks. There's a Tutorial For That The fourth step of the Task Logic Tools tutorial models how to create a task system that uses global lists and combines it with standard task logic. See How Task Executers Handle Tasks for more information about task sequences and how task executers handle them. Creating a Global Task Sequence List The global task sequence list will act as the job board from which the task executers will pull the list of tasks they need to do. To set up a global task sequence list: In the left pane, click the Toolbox tab to switch to the Toolbox. Click the Add button to open a menu. Point to Global List , then select Task Sequence List . In the list properties, change the name of the list to something distinct that you'll remember, such as Available Tasks . If needed, add or remove any custom fields to help track your list entries. Press the OK button to save the changes and close the window. Confirm that the list you just created now appears in the Toolbox. See Key Concepts About Lists for more information about lists in general. Adding On Resource Available Triggers After creating the global task sequence list, you'll need to add an On Resource Available trigger on all of the task executers in the 3D model. Then you'll set the trigger to pull from this list whenever they're available to work on tasks. To add this trigger: In the 3D model, click the task executer to open its properties on the right. Under the Triggers section, click the Add button to open a menu. Select On Resource Available . Next to the On Resource Available box, click the Add button to open a menu. Point to Use List , and then select Pull from Task Sequence List . In the picklist properties window, click the List menu and select the name of the global list the task executer should use. If needed, add a query to the Query box to instruct the task executer which task sequences should be pulled before others. Repeat the previous steps for all of the task executers in the 3D model. See Key Concepts About Events for more information about triggers in general. Creating a Task Sequence in Process Flow The Process Flow library includes the Create Task Sequence activity. You can use this activity to create task sequences. You'll use the Create Task Sequence activity at the beginning of a set of process flow tasks to create a task sequence and assign the task sequence a name. Next, you'll add the task activities in the order they should be completed. To create a task sequence in process flow and push it to a global task sequence list: Add a List shared asset to the process flow. In the List box, use the menu to link it to the global task sequence list you created earlier. Think through which event(s) in the simulation model will trigger the creation of token that will then create the task sequence. Perhaps you could use an Event-Triggered Source that listens for a specific event to occur, such as an item entering a queue that needs to be transported. Add a Create Task Sequence activity to the process flow. In the activity's properties, next to the Task Executer / Dispatcher box, click the Delete button to ensure there is no currently selected task executer. If needed, you can assign values for the Priority and Preemption properties for the entire task sequence. In the box under the Assign to option, delete the part of the code that says taskSequence and replace that with the custom name you want to give your task sequence. For example, the final code could read something such as token.MyTaskSequence or token.TransportTasks . Clear the Dispatch and Wait checkbox. This will make the token immediately continue to the next Push to List activity. Setting Labels on the Task Sequence You can optionally set labels on the task sequence, using an Assign Labels activity. These labels can be accessed when resources pull from the list, to query information about the task sequence, in order to filter and prioritize which task sequences to do next. After the create task sequence activity, add a Push to List activity that will push the task sequence to the global task sequence list. Link the activity to the list in the process flow (which should be tied to the global task sequence list). In the Push Value box, make sure that you assign the value to the name of the custom task sequence you created earlier. Add the rest of the task activities that will comprise the task sequence. In each task activity's properties, make sure that you change the Executer / Task Sequence box to add the task to the custom task sequence you created earlier, e.g. token.TransportTasks . Finally, add a Finish Task Sequence activity. In the activity's properties, make sure that you change the Task Sequence box to reference the custom task sequence you created earlier, e.g. token.TransportTasks . Try completing Task Logic Tutorial 1.4 for a hands-on example of this system."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/WorkingWithTasks/Travel/KeyConceptsTravel/KeyConceptsTravel.html",
        "title": "Key Concepts About Travel",
        "content": "Overview of Travel Systems This topic will provide a high-level overview of different tools for controlling the travel paths for task executers such as operators, transporters, and the TaskExecuter object. By default, when a task executer travels between two objects, FlexSim will simply choose the shortest distance between two points: a straight line. While this default travel logic might meet your simulation needs, in many cases it won't---especially if you're working with a specific floor plan. If task executers use the default travel system, they might end up traveling through other objects or through barriers such as walls. The following image shows an example of the default travel behavior: Using one of FlexSim's travel tools instead of the default travel system will allow you to create more accurate travel paths. You can define the specific travel paths that task executers should use and/or you can create barriers that task executers will need to travel around (such as walls). In other words, you'll be able to create more accurate travel paths for your task executers. Travel accuracy has two main advantages: Accurate travel paths will give you better statistics - If task executers aren't traveling on the shortest distance between two points, that means their travel time might be longer. Even seemingly minor differences in travel time and distance can have a large impact on the overall statistics of your simulation model over time. Using accurate travel paths will ensure that those statistics are more representative of the actual business system you are trying to simulate. Accurate travel paths will look better visually - When task executers travel in a straight path between two objects, it sometimes makes them travel in ways that appear visually incorrect. For example, an operator might walk through an object or through the walls of a floor plan to get to its destination. Using a travel system to force task executers to walk around objects or barriers will help the model look more correct visually. FlexSim has two different tools to create different travel systems for task executers: Travel Networks - Using this tool, you'll define the specific paths that task executers can use to get from one location to another in the simulation model. A* Navigation - Using this tool, you'll create travel barriers for task executers. Any fixed resources you connect to the A* system will also be treated as a barrier that cannot be passed through directly. The A* Navigator will then use these barriers and the travel threshold around fixed resources to calculate the shortest distance between two locations. You Can Make Both Systems Invisible While you're building travel systems, you'll usually want to have several different visual guides turned on to ensure you build the travel system correctly. However, after your system is built and validated, you can easily hide these travel systems if needed. The following sections will discuss the two different travel tools in more depth as well as other important concepts related to travel systems. How Travel Networks Work As was stated above, when you use the travel network tool, you'll define the specific paths that task executers can use to get from one location to another in the simulation model. The following image shows the same model that was used in the previous image, but now the task executers travel on specific paths: To use this tool, you'll follow a few basic steps: Add network nodes to the model - You'll start by dragging out network nodes (from the Library) and placing them at key points in the simulation model. In general, you'll want to put network nodes next to fixed resources to which task executers will need to travel. Then, you'll want to put network nodes at the beginning and end of a path you want them to travel (such as a hallway). The following image shows an example of two unconnected network nodes at the beginning and end of a hallway: Connect network nodes to create travel paths - You can connect two nodes using the same method that you would use to create input/output port connections (A-connects) between fixed resources. Once the nodes are connected, you'll see a line connecting the two nodes. The line will also have directional arrows indicating which directions of travel are allowed on that path: You Can Create Curved Paths If needed, you can right-click a path and change it to a curved path. Doing so will add spline points on the path. You can drag those splines to create curves as needed. Connect fixed resources to network nodes - If a task executer needs to travel to a fixed resource, you'll need to make sure it's connected to the travel network. Use an A-connect to connect a nearby network node to the fixed resource. A blue line will appear to show that the fixed resource is now connected to that node: Connect task executers to network nodes - Use an A-connect to connect a nearby network node to the task executer. This network node will act as the task executer's entry point to the travel network, so you should connect the task executer to a node that is near its starting reset position in the simulation model. A red line will appear to show that the task executer is now connected to that node: Add a traffic controller to prevent collisions - Many simulation models will not need a traffic controller, but if you have a busy travel intersection where many different task executers might possibly collide, you might want to add a traffic controller object to manage the traffic. You'll connect network nodes to the traffic controller to define which paths should have restricted access. The traffic controller can then limit the number of travelers that are allowed to enter a particular path or area at a time. Change additional travel network properties - If needed, you can adjust properties on the entire network or the connection between two network nodes. You can determine whether connections will allow two-way or one-way traffic. You can also determine whether task executers traveling at a faster speed can pass slower task executers and, if not, how much space will be allowed between them on the path. Make the travel network invisible - Lastly, you can hide the travel network so that you don't have to clutter up the simulation model with travel network paths. Right-click and change the Network View Mode. If you select None , all of the network nodes and paths will disappear except for one node (the one you right-clicked). You can use the one remaining node to turn the visibility back on if needed. When you reset and run the simulation model, FlexSim will calculate the shortest path for a task executer to take on the travel network any time a task executer needs to travel from one point on the network to another. How A* Navigation Works As was stated above, you'll use the A* navigation system to create travel barriers for task executers. Any fixed resources you connect to the A* system will also be treated as a barrier that cannot be passed through directly. The A* Navigator will then use these barriers and the travel threshold around fixed resources to calculate the shortest distance between two locations. The following image shows a model similar to one that was used in the previous sections, but now the task executers travel by calculating the shortest path around barriers: To use this tool, you'll follow a few basic steps: Add A* Navigation to the model - The A* Navigator system is automatally added to the model as soon as any A* object (Barrier, Divider, Grid, Bridge, or Path) is added to the model. Adding any one of these objects to the model will cause the A* Navigator tool to be added in the Toolbox. You can can double-click the toolbox entry to access the navigator properties. Connect all the fixed resources and task executers to the A* Navigator - You can connect objects to the A* Navigator using the same method that you would use to create input/output port connections (A-connects) between fixed resources. To do this, hold the A key and connect the desired object to any A* object (Barrier, Divider, Grid, Bridge, or Path). It will then be connected to the A* Network. You can also connect 3D objects in the A* Navigator's properties by sampling them as members. (See Connecting 3D Objects to the A* Navigator ) When a 3D object has been successfully connected to the navigator, it will have a purple background underneath it. Add any dividers or barriers to the model as needed - Dividers and barriers act as places that task executers have to walk around. In the Library, click the Divider or Barrier buttons to enter Create Divider or Create Barrier mode. Then you can click inside the model to draw the dividers or barriers. (It sometimes helps to turn off the model's main grid and turn on the A* grid visuals instead.) Check that the travel thresholds for fixed resources don't extend beyond the dividers or barriers - An object's travel threshold is comprised of red points surrounded by blue points. (See A* Travel Thresholds for a deeper explanation of how A* uses travel thresholds.) You'll want to move an object so that the red points in its travel threshold don't fall on the wrong side of A* dividers or barriers. Otherwise, it could make a task executer travel along an incorrect path to get to that entry point. The following image shows an example of a travel threshold extending beyond a divider: Make the A* visual guides invisible - After you've successfully tested your A* system, you can hide the visuals if needed. You can do this in the A* Navigator's properties. When the simulation model runs and a task executer needs to travel from one point in the grid, A* will run a search algorithm to find the shortest path between points. The algorithm basically divides the model into a grid of nodes through which task executers might travel. Each node specifies the direction travel members can possibly move. The algorithm will look at nodes in the direction of travel and determine which direction is the fastest, including traveling diagonally between nodes. The grid of nodes can be modified by creating barriers restricting where the travel members can move. The following image shows an example of a grid that has several barriers in place: When a traveler needs to go from point A to point B, the A* algorithm would calculate the shortest path. Notice in this scenario that there is more than one possible path, but only the path that is marked is clearly shorter than the others. A* can adapt to changing conditions and find the ideal path. A* is an Open Source Algorithm A* is an open source algorithm that was developed by a third party outside of FlexSim. For that reason, there are more in-depth guides you can find about how the A* algorithm works if you need one. Just do a simple internet search and you should be able to find plenty of information. A* Travel Thresholds The A* Navigation system uses travel thresholds to calculate the shortest possible point between two objects. A fixed resource's travel threshold represents the possible entry points to which a task executer may travel when it is walking to that object. An object's travel threshold consists of two zones: a calculated path zone and a travel arrival zone. The following image displays these two zones on an object: Notice that this image shows an object surrounded by red and blue points. These points indicate the two zones that make up the object's travel threshold. Each zone is described in the following table: Zone Description calculated path zone When a task executer needs to travel to this fixed resource, the A* Navigator will compute the shortest path between the traveler and any of the points in the calculated path zone. The traveler will then begin traveling following this shortest path. travel arrival zone The travel arrival zone won't be used by the A* algorithm to calculate a path, but the points in the travel arrival zone will be used to determine when the travel has arrived at the fixed resource. As soon as the traveler reaches any of the blue dots, FlexSim will consider the traveler as having arrived and the travel task as complete. In other words, the A* algorithm will first build the shortest path to a red dot. Then, if the resulting path includes blue dots, the algorithm will shorten the path to stop at the first blue dot on the path. The difference between the red and blue dots becomes more apparent when a fixed resource is especially long, for example when the object's x axis size is significantly larger than the object's y axis size. Travel thresholds can sometimes be the source of problems while using A*, causing strange travel behavior or animations. See Troubleshooting Travel Thresholds for instructions on how to fix common travel threshold problems. Deciding on a Travel Tool When deciding whether to use travel networks or A* navigation, you'll need to consider which system makes sense for your simulation project. For the most part, it's largely going to be a matter of personal preference. However, each system has different advantages and disadvantages, as explained in the following table: Travel Networks A* Navigation Advantages Gives the user more control over task executer travel paths Models might run faster because travel networks don't need to perform as many calculations Can be used to restrict the direction that travelers can travel on a path (one-way vs. two-way, etc.) Can set speed limits on certain travel paths Can be used to create virtual distances, which is where you make the distance between nodes longer or shorter than the actual distance in model units Fairly easy to set up and handles most of the logic on your behalf When you have a model with a high number of possible destinations and many possible paths between those destinations, A* would be easier to set up than travel networks Disadvantages Takes a slightly longer time to set up Creating paths between every possible destination can be cumbersome Sometimes troubleshooting takes more time If your model is large and complex, the A* algorithm could slow down your model while it computes the ideal travel path When the calculations take too much time to process, it can sometimes create strange visuals Try experimenting with both methods at first and discover which system makes the most sense for your simulation model project."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/WorkingWithTasks/Travel/WorkingWithTravelNetworks/WorkingWithTravelNetworks.html",
        "title": "Working With Travel Networks",
        "content": "Introduction to Travel Networks You can use the Travel Network objects to define the specific paths that task executers can use to get from one location to another in the simulation model. Before reading this topic, you should make sure you are familiar with the concepts discussed in Key Concepts About Travel . This topic will provide a high-level overview of how travel networks work. The rest of this topic will provide instructions about how to do the various tasks needed to build a travel network. Adding and Connecting Network Nodes The first step in building any travel network is to add network nodes to your model and connect them together to form travel paths: With the Library open, under the Travel Network group, drag a NetworkNode into your 3D model. It will appear visually like a square point in your model. Place additional network nodes as needed in the model. Generally, it's best to place nodes: Next to the fixed resources to which task executers will travel Next to the model reset position of task executers At key travel junctures, such as the beginning and end of a hallway You can connect network nodes together using the same method you'd use to create input/output port connections (A-connects) between fixed resources. Click the Connect Objects button on the toolbar to open a menu. Select Connect Objects from the menu to turn on connection mode. Use the A Key Shortcut Alternatively, you can press and hold the A key to turn on connection mode. When you are in connection mode, your mouse pointer will change to a plus sign with a chain link symbol next to it: Once you are in connection mode, click the first network node you want to connect. You will notice as you move your mouse that a yellow line will appear between the network node you clicked and your cursor. Click a second network node to create a travel path between the two nodes. You will still be in connection mode even after you connect two network nodes together. If you need to exit connection mode, press the Esc key or right-click a blank area in the model. Otherwise, you can continue connecting network nodes together if needed. Using Network Node Connections to Create New Nodes If you press and hold the A key and click a network node to enter connection mode, you can click a blank space in the model to place a new network node at that point. The new network node will be connected to the previous network node. Creating Curved Paths To create a curved travel path: Create a connection between two nodes using the method outlined in the previous section. Right-click the travel path to open a menu. Select Curved . Two spline points will appear on the path. Drag these spline points to create an appropriate curve. Deleting Network Nodes and Connections When you delete a network node, it will also remove any paths that are connected to it. To delete a network node: Click the node in the 3D model. Press the Delete key. Simply deleting a connection between nodes involves more steps than you might expect. It is similar to deleting port connections, but slightly different. To delete a connection: Click the Disconnect Objects menu on the toolbar to open a menu. Select Disconnect Objects from the menu to turn on disconnection mode. Use the Q Key Shortcut Alternatively, you can press and hold the Q key to turn on disconnection mode. When you are in disconnection mode, your mouse cursor will change to a plus sign with a broken chain link symbol next to it: Once you are in disconnection mode, you can remove a connection between two nodes. Click the first node you want to disconnect. You will notice as you move your mouse that a yellow line will appear between the node you clicked and your cursor. Click the node to which it is connected. The connection will change to a red arrow. What the Red Arrow Means Notice that the connection between two nodes is still present and all that changed was the green arrow changed to red. So far, all you've done is changed the two-way path into a one-way path. You need to delete the connection going in the other direction to fully delete the path. See Using Traffic Controllers and One-Way Paths for more information. While still in disconnection mode, click the second node again, then click the first node to fully delete the path. You will still be in disconnection mode even after you remove the connection between two objects. You can continue disconnecting objects together if needed. Alternative Methods of Deleting Paths As a shortcut, you can right-click on a path's arrow to open a menu and select Delete Path. You can also click on one of the arrows and press the delete key. Connecting 3D Objects to the Travel Network After you've created the travel paths, you then need to connect the 3D objects in the model to the travel network. When you connect a task executer to network node, that node will act as the entry point where the task executer will enter the travel network. You should try to use a network node that is close to the task executer's starting reset position. When a task executer is connected to a network node, it will display a red line between it and the node: When you connect a fixed resource to the travel network, that node will make it possible for task executers to travel to that location. If you don't connect the fixed resource, it could result in error messages during a simulation run. When a fixed resource is connected to a network node, it will display a blue line between it and the node: To connect 3D objects to a travel network: You can connect fixed resources and task executers to nearby network nodes using the same method you'd use to connect network nodes together. Click the Connect Objects button on the toolbar to open a menu. Select Connect Objects from the menu to turn on connection mode. Use the A Key Shortcut Alternatively, you can press and hold the A key to turn on connection mode. When you are in connection mode, your mouse pointer will change to a plus sign with a chain link symbol next to it: Once you are in connection mode, click the network node you want to connect to a 3D object. You will notice as you move your mouse that a yellow line will appear between the network node you clicked and your cursor. Click the fixed resource or task executer to create a connection with the node. Editing Node Properties How you will edit a network node's properties will depend on which properties you want to edit. You can right-click a node to open a menu to increase or decrease its draw size. You can click a node to open its properties on the right. In the Properties window, you can edit the settings for each connection. You can also edit the node's triggers, labels, and general properties---the same as you would for any fixed resource. See the Network Node reference page for a more detailed explanation of each property. You can also right-click a path to open a menu with some different properties. You can also right-click a directional arrow to open a menu with properties. Try experimenting with some of the options to see what they do. Editing Network Properties To edit the properties for the entire network: Right-click any network node to open a menu and select Network Properties to open the properties window. Make any changes to the network properties as needed. You can set the default connection types and the node or arrow draw size. Using Traffic Controllers and One-Way Paths You can add one or more traffic controllers to your model to help prevent collisions on certain paths in your model. A traffic controller can restrict access to a specific path or a set of paths. You will basically use it to define a restricted area that will only let a specific number of task executers in the area at a time. If a task executer tries to enter a restricted area while another traveler is occupying that area, the task executer will wait. The following image shows an example of a network node system before a traffic controller has been added: Notice that the operators frequently walk through each other while traveling on the center path. Now compare the same system in which a traffic controller is connected to the two nodes on the center path: The operators no longer walk through each other while traveling on the center path. Instead, they wait their turn and enter one at a time. Notice that they do overlap each other while waiting at a node, though. One way to solve this might be to introduce a second center path and changing both paths so that traffic can only flow one direction: The following sections will explain how to add traffic controllers and create one-way paths. Adding and Connecting Traffic Controllers To add and connect a traffic controller: In the Library under Travel Networks , drag a TrafficControl object into the 3D model, placing it near the nodes you want to control. You can connect a traffic controller to nearby network nodes using the same method you'd use to connect network nodes together. Click the Connect Objects button on the toolbar to open a menu. Select Connect Objects from the menu to turn on connection mode. Use the A Key Shortcut Alternatively, you can press and hold the A key to turn on connection mode. When you are in connection mode, your mouse pointer will change to a plus sign with a chain link symbol next to it: Once you are in connection mode, click the traffic controller. You will notice as you move your mouse that a yellow line will appear between the traffic controller you clicked and your cursor. Click a network node to connect it to the traffic controller. When a traffic controller is connected, you'll see a red line between the traffic controller and the node. Creating One-Way Paths The color of the directional arrows on a network path indicate the direction of travel and whether the network path allows faster task executers to pass slower or stopped task executers: Arrow Color Meaning Travel can occur in this direction and passing is allowed Travel can occur in this direction but passing is not allowed Travel cannot occur in this direction To create a one-way path: Click the Disconnect Objects menu on the toolbar to open a menu. Select Disconnect Objects from the menu to turn on disconnection mode. Use the Q Key Shortcut Alternatively, you can press and hold the Q key to turn on disconnection mode. When you are in disconnection mode, your mouse cursor will change to a plus sign with a broken chain link symbol next to it: Once you are in disconnection mode, you can remove a connection between two nodes. Click the first node you want to disconnect. You will notice as you move your mouse that a yellow line will appear between the node you clicked and your cursor. Click the node to which it is connected. The connection will change to a red arrow. Right-Click the Directional Arrow Alternatively, you can right-click the directional arrow for the direction you want to change and select the passing type you want to use. Creating Alternate Exits Sometimes you might want to connect fixed resources to more than one network node---especially if you've got a particularly long fixed resource such as a rack or a waiting line. When working with a fixed resource connected to two network nodes, you sometimes get strange behavior where a task executer doesn't travel on the most efficient path. This behavior is caused by the logic that controls how network nodes interact with fixed resources. By default, a task executer will exit a location using the same network node that it used to enter a location. You can see this behavior in the following image: In this example, both queues are assigning transport tasks to a transporter. First one queue assigns a transport task and then the next queue assigns it, alternating in an almost round robin fashion. Notice how it would be more efficient if the task executer exited using the opposite network node that it entered from. Instead, the transporter backtracks to the network node that it entered from before traveling to the other queue. You can fix this behavior by adding alternate exits to the path. Creating an alternate exit makes it so that the task executer can exit from either of the network nodes connected to a fixed resource, depending on which is more efficient: Notice how the transporter can now use either node as an exit. To create an alternate exit: Create a connection between two nodes. Also, don't forget to check that the nodes are connected to the fixed resource. Press and hold the D key to enter alternate exit creation mode. When you are in connection mode, your mouse pointer will change to a plus sign with a chain link symbol next to it: Once you are in connection mode, click the first network node you want to connect. You will notice as you move your mouse that a yellow line will appear between the network node you clicked and your cursor. Click a second network node to create an alternate exit connection between the two nodes. The path will turn orange to indicate that the connection allows alternate exits. Deleting Alternate Exit Connections To delete alternate exit connections, press and hold the E key to enter disconnection mode. Turning Travel Network Visibility On or Off After you've built your travel networks and validated that they work correctly, you might want to turn off the travel network's visibility to reduce the model's visual clutter. To turn off travel network visibility: Pick a network node that is located in a position where you will be likely to remember it. Right-click the node to open a menu. Point to Network View Mode and select None . Notice that all of the other network nodes and paths will become invisible except for the network node you used to change the network view mode. To turn the visibility back on, right-click the same node that you used to turn the visibility off. Point to Network View Mode and select Show All . Using Travel Networks With People Objects You can use FlexSim's people-based 3D objects and process flow activities to simulate business systems that are based around the flow of people rather than items, such as customer service centers or health care facilities. The customers or patients that flow through these kinds of simulation models are a special kind of task executer. As such, you can control their travel behavior the same way you would any other task executer. However, one difference is that these customers or patients aren't created until the simulation runs, so you can't connect them to the travel network directly. The way to fix this problem is to create the person at one of the network nodes rather than a location: At some point while building a people-based model, you'll use a Create Person activity in your process flow. Click this activity to select it. In Quick Properties next to the Destination box, click the Sampler button to enter sampling mode. In the 3D model, click one of the network nodes to open a menu. Select the network node's name from the menu. (Generally, the name starts with NN and is followed by a number.) Virtual Distances Using travel networks, you can create virtual distances between two nodes. A virtual distance is when you make the distance between nodes longer or shorter than the actual distance in model units. Virtual distances can be helpful if you want to simulate a task executer traveling a long distance from one point to another but you don't want to actually put those two nodes that far apart in your model. The following example shows an operator traveling on a path before the virtual distance has been applied: On the uppermost path, the distance from the left node to the right node is 7 model units. The following image shows an operator traveling a virtual distance of 50 model units on the uppermost path: Notice that the operator now walks slower while on the uppermost path to simulate the virtual distance between the two points. Also notice that the virtual distance only applies in one direction. To fix that, you'd have to apply the virtual distance to the connection going both ways. To create a virtual distance between two points: Click one of the nodes on either end of the path that you want to use to create a virtual distance. This will bring up its properties on the right. Under the NetworkNode section, select the path connection you want to change to a virtual distance. Note that the Current Distance box displays the actual distance between the two nodes in model units. In the Virtual Distance box, type the distance in model units that you want FlexSim to treat as the virtual distance. If you want to apply the virtual distance going in the opposite direction on the path, click the network node on the opposite end of the path and repeat the previous steps. Travel Offsets Be aware that for statistical purposes, once a task executer has reached a network node, FlexSim will consider the travel task to be complete. After that point, you might see a task executer continue traveling if it has to walk closer to a fixed resource. That travel time is called a travel offset , while the animation is appears to be traveling even though FlexSim no longer considers the task executer to be traveling. Just keep in mind that the travel offset period will not count as traveling for statistical purposes. You could compensate for this by creating a custom statistics collector or a milestone collector. See Key Concepts About Getting Data for more information."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/WorkingWithTasks/Travel/WorkingWithAStar/WorkingWithAStar.html",
        "title": "Working With A* Navigation",
        "content": "Introduction You can use the A* navigation tool (pronounced \"AStar\") to create travel barriers for task executers. Any fixed resources you connect to the A* system will also be treated as a barrier that cannot be passed through directly. When a task executer needs to travel from one point to another, the A* Navigator will then use these barriers and the travel threshold around fixed resources to calculate the shortest distance between the two points. Before reading this topic, you should make sure you are familiar with the concepts discussed in Key Concepts About Travel . This topic will provide a high-level overview of how A* navigation works. The rest of this topic will provide instructions about how to do the various tasks needed to build an A* navigation system. Adding an A* Navigator The A* Navigator is automatically added to the Toolbox when any A* object is added to the model (Grid, Barrier, Divider, Bridge, Path). To access the navigator properites, open the Toolbox and double-click the A* Navigator . Use these tabs and properties to change any settings as needed. For example, on the Visual tab, you might want to check the Show Grid and Show Travel Threshold checkboxes while you're in the early stages of building your system. Connecting 3D Objects to the A* Navigator After an A* Navigator has been added to your model, you will need to connect all the task executers that will use the navigation system. You also need to add any fixed resources to the model that should be treated as barriers that task executers can't walk through. There are three methods of connecting objects to the A* Navigator. Use any of the following methods to connect objects to the A* Navigator: A-Connect to A* Objects Click the Connect Objects button on the toolbar to open a menu. Select Connect Objects from the menu to turn on connection mode. Use the A Key Shortcut Alternatively, you can press and hold the A key to turn on connection mode. When you are in connection mode, your mouse pointer will change to a plus sign with a chain link symbol next to it: Once you are in connection mode, click on any A* object (Grid, Barrier, Divider, Bridge, or Path). You will notice as you move your mouse that a yellow line will appear between the object and your cursor. Click on a 3D object to connect it to the navigator. Once it's connected, a purple colored space will appear under the connected object. Press the Esc key or right-click a blank area in the model to exit connection mode. Use the Sampler Double-click on the A* Navigator in the Toolbox to open the navigator properties. Under the Setup tab, in the Members panel, select the Sampler button to enter sampling mode. Select the 3D object you'd like to connect to the navigator. You will see the object has been added to the Members list in the A* Navigator Properties. Add One or Multiple Objects Double-click on the A* Navigaor in the Toolbox to open the navigator properties. Under the Setup tab, in the Members panel, click the Add button. Click on one or multiple 3D objects you'd like to connect to the navigator. Click Select. You will see the object(s) have been added to the Members list in the A* Navigator Properties. Adding Dividers and Barriers You can add dividers and/or barriers to your 3D model in order to create obstacles that will cause the task executer to travel around them. Dividers can act like walls, as shown in the following example: Barriers can restrict an entire area in the grid: Adding Dividers To add dividers to a model: In the Library under the A* Navigation group, click the Divider object to enter Create Divider mode. Your mouse pointer will change to the Dividers icon to show that you are in Create Dividers mode. Find the position in your simulation model where you want to place a divider. When you click that position in the model and start moving the mouse pointer in a different direction, you'll notice that it begins creating a divider. Reposition the mouse pointer until the divider's end is the approximate length, angle, and radius you want it to be relative to the starting point. Click the mouse again to finish creating the divider. If needed, you can move the endpoints and connecting points to change the divider's length, angle, or radius. Press Esc or right-click a blank space in the model to exit Create Divider mode. Adding Barriers To add a barrier to a model: In the Library under the A* Navigation group, click the Barrier object to enter Create Barrier mode. Your mouse pointer will change to the Barrier icon to show that you are in Create Barriers mode. Find the position in your simulation model where you want to place a barrier. When you click that position in the model, a red diamond will appear. Once you start moving the mouse pointer in a different direction, you'll notice that it begins creating a barrier. Reposition the mouse point until the barrier's is the approximate length and width you want it to be. Click the mouse again to finish creating the divider. If needed, you can click the barrier's red resizing arrows to change the length or width of the barrier. Press Esc or right-click a blank space in the model to exit Create Barrier mode. Defining Barrier Travel Patterns By default, a barrier acts as a solid barrier that no one can travel in. However, you can also define a barrier as an area of one or more travel patterns. For example, you could define a barrier such that travelers may only travel one way while inside the barrier. As another example, you could set up a barrier so that travelers travel in one direction when on the right side of the barrier, and in the opposite direction when on the left side of the barrier. To define barrier travel patterns: Create a barrier as described above. Click on the barrier. Several manipulation handles will appear. To define a specific pattern, click on one of more of the four arrows in the center of the barrier. This will change the arrow color to green, indicating that travel is allowed in that direction. To define multiple separate pattern areas within the barrier, click on a scissor icon on the edge of the barrier. This will split the area into two separate areas, each with its own four pattern arrows in the center. Then click the arrows to define the travel pattern for each area. To change the size of pattern areas, click and move the dividing lines, or use the red sizer arrows shown over the dividing lines on the edge of the barrier. To remove areas that have been created, click the merge button on the edge of the barrier to merge two adjacent areas together. Adding One-Way Dividers A divider can be a one-way divider, meaning that a task executer can pass through a divider in one direction, but cannot pass through in another direction. The green arrows on the one-way divider indicate which direction the task executer can travel: To add a one-way divider, you'll use the same method you would use to add a normal divider. Once you've created the divider, click on the object, and in Quick Properties, uncheck Two Way . Troubleshooting Travel Thresholds Before reading this section, you'll want to make sure you've read the key concepts about A* Travel Thresholds to understand how they work. One of the most typical problems you might have with A* navigation is with task executers traveling to a place on the grid that you didn't expect or taking a strange route to a fixed resource. Usually, this is caused by problems with travel thresholds that extend beyond barriers or dividers. To troubleshoot this problem: Double-click the AStar Navigator in the Toolbox to open its properties window. On the Visual tab, check the Show Travel Threshold checkbox. Consider Showing the Grid As Well You might find it's helpful to see the A* grid and turn off the 3D model grid. To turn on the A* grid, check the Show Grid checkbox on the Visual tab. To turn off the 3D model grid, click a blank space in the model. In Quick Properties, clear the Show Grid checkbox. Click OK to save the changes and close the properties window. On the simulation control bar, press the Reset button to apply the visual changes. Click a fixed resource that is located close to barriers or dividers to select it. Check that the object's calculated path zone (the red points) do not extend beyond the barriers or dividers. The following image shows an example of an object in which the red points extend beyond the divider beside it: Reposition the fixed resource until the red points are contained on the correct side of the divider or barrier. Consider Checking All Fixed Resources It's generally a good practice to check the travel thresholds of all the fixed resources in your 3D model to prevent travel problems. Adding Preferred Paths A preferred path gives more weight to a particular path when the A* algorithm is calculating the most efficient path for a task executer to use to get from one point to another. Preferred paths will also create a path across dividers and barriers if the path crosses over them. The following image shows a task executer's travel path before a preferred path has been applied: As you can see, the task executer takes the upper path to get from the queue to the processor. Imagine that you wanted the task executer to take the lower path instead. You could create that logic by adding a preferred path: Be aware that the preferred path acts a little bit like a magnet. A task executer will only use the preferred path if it is close enough to influence the task executer's current travel trajectory. Once the task executer gets close to it, it will begin to incorporate the preferred path in the travel calculations. Notice also in the preceding image that the task executer only uses the preferred path when traveling in one direction. To make the task executer use it going in both directions, you'd have to add a second preferred path going in the opposite direction. To add a preferred path: In the Library under the A* Navigation group, click the Preferred Path object to enter Create Preferred Path mode. Your mouse pointer will change to the Preferred Path icon to show that you are in Create Preferred Path mode. Find the position in your simulation model where you want to place a preferred path. When you click that position in the model and start moving the mouse pointer in a different direction, you'll notice that it begins creating a preferred path. Reposition the mouse pointer until the preferred path's end is the approximate length, angle, and radius you want it to be relative to the starting point. Click the mouse again to finish creating the preferred path. Press Esc to exit Create Preferred Path mode. If needed, you can move the endpoints and connecting points to change the preferred path's length, angle, or radius. Troubleshooting a Preferred Path Sometimes when you test a preferred path, you might find the task executer doesn't use it. Try repositioning the path or try making it longer. You can also turn on the A* grid so that you can see how the preferred path intersects with the grid the task executer is traveling on. Another solution is to change the weight of the preferred path in the A* navigator's properties to affect how strongly it influences a task executer. Adding Bridges Bridges can be used to allow an operator to pass through a barrier as needed. In simulation terms, this can represent a task executer possibly walking over a barrier using stairs or some other kind of bridge. The following image shows what would happen in the A* system if you prevented a task executer from reaching its destination by placing too many barriers in its path: Notice that the task executer is considered as having arrived once it reaches the closest possible point to its destination. It unloads the item at the processor even though it is not very close to the processor. If you wanted the task executer to get closer to the processor, you could add a bridge: However, notice that now the task executer gets trapped on the other side of the dividers now. The task executer gets trapped because the bridge only goes one way. You can fix this problem by adding a second bridge going in the other direction: To create a bridge: In the Library under the A* Navigation group, click the Bridge object to enter Create Bridge mode. Your mouse pointer will change to the Bridge icon to show that you are in Create Bridge mode. Find the position in your simulation model where you want to place a bridge. When you click that position in the model and start moving the mouse pointer in a different direction, you'll notice that it begins creating a bridge. Reposition the mouse pointer until the bridge's end is the approximate length, angle, and radius you want it to be relative to the starting point. Click the mouse again to finish creating the bridge. Press Esc to exit Create Bridge mode. If needed, you can move the endpoints and connecting points to change the bridge's length, angle, or radius. Adding Mandatory Paths Mandatory paths can be used to force a traveler to only travel along designated paths in the system. For example, you may have a travel area that includes both humans and automated guided vehicles (AGVs). While the humans do not usually have designated paths to travel on, AGVs do. Here one option is to use the AGV module for AGVs, and use A* for humans. The problem with this option, however, is that AGV traffic would be blind to human traffic and vice versa. Thus objects may run over each other. Alternately, by defining mandatory paths in the A* travel area, and telling AGVs to only travel on mandatory paths, you can still simulate designated paths for AGVs, and both AGVs and humans would recognize and avoid each other because they share the same A* travel grid. To create mandatory paths: In the Library under the A* Navigation group, click the Mandatory Path object to enter Create Mandatory Path mode. Your mouse pointer will change to the Mandatory Path icon to show that you are in Create Mandatory Path mode. Find the position in your simulation model where you want to place a mandatory path. When you click that position in the model and start moving the mouse pointer in a different direction, you'll notice that it begins creating a mandatory path. Reposition the mouse pointer until the path's end is the approximate length and angle you want it to be relative to the starting point. Click the mouse again to finish creating the bridge. Press Esc to exit Create Mandatory Path mode. If needed, you can move the endpoints and connecting points to change the bridge's length, angle, or radius. Once you've added mandatory paths, you need to designate which travelers are to travel only on mandatory paths. To do this, click on a task executer that has been added to the A* network. In the Quick Properties panel on the right, under A* Traveler check the box Use Mandatory Paths . Adding Elevator Banks An Elevator Bank can simulate a bank of elevators that moves people between different floors in a facility. In the context of A*, an elevator bank implements a special bridge between two or more A* grids that are stacked on top of each other along the z axis. In order to get from one floor/grid to another, a traveler will go to the elevator bank and make a request to that elevator bank. An elevator will then go to the traveler's floor, pick up the traveler, and take her/him to the desired destination floor. To create an elevator bank: First create two or more vertically stacked A* grids. In the Library under the A* Navigation group, click the Grid object to enter Create Grid mode. Your mouse pointer will change to the Grid icon to show that you are in Create Grid mode. If you already see an A* grid on the ground level (a blue rectangular border surrounding A* barriers, dividers, etc.) then skip this step. To create the first grid, find the position in your simulation model where you want to place one corner of the grid. When you click that position in the model and start moving the mouse pointer in a different direction, you'll notice that it begins creating a grid. Reposition the mouse pointer until the grid surrounds the desired area in your model. Click the mouse again to finish creating the grid. Move the view's Grid Z up in the Z direction. First click in an empty area in your model. Then in Quick Properties under the View Settings pane, change the Grid Z value to the z position of the second floor, say 5 meters up. This will change the \"base point\" at which you are viewing the model, creating objects, etc. Again, find the position in your simulation model where you want to place one corner of the second floor grid. When you click that position in the model and start moving the mouse pointer in a different direction, it will create a new grid on the second floor. Reposition the mouse pointer until the grid surrounds the desired area in your model. Click the mouse again to finish creating the grid. Set back your view's Grid Z. Click in a blank area in the model, then in Quick Properties change the view's Grid Z back to 0. Now create the Elevator Bank. In the Library under the People group, drag a new Elevator Bank object into your model. Expand the object's x axis to make more elevators part of the bank. Use the standard A-connect mode to connect the Elevator Bank to the A* navigator object in the model, making the Elevator Bank part of the A* network. Adding Control Areas You can also use control areas to restrict the number of travelers allowed in a given area. While traditionally control areas have been used for AGV systems, they have been extended to also work with A* networks. To add a control area for A* travel restriction, you can do any of the following: Drag a Control Area from the A* Navigation category of the library. Check the A* Member property of any existing control area in your model. This will make the A* network aware of the control area and consequently restrict A* travel within that object's boundaries. Once you've added the control area to your model, adjust its location, size, and rotation to surround the area you want restricted, and set its Max Allocations property to the desired maximum number of travelers you want allowed in that area. The A* network will then restrict the number of travelers in that area. Turning A* Visibility On or Off After you've built your A* navigation system and validated that it works correctly, you might want to turn off the system's visibility to reduce the model's visual clutter. To turn off A* visibility: Double-click the AStar Navigator in the Toolbox to open its properties window. On the Visual tab, clear all the checkboxes as needed. Working With Large Task Executers If you're working with a large task executer such as a transporter, you should be aware that the task executer might actually be larger than a single square on the A* grid. FlexSim will determine which square a task executer is on based on its center point. Depending on the size of your travel grid, this can sometimes create some strange problems with the 3D visuals. These problems might become especially apparent when using collision avoidance. The A* navigator calculates collision avoidance purely based on the individual squares the travelers are moving on. This means that if a traveler's size takes up more than one square, this extra size will be ignored by the collision avoidance mechanism, and some travelers may overlap. You'll need to decide on the right balance between having a smaller square size and more precise travel, versus a larger square size and better collision avoidance."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/WorkingWithTasks/Travel/WorkingWithGIS/WorkingWithGIS.html",
        "title": "Working With GIS Navigation",
        "content": "Introduction to GIS Navigation You can use GIS maps, points, and routes to define paths that task executers can use to travel with the GIS Navigator. Before reading this topic, you should make sure you are familiar with the concepts discussed in Key Concepts About Travel . The rest of this topic will provide instructions about how to do the various tasks needed to build a GIS travel network. Creating Maps The first step in building any GIS travel network is to add a map to your model. With the Library open, under the GIS group, drag a Map into your 3D model. Select the map and use the mouse wheel to zoom into a particular location on the map. You can use the left mouse button to pan the map's position. Move and resize the map to where you want it in your model. Scaling all axes of the map will make the entire map larger or smaller. Scaling just the X or Y axes will adjust how much of the map is drawn at the current zoom level. Adding and Connecting Points The next step in building a GIS travel network is to add points to your model and connect them together to form routes: With the Library open, under the GIS group, drag a Point onto your map. It will appear visually like a square point on the map. GIS Points can also have 3D shapes. Click Point in the Library to create points with different shapes. A point's shape can also be changed to any custom 3D shape using the Properties pane. You can create routes by connecting points together using the same method you'd use to create input/output port connections (A-connects) between fixed resources. Click the Connect Objects button on the toolbar to open a menu. Select Connect Objects from the menu to turn on connection mode. Use the A Key Shortcut Alternatively, you can press and hold the A key to turn on connection mode. When you are in connection mode, your mouse pointer will change to a plus sign with a chain link symbol next to it: Once you are in connection mode, click the first point you want to connect. You will notice as you move your mouse that a yellow line will appear between the point you clicked and your cursor. Click a second point to create a route between the two points. You will still be in connection mode even after you connect two points together. If you need to exit connection mode, press the Esc key or right-click a blank area in the model. Otherwise, you can continue connecting points together if needed. Changing Route Types By default, routes are created as flight paths. You can change their type using Properties or change the default type in the GIS Navigator Properties. Create a route between two points using the method outlined in the previous section. Click on the route to view its Properties. Change its Type to Driving Roads . Click the Update button. It may take a moment to download the driving roads information from the routing server. Once the routing data is downloaded, the route will change to driving road paths. Right-click the map and select GIS Navigator Properties . In the GIS Navigator Properties window, you can change the Default Route Type that is created when connecting points together. In the GIS Navigator Properties window, you can also adjust the settings used for air route calculations and specify the Routing Server URL. Deleting Points and Routes When you delete a point, it will also remove any routes that are connected to it. To delete a point: Click the point on a map. Press the Delete key. To delete a route: Click the route on a map. Press the Delete key. Connecting 3D Objects to the GIS Network After you've created the travel routes, you can then connect 3D objects in the model to the GIS network. To connect 3D objects to a GIS point: You can connect fixed resources and task executers to a point using the same method you'd use to connect points together. Click the Connect Objects button on the toolbar to open a menu. Select Connect Objects from the menu to turn on connection mode. Use the A Key Shortcut Alternatively, you can press and hold the A key to turn on connection mode. When you are in connection mode, your mouse pointer will change to a plus sign with a chain link symbol next to it: Once you are in connection mode, click the point you want to connect to a 3D object. You will notice as you move your mouse that a yellow line will appear between the point you clicked and your cursor. Click the fixed resource or task executer to create a connection with the point. When you connect a task executer to a point, that point will act as the reset point where the task executer will start traveling. When a task executer is connected to a point, it will display a red line between it and the point: When you connect a fixed resource to a point, that point will make it possible for task executers to travel to that location. Fixed resources can be connected to multiple points. When traveling to a fixed resource, the task executer will travel to the point that is closest to the traveler's current point. When a fixed resource is connected to a point, it will display a blue line between it and the point: The connection lines are only drawn when the involved objects are highlighted. Highlighted travelers will draw a red line to their current point on whatever maps are drawing that point. Highlighted fixed resources will a draw blue line to any connected points on whatever maps are drawing those points. Highlighted maps will draw red lines and blue lines from any visible points to any involved travelers or fixed resources. Visualizing Travelers When task executers are traveling between points using the GIS Navigator, the task executer's 3D shape will not move. Instead, you will see a representation of that traveler's current geographic position drawn on the route on the map. Travelers that are at a point but not currently traveling are not drawn on the map."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/WorkingWithTasks/AGVNetworks/KeyConceptsAGVNetworks/KeyConceptsAGVNetworks.html",
        "title": "Key Concepts About AGV Networks",
        "content": "Reasons to Simulate AGV Systems FlexSim's AGV objects and tools are designed to help you simulate business systems that will use automated guided vehicles (AGVs). AGVs are portable robots designed to transport goods from one destination to another. The following image shows a hypothetical example of a hospital that uses AGVs to transport medical supplies, laundry, and waste: AGV systems are now being used for a growing variety of applications in material handling, manufacturing, and beyond. Since AGV systems are costly to implement, they are ideal for a simulation project. You can experiment with different AGV system setups in a simulation model until you find the most efficient system for your needs. An AGV simulation model can also act as a communication tool when you get to the implementation phase. You can hand off the model to the individuals who will program the AGVs to help them understand the kind of logic that they will need to use when they program the AGVs in the system. Before Building an AGV Network Before beginning your AGV simulation project, you should ideally research the types of AGVs your system will use. If it's not possible to find out information about the AGV system before you begin your project, keep in mind that you can build a working model and then make modifications to it as you get more information about the AGVs you will use. With that in mind, the following is a list of questions that you could consider asking your vendor about the AGVs that you'll use in your system: Navigation - What kind of navigation system will your AGVs use? How will vehicles enter and exit the system? Will operators need to call AGVs or will they loop on a continuous system looking for work? Routing - How will your AGVs be routed from one location to another? Will your system use a central AGV controller? How will AGV traffic be controlled to prevent collisions? Vehicle Specifications - What is the load capacity of the AGVs? How long does it take to load and unload? At what speed do the AGVs travel, including when decelerating or turning? Do their speeds change when they are carrying a load? What is their battery lifespan and charge rate? Overview of AGV Objects and Tools The following sections will provide a high-level overview of the 3D objects and tools that are used to build an AGV model in FlexSim. Library Objects The TaskExecuter 3D object in the library is designed to look and move like an AGV, so it is the best object to use in an AGV model. You can find this object in the Task Executer category of the library. The AGV category in the library has the following objects: Name and Icon Description Straight Path Draws a straight path that AGVs will use to travel from one location to another. Curved Path Draws a curved path that AGVs will use to travel from one location to another. Join Paths Join paths acts more like a tool than an object. Use it to create a curved AGV path connecting two AGV paths. Control Points Control points handle a lot of the logic in AGV networks. AGVs and flow items will need to enter and exit the network through a control point. If you need to route AGVS to different floors, you'll use control points to communicate with elevator objects. Control points can also be connected to other control points to create look for work systems where AGVs loop through the network looking for tasks at different locations. Control Area You can add control areas to sections of the AGV network to prevent collisions. These control areas will restrict access to that section of the AGV network by only allowing a fixed number of AGVs into the area at a time. Process Flow Templates To make AGV simulation even simpler, FlexSim has several pre-built AGV process flow templates you can use with your AGV simulation project. These process flow templates already have basic logic to simulate many common AGV systems, but also can act as a launching point for you to customize the logic to your specific AGV system's needs. All you need to do is choose which process flow is closest to how your system works, then attach the AGVs in your 3D model to the chosen process flow, then adjust the settings or add new logic that will be unique to your AGV system. See Using the AGV Process Flow Templates for more information on process flows for controlling and dispatching AGVs. See Adding Elevators to AGV Networks for more information on a process flow that integrates elevators into AGV travel. How AGVs Work in FlexSim AGVs are essentially task executers that have been connected to the AGV path network . As such, all travel tasks will be executed via the AGV travel network. For that reason, you should consider reading Key Concepts About Task Logic before reading about AGVs specifically. Other than defining the specific logic of an AGV's travel tasks, generally all other tasks are handled according to normal task executer logic. This is no different than if you were to connect the task executer to an A* travel network . However, when you connect the AGV to an AGV Process Flow Template this enables special dispatching and task sequence generation logic that is specifically catered to AGV systems. In other words, merely connecting the task executer to the AGV network only affects the Transportation or Travel aspect of a task executer's behavior. However, when you connect the AGV to an AGV Process Flow Template , you are defining specific solutions associated with the Task Sequence Generation and Task Sequence Dispatching aspects of the task executer's behavior."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/WorkingWithTasks/AGVNetworks/WorkingWithAGVPaths/WorkingWithAGVPaths.html",
        "title": "Working With AGV Paths",
        "content": "Introduction to AGV Paths AGV paths are the actual paths that AGVs will travel on as they move from one location to another. For that reason, adding a set of paths is generally the first step in building an AGV network. For the most part, AGV paths can be added, moved, resized, etc. using the same methods you would use for other 3D objects. (See the chapter on Using 3D Objects for more information.) However, the key difference is that AGV paths have two ends: respectively called the start and the end . The start is where AGVs enter the path and the end is where AGVs leave the path. Although these two ends are connected, you can move them independently. Curved paths also have a radius, start angle, and sweep angle that you can use to control the arc of the path. Another key difference is that you can set the direction that AGVs will travel on the paths. Each path has a directional arrow that indicates which direction AGVs can travel along that path: You can also set a path to allow two-way travel, in which case the directional arrow will look like a hexagon: Adding Paths To add a new path: In the Library, click the Expand button next to the AGV group to view the AGV objects. Click the Straight Path or Curved Path object to enter path building mode . When you are in path building mode, your mouse pointer will change to a plus sign with either a Straight Path or Curved Path icon next to it, as shown in the following image: Once in building mode, find the position in your 3D model where you want to place the start of the AGV path. When you click on that position in the model and start moving the mouse pointer in a different direction, you'll notice that it begins creating an AGV path. Reposition the mouse pointer until the path's end is at the approximate length and angle you want it to be relative to the start. Click the mouse again to finish building the path. After building your first path, you will still be in path building mode. You can add any additional paths as needed. Be aware that the paths will not be connected at this point in the path building process. Press the Esc key to exit path building mode. Joining Paths One way that you can join paths together is to bring the ends of two paths close enough to the point that they snap together. Another method is to use the Join Paths object in the FlexSim library. Even though the Join Paths object is in the library, it actually functions more like a tool than a 3D object. When using the Join Paths tool, you can either join the ends of two paths or create junctions coming off one path to another. To join two paths: In the Library under the AGV group, click the Join Paths object to enter path joining mode . When you are in path joining mode, your mouse pointer will change to a plus sign with a Join Paths icon next to it, as shown in the following image: While you are in joining mode, hover your mouse over the end of one of the paths until it turns yellow, as though it were highlighted. Click the path and start moving the mouse pointer to the path you want to join. Click the path when it turns yellow as though it were highlighted. The paths should now be joined. Check that the direction of the connecting path matches the directions of the joining paths and change the direction if needed. See Changing Path Directions for more information. Press the Esc key to exit path joining mode. Moving or Resizing Paths Like other 3D objects, AGV paths can be moved or resized using either the Properties pane or your mouse. (See Moving, Rotating, Resizing 3D Objects for more information.) However, the key way in which paths are different is that they have resizing handles at the start and end of the path. Curved paths have an additional green resizing handle that can be used to change the length of curved paths. The following sections will explain the differences for using either a mouse or Properties to move or resize paths. Using the Mouse to Move or Resize a Path In order to use your mouse to move or resize a path, you must first click once on the path to highlight it. After you've taken that step, use the steps listed in following table: Task Process Demonstration To move the entire path Click anywhere on the path (except the endpoints or other handles) and drag the path to the desired position. To move either the start or end of the path Click the resizing handle on either the start or end of the path. Drag the start or end to the desired position. To change the height (Z-axis) of the entire path Click anywhere on the path (except on the resizing handles) and scroll the mouse wheel up or down until the path is at its desired height. To change the height (Z-axis) of either the start or end of the path Click the resizing handle on either the start or end of the path. Scroll the mouse wheel up or down until the start or end is at its desired height. To change the length of the path Click the resizing arrow on either the start or end of the path. Drag the start or end to the desired length. Additional Resizing Options for Curved Paths Everything in the preceding table applies to curved paths, but you can also use the green resizing arrow to change its length. See Changing the Radius and Angle of Curved Paths for more information. Using Properties to Move or Resize a Path You might want the location, rotation, and size of the path to be more precise in your model. In that case, it's generally a good practice to use your mouse to move or resize your path until it is in the approximate position or size you want it to be. Then you can use the Properties pane to make it more precise. When you highlight a path by clicking it, the right pane displays the Properties for that specific path. The controls that appear in Properties will vary depending on whether you clicked a straight or curved path. Straight paths have settings that adjust the position and size of the start and end of the path, as illustrated in the following image: However, curved paths also have boxes that adjust the radius, start angle, and sweep angle. The following image shows the Properties for a curved path: Try experimenting with some of the Properties to get your path exactly the way it should be. Changing the Radius and Angle of Curved Paths Curved paths have three additional properties: Radius - The radius of the path relative to the midpoint of the hypothetical circle around which the path is drawn. Changing the radius will affect the length of the path because it makes this hypothetical circle larger. Start Angle - The angle of the start end of the path relative to the simulation model grid. For example, if the start angle is set to 90, the edge of the path's start direction will be perpendicular to the x-axis of the model. Sweep Angle - The angle of the end of the path relative to the start angle. For example, if the start angle is set to 45 and the sweep angle is set to 90, the edge of the path's end direction will be 135 degrees offset from the x-axis of the model. You can use either the mouse or Properties to change the radius, start angle, and sweep angle of curved paths. It's generally a good practice to use your mouse to move or resize your path until it is in the approximate position or size you want it to be. Then you can use the Properties pane to make it more precise. To change the radius, start angle, or sweep angle of a curved path, you must first click the path once to highlight it. After you've taken that step, use the steps listed in following table: Task Process Demonstration To change the radius Click the green resizing handle in the middle of the curved path and drag the mouse to the desired radius. To change the start angle Click the red resizing handle on the start end of the curved path and drag the mouse until the edge of the start is at the desired angle. To change the sweep angle Click the red resizing handle on the end of the curved path and drag the mouse until the edge of the end is at the desired angle. Changing Path Directions Every AGV path has a large arrow on it that indicates which direction AGVs will travel on the path: To change the direction that AGVs travel on a path: Click the path to highlight it. In the Properties pane, click the Switch Direction button. The direction indicator on the path will now point in the opposite direction. You can also make a path a two way path so that AGVs can travel in either direction on the path: Click the path to highlight it. In the Properties pane, check the Two Way check box. The direction indicator on the path will now display a hexagon. Copying Paths AGV paths can be copied and pasted using many of the same methods you would use to copy and paste other 3D objects. See Copying and Pasting 3D Objects and Properties for more information."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/WorkingWithTasks/AGVNetworks/BuildingAGVLogic/BuildingAGVLogic.html",
        "title": "Building AGV Network Logic",
        "content": "Introduction to AGV Network Logic The following image shows an example of a control point on an AGV path: In addition to the AGV process flow template, AGV control points are the key to creating the logic and functionality of AGV networks: AGVs need to be connected to control points in order to enter and exit the AGV network When an AGV passes over a control point, that control point can give the AGV instructions about which control point should be its next destination (a pick up point, a drop off point, another control point where the AGV will look for work, etc.) Fixed resources must be connected to control points in order to transport items through the AGV network Control points can affect traffic control and help prevent potential collisions or deadlocks If you are going to use elevators to transport AGVs to multiple floors, you'll need a combination of control points to handle that logic Adding Control Points to a Path To add a control point to a path: In the Library under the AGV group, drag a Control Point into the model. Position the control point so that it is over an AGV path. When it connected to an AGV path, the control point will look like a diamond with crosshairs, as shown in the following image: Connecting Fixed Resources to the AGV Network When an item in a fixed resource needs to be transported via the AGV network, you need to associate that fixed resource with a specific control point on the network, so that AGVs will know how to navigate to the fixed resource on the network. To connect a fixed resource to a control point: Press and hold the A key to enter connection mode. When you are in connection mode, your mouse pointer will change to a plus sign with a chain link symbol next to it: Click the fixed resource you want to connect to a control point. You will notice as you move your mouse that a yellow line will appear between the object you clicked and your cursor. Hover over the control point so that it is highlighted. Click the control point to open a menu. Select Location . A blue line will appear to show that the fixed resource is now connected to the control point. Click the fixed resource to open its properties on the right. Under the Output section, set up the Send To Port property so that it sends items to the appropriate destination: You can use port connections to send the item to its destination. Make sure that the upstream fixed resource is connected to the downstream fixed resource with an input/output port connection (A-connect). Then set the port connection to use whatever flow logic your business system needs. See Overview of 3D Object Flows for more information. You can push the item to a list. Make sure that the downstream fixed resource(s) are set up to pull items from the list as well. Also under the Output section, check the Use Transport box. In the box next to this checkbox, set up this property to assign AGVs to transport the item to its destination: If you are using the AGV process flow template , you should select Use List and select the AGVWork list that is automatically generated when you use the AGV process flow template. If you are using a simple AGV network system with one AGV, use a center port connection (S-connect) to connect the fixed resource to the AGV. If you are using multiple AGVs, use a center port connection (S-connect) to connect the fixed resource to a dispatcher. Then, use input/output connections (A-connects) connect the dispatcher to all the AGVs in the system. Setting Loading Times To simulate a time delay while an AGV loads an item, you can set the load time on the AGV object itself. See Connecting AGVs to the AGV Network for more information about AGV settings. When a simulation runs, the fixed resource will hold the item until the AGV reaches the control point it is connected to. The item will immediately appear on the AGV once it has been transferred. Connecting AGVs to the AGV Network In order for an AGV to travel on an AGV path network, it needs to be connected as a Traveler AGV to a control point on the AGV network. Choose a control point that is on the main AGV network. It should be close to the area where you want the AGVs to enter. To connect an AGV to a control point: Press and hold the A key to enter connection mode. When you are in connection mode, your mouse pointer will change to a plus sign with a chain link symbol next to it: Click the AGV. You will notice as you move your mouse that a yellow line will appear between the object you clicked and your cursor. Hover over the control point so that it is highlighted. Click the control point to open a menu. Select Traveler AGV . A red line will appear to show that the AGV is now connected to the control point. When you reset the model, the AGV will begin traveling from this control point. Repeat the previous steps to connect multiple AGVs to control points. When you reset the simulation model, any AGVs that are connected to this control point will appear on that point. If multiple AGVs are connected to that point, they might overlap on that control point. Control Point Connections Control points are the basic building blocks of logic in an AGV network. They are both the \" end points \" of travel, as well as the \" stepping stones \" of AGV look-ahead allocation. Additionally, control points can be logically associated with each other, through control point connections. Control point connections are an incredibly powerful feature that makes it easier to drive the logic of an AGV model. At its most basic level, a control point connection is just a named connection from a control point to another object or control point. A connection can be one-way or two-way, and a control point can have more than one connection of the same name. For example, a control point CP1 may have two DropoffPoints connections, to control points CP2 and CP3 respectively. Control point connections, by themselves, do not have inherent, hard-coded meanings. In other words, creating the above-mentioned DropoffPoints connections from CP1 to CP2 and CP3 does not actually trigger any special internal logic of the AGV system. Simply making these connections will not change anything about the way your model runs. However, when you decide to use a process flow like the AGV process flow template or the AGV elevator process flow , or if you decide to add AGV Offset Travel , you are giving meaning to various control point connections. For example, the AGV process flow defines specific meanings for the Location , PickupPoints , DropoffPoints , ParkPoints , WorkForwarding , and NextWorkPoint connections. The AGV elevator process flow defines specific meanings for the ElevatorFloorCP , ElevatorRedirectCP , and ElevatorEntryCP connections. Creating Control Point Connections in the 3D View To create a control point connection: Press and hold the A key to enter connection mode. When you are in connection mode, your mouse pointer will change to a plus sign with a chain link symbol next to it: Click the control point from which you want to originate the connection. You will notice as you move your mouse that a yellow line will appear between the object you clicked and your cursor. Hover over the control point that will become the end point of the connection, so that it is highlighted. Click the control point to open a menu. Select name of the control point connection you want to create. Creating Control Point Connections in Properties In some cases, the control points are geographically distant, such that is hard to make the connection in the 3D view. In this case, you can also create a control point connection through a control point's Properties pane. Click the control point from which you want to originate the connection. In Properties under Connections , press the drop-down and and select the name of the connection you want to add to, e.g. PickupPoints . Press the Add button and a popup will appear. Navigate in the view to the desired control point you want to connect to, or type in the name of the control point in the search/filter control. Once you've found the target control point(s), click or lasso them so that they are highlighted in blue. Press Select . Removing Control Point Connections To remove a control point connection: Click the control point to select it. In Properties, find the Connections menu and select the type of connection you want to remove. In the box below this menu, click the name of the object to which you want to remove the connection. Click the Remove button to delete the connection. Changing AGV Settings After you've set up the basic logic of your AGV network, you might want to make changes to the way AGVs behave. You can customize the speed at which AGVs travel, their load capacity, their battery life cycle, the amount of time they take to load and unload items, etc. This section will discuss the different properties you can control and where to adjust those settings. AGV Network Properties The AGV network properties can be accessed either from the Toolbox (it shows up as AGV Network) or by right-clicking on an AGV path and choosing AGV Network Properties . Using the AGV network properties window, you can set the global speed for all AGVs on the AGV networks, their battery capacities and charging rates, their accumulation behavior, their deallocation behavior, and general visual settings. The following shows two of the more useful tabs on the AGV Network Properties window: See AGV Network in the reference section for more information about these properties. TaskExecuter Properties If you click an AGV (which is technically the TaskExecuter object), it will open its properties where you can edit properties such as its capacity, etc. Note that the AGV network logic ignores the task executer's max speed, acceleration, and deceleration properties in favor of its own customized speed settings. See The Task Executer Tab in the reference section for more information about these properties. Understanding Allocation Behavior and Terminology AGV networks have a powerful look-ahead mechanism that can avoid crashes and provide sophisticated traffic control. FlexSim provides several mechanisms for configuring these behaviors. Control points act as \"stepping stones\" on the AGVs path. When an AGV arrives at a control point, say CP1, it will attempt to allocate ahead to the next control point, say CP2. If it cannot allocate CP2, then it will decelerate to stop at CP1, and wait until it can allocate CP2 before continuing on. This is independent of how far separated CP2 is from CP1 on the network. In other words, when default settings are used, control points are the only points where AGVs can stop on the network. They will not continue from one control point to the next until they have allocated that next control point, no matter how far ahead it is. As such, they may look very far ahead in their travel path to allocate the next control point. Terminology A few key terms to be aware of: Allocation Allocation is performed when an AGV is traveling to or through a control point/area. You could think of it as acquiring that control point so that it can't be acquired by other AGVs. You can set the maximum number of AGVs that may allocate a specific control point/area at a given time. Control point/area allocation requests are made when the AGV pre-arrives to the previous control point. For example, if an AGV's travel path traverses, say, CP1 then CP2, then the AGV will request allocation of CP2 when it pre-arrives at CP1. Deallocation When an AGV releases a control point so that it can be acquired by another AGV, it deallocates that object. You control the timing of when this happens by defining an object's Deallocation Type . Collision A collision happens when one AGV runs over the top of another AGV. In real life the AGVs would physically collide, but in a simulation, since they are each merely 3D images drawn on the screen at various positions, it will show them overlapping. In either case, this represents an error in the system. In FlexSim it will happen if you give a control point a Max Allocations value greater than 1, but don't use accumulation . Deadlock Deadlock happens when requests for allocation of control points form a circular wait , such that all AGVs in the cycle are stuck because they're waiting on each other. A circular wait can happen with as few as two AGVs and two control points. For example, if AGV1 has allocated CP1 and wants to allocated CP2, whereas AGV2 has allocated CP2 and wants to allocate CP1, this forms a deadlock. Neither AGV1 nor AGV2 can release their allocated control point until they have allocated the next control point, and neither can allocate the next control point until the other AGV has released it. By default, the AGV module will detect deadlock, stop the model, and show an error message when it happens. However, the OnAllocationFailed trigger includes a parameter that tells if a given allocation failure represents deadlock, and if you return 1 from that trigger, the default behavior will be skipped and you can define deadlock recovery yourself. Nevertheless, deadlock recovery can be very complicated to implement, so we advise, where possible, to avoid deadlock altogether. Control Areas A control area acts as an additional allocation tool for restricting access to an entire area. As already mentioned, when an AGV arrives at a control point, it will allocate ahead to the next control point. If it must enter any control areas as part of its path to that control point, it must also allocate all of those control areas, then allocate the control point, before it can proceed forward. Note that if it cannot allocate all of the control areas as well as the control point itself, it will not allocate any of them. This helps to prevent deadlock. By placing a control area around an area of your AGV network, you can prevent collisions and deadlock. Control areas will restrict access to an area of the AGV network so that only a set number of AGVs can occupy that area at a time. By default, only one AGV can occupy the area at a time, but you can change the number of AGVs that can access the area in the control area's properties if needed. Preventing Collisions and Deadlocks In FlexSim, simple control point allocation/deallocation is the default mechanism by which AGVs avoid collisions with each other. The reasoning for using this as the default behavior is guided by a 'collision avoidance guarantee'. Collision Avoidance Guarantee There are a set of rules that, if followed, will guarantee that AGV collisions will never happen in your model. These are: Rule How to Follow Rule 1 An AGV must allocate a control point before traveling to it Automatically guaranteed by internal AGV logic Rule 2 Only one AGV can allocate a control point at a time Leave each control point's Max Allocations property as 1 Rule 3 An AGV will not deallocate a control point until it is completely past that control point Use the default 'Deallocate at Next Control Point' Deallocation Type , and follow Rule 4 Rule 4 All control points are spaced at least one AGV length away from each other Properly lay out control points in the model Rule 5 AGV paths are sufficiently spaced so that AGVs traveling on one path can never collide with AGVs traveling on a completely separate path Properly lay out paths in the model Rule 6 AGVs can only stop at control points Do not use accumulation , preemption , or customized AGV travel behavior In situations where following all of these rules is possible, you get collision avoidance for free. Just create your control points, path network, AGVs, and dispatching logic. Run the model and you will get collision avoidance automatically. Relaxing the Rules In reality, however, some of these rules may need to be relaxed in order get the behavior you want or to make model-building easier. For example, you may have long sections of path in your model. If you put control points too far apart on those paths, then FlexSim's default allocation algorithm (Rules 1 and 2) will cause low throughput because AGVs must allocate far ahead, causing large gaps where there are no AGVs. To fix this: Place many more control points along the path. This would ensure that you're still following all rules above, but it takes more work because you have to create a lot of control points. Instead, relax Rule 2 above by increasing the number of AGVs that can allocate a control point that is on a long section of path, and instead use accumulation to ensure AGVs do not run over each other while on that path. Additionally, intersections can by themselves be an inherent violation of Rule 5, and you may need to use control areas and/or accumulation to prevent collisions at intersections. Also, you may want to actually use the features that would break Rule 6. Finally, following Rules 1-6 does not guarantee against deadlock, so you'll still need to ensure deadlock prevention. The reality is that, while these rules are a good starting point to think about as you build your model, they are in the end just guidelines, and you'll likely need to implement strategies that do not strictly follow Rules 1-6. Nevertheless, it's important to understand that relaxing one or more of these rules will negate the collision avoidance guarantee. Consequently, in those situations you may need to provide some other mechanism for preventing collisions. FlexSim provides many mechanisms for achieving this, such as control areas , accumulation , mutual exclusion using process flow, or even proximity detection with the Agent module. Further, you can mix and match strategies. In some areas of your model you can follow all of the rules and thus get collision avoidance for free, while in other areas, you can relax some rules and implement supplemental collision avoidance mechanisms. This section will explain strategies for fixing various problems associated with deadlock and collision avoidance. Adding More Control Points As mentioned above, you can add more control points to your network. This can increase overall throughput, but also serves to prevent deadlock. Having more control points makes it so that AGVs have more \"stepping stones\" that they can go to in getting to their destination. This helps prevent the creation of allocation cycles required for deadlock. Changing Deallocation Types By default, control points are set to deallocate when the AGV reaches the next control point. You can change a control point's deallocation type to make it deallocate earlier, freeing more control points to be re-allocated: Click a control point to select it. In Properties click the Deallocation Type menu and select Deallocate When Past Current . Adding Control Areas A control area can be useful for avoiding deadlock, or if you need to relax one or more of Rules 2-6, but still need to avoid collisions. To add a control area: In the Library in the AGV group, click Control Area to enter control area building mode. Place your cursor outside the top right corner of the portion of the AGV network where you want to add the control area. Click to begin drawing a control area box. Draw the control area box around the portion of the AGV network you want to restrict. Press Esc to exit control area building mode. Click the control area and use the sizer arrows if you need to resize the control area. While the newly added control area is selected, you can edit its properties in the Properties panel if needed. Managing Two-Way Paths If your system includes two-way paths, then you should find a way to prevent AGVs from traveling in opposite directions on the path at the same time. Two AGVs going in opposite directions on the same path at the same time will almost always create a deadlock situation. Control areas can be used here to implement such restrictions."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/WorkingWithTasks/AGVNetworks/UsingAGVProcessFlowTemplate/UsingAGVProcessFlowTemplate.html",
        "title": "Using the AGV Process Flow Templates",
        "content": "Overview and Concepts To make AGV simulations simpler, FlexSim provides several pre-built AGV process flow templates you can use with your AGV simulation projects. These process flow templates include pre-built sophisticated logic that makes it relatively easy to simulate many if not most AGV systems. The set of available process flow templates are: Basic AGV AGV with Work Forwarding AGV with Basic Parking AGV with Heuristic Parking Advanced AGV While all process flows work around the same core model design, each process flow progressively adds features and sophistication. The specific differences between process flows will be discussed in detail later in this topic. The image below shows the most sophisticated process flow template, Advanced AGV. While you may find one of these process flows perfectly sufficient for your AGV simulation project, these process flows are also intended to be launching points for you to customize to your simulation's requirements. If there are features that you need that are not supported by these process flows, you can choose the simplest AGV process flow that implements the features you do need, and then extend it with the additional features that are required. This topic will make reference to many concepts associated with building task sequence logic. As such, we advise first reviewing Key Concepts About Task Sequence Logic before proceeding with this topic. Setting Up the AGV Process Flow Template To set up an AGV process flow template: Add an AGV process flow - On the toolbar, click the Process Flow button to open a menu. Point to Add an Object Process Flow and select one of the AGV process flows to create a new process flow template. The AGV Templates Auto-Generate a Global List When you first create an AGV process flow template, the template will also create a global list named AGVWork . This global list is for handling available AGV transportation tasks. This list is automatically integrated into the logic of the AGV process flow template. You'll link to this list when you're indicating which transport to use on a fixed resource's Use Transport property. See Connecting Fixed Resources to the AGV Network for more information. Attach objects to the process flow - In the newly created process flow, click a blank area to ensure nothing is selected. In Properties under the Process Flow Instances group, find the Attached Objects (instances) box. Click the Sampler button by this box to enter sampling mode. Then click on an AGV in the 3D view. It should now show up in the Attached Objects box. Repeat this step to add additional AGVs as needed. Attaching Objects through the Right-Click Menu You can also attach objects to the process flow by right-clicking the object in the 3D view, and selecting the target process flow in the Process Flow context menu. Configure your AGV network with appropriate connections - Primarily, the network needs a loop of NextWorkPoint connections. To do this, 'A' connect from one control point to another and choose NextWorkPoint . AGVs will follow this loop looking for items to pick up. These control points become the \"Work Points\" in the system where AGVs find work to do. See Creating Work Point Loops below for more information. Differences Between Process Flows: Connection Capabilities The primary difference between the available process flows is that progressively more sophisticated process flows give logical meaning to additional AGV connections, like WorkForwarding , PickupPoints , and DropoffPoints . These will be explained in detail later. However, all process flows assume the model is built with a loop of NextWorkPoint connections. Configure objects in the model to add work for the AGVs to perform - A global item list named AGVWork will have been added to the model's toolbox. To generate work for the AGVs to do, you push items to this list. You can do this with fixed resources by going to their properties Output pane, check Use Transport, and choose the behavior: Use List > Push to Item List (No Task Sequence) . See also Job Dispatching below for more information. How the AGV Process Flow Templates Drive AGV Behavior In this section we explain in detail how the AGV process flow templates implement task executer task logic . AGVs are essentially task executers that have been connected to the AGV path network. As such, all travel tasks will be executed via the AGV travel network. Thus, when you connect a task executer to an AGV network, you are defining the Transportation or Travel aspect of its behavior. Connecting a Task Executer to an AGV Network Transportation or Travel How do task executers move around? Via an AGV network. Alternately, when you attach an AGV process flow template to an AGV, you are defining both the AGV's Task Sequence Generation and Job Dispatching behavior. Connecting a Task Executer to the AGV Process Flow Template Task Sequence Generation How are task sequences defined? AGV process flow generates task sequences. Job Dispatching Who or what will perform what jobs? AGV process flow handles dispatching. Note that, when using the AGV process flow template, the Item Flows and Routing aspect of task executer logic is mostly still up to you. You can define it through connecting fixed resources, by using another process flow, etc. Item Flows and Routing Where do the items need to go? Mostly still up to you. Task Sequence Generation Task Sequence Generation How are task sequences defined? AGV process flow generates task sequences. The AGV process flow template handles all task sequence generation for the attached AGV. Work Point Looping The AGV process flow directs the AGV to travel along a loop of \"work points\" which you have defined. The AGV decides what to do next at each work point. This loop is a set of control points that are connected together in a loop with the \"NextWorkPoint\" control point connection . Each of the work points is a place where the AGV will go to see if there is any item that needs to be picked up at that location. If there is no item to be picked up, then the AGV will continue to the next work point, and so on. The Basic AGV process flow is, as named, the most basic implementation of this looping behavior. The other process flows progressively add sophistication. Yet these additions are mainly to improve the set of choices that an AGV can make when at a work point. At their core, all the process flows do the same thing, that is: check if the AGV should do something at its current work point, and if not, move to the next work point, and repeat. Job Dispatching Job Dispatching Who or what will perform what jobs? AGV process flow handles dispatching. When using the AGV process flow template, job dispatching logic is handled by a combination of control points, the AGV process flow template, and a global list named AGVWork . This global list is automatically created whenever you use an AGV process flow template. When a fixed resource needs to request an AGV transport for a flow item, it will push the item to the AGVWork global list. Here, the item being pushed onto the list represents the \"job.\" The process flow template will immediately pull the job from the list, figure out where the item is, and push it back onto the AGVWork list, but this time partitioned by the work point associated with that item. Thus when AGVs arrive at these work points, they pull from that work point's partition to see what work is there. The image below shows the process flow logic of the Basic AGV , wherein the process flow pulls from the AGVWork list, figures out the correct work point, and then pushes the item back onto the list partition. With this work partitioning mechanism implemented, AGVs can query jobs by their location in the 3D model. This enables the work point looping explained above. The key thing to keep in mind is that job dispatching is mostly determined by the location of AGVs and items in the 3D simulation model. When an AGV arrives at a work point, it checks to see if there are any available tasks to work on, such as items to load. If there are things to do at that point, the AGV will take up those tasks. Otherwise it will move to the next work point. In Summary Dispatching Decisions Resource Selection The AGV process flow template does not do immediate resource selection. In other words, when a new job arrives (i.e. an item is pushed onto the AGVWork list), that job will not immediately be assigned to a resource. Instead it will wait for an AGV to come to its work point. Thus resource selection is determined by the first AGV to arrive at the work point. This means, in general, that the job will be picked up by the closest AGV to that job. This delayed resource selection can be beneficial because there may be an AGV that drops an item off near to the job location, but AFTER the job arrives. If the logic had immediately performed resource selection, the AGV would have been busy at the time, and it would have dispatched the job to a less-optimal AGV. Job Selection Job selection is performed when an AGV arrives at a work point. There it looks to see if there is any work to do at that location. This is performed by pulling from that work point's partion of the AGVWork list. You can define prioritization, filtering, etc. by customizing the pull query for the Is There an Item to Load Here? activity of the AGV process flow. If there aren't any available items to load at one of the work points, the AGV would simply move on to the next work point. Item Flows and Routing Item Flows and Routing Where do the items need to go? Mostly still up to you. Item flows and routing are still primarily handled by you. You can use fixed resources as you would use them normally, or you can define routing through your own process flow. In other words, the same methods that you would use to connect 3D object flows in a standard simulation model would apply when using the AGV process flow template. See Connecting 3D Object Flows for more information. The single difference with standard routing is that, once you have decided where you want a flow item to go, you need to push the item to the AGVWork list. Additionally, you should set a label named \"destination\" on the item that references the target destination. This can be done by using the Push to Item List (No Task Sequence) option in the Use Transport field. Connecting Fixed Resources to the AGV Network When using the AGV process flow template, you connect fixed resources to the network the same way as when using the AGV network normally. The only difference is that, once connected, you should make the connected control point part of the work point loop . Creating Work Point Loops As mentioned above , AGVs travel in a loop looking for transportation tasks to work on. To enable this, you need to create a work point loop in your AGV network. This is basically a series of control points that are connected to each other in a loop. To create a work point loop: Press and hold the A key to enter connection mode. When you are in connection mode, your mouse pointer will change to a plus sign with a chain link symbol next to it: Click the first upstream control point the AGV will pass over in the work point loop. You will notice as you move your mouse that a yellow line will appear between the object you clicked and your cursor. Pay Attention to the Connection Order The order in which you connect control points can affect how their logic works. In general, upstream control points should be clicked first. That's because an AGV will pass over the first control point and then it will send the AGV to the second control point. Hover over the second control point you want to connect so that it is highlighted. Click the control point to open a menu. Select NextWorkPoint . A red line will appear to show that the control points are now connected. Repeat this process to add more control points to the loop. Make sure that the last control point gets connected to the first control point to create a loop. Branching Work Point Loops You can also create work point loops that branch off from the main loop. Just make sure that the last control point in the side loop connects back to one of the control points in the main loop so that there is a path for the AGV network to both enter and exit the loop based on the work it finds. AGV Reset Point An AGV's reset control point (the control point you 'A' connect the AGV to) should be a point in the work point loop. Once you've built this loop, you can run the simulation model. The AGVs will loop around the system looking for work. AGV Process Flow Templates As mentioned previously, there are several different AGV process flow templates available. These include: Basic AGV AGV with Work Forwarding AGV with Basic Parking AGV with Heuristic Parking Advanced AGV While all process flows use the same core work point looping logic, each adds features to the previous one that give you more flexibility and power. Further, this progression from simple to complex allows you to choose a simplified launch point from which to add your own custom logic. In this section we describe each process flow template and the features it provides. Basic AGV The Basic AGV process flow is the most basic implementation of the work point looping mechanism. It implements a simple work partitioning mechanism as part of its Work Generation process. The AGV's looping logic is also as simple as possible: Check if there is an item to load at the current point. If there is an item to load at the current point, then load it, travel to its target destination, unload it, and repeat. If there is nothing to load, then travel to the next work point and repeat. Resolving the Next Work Point In resolving the next work point, and with other features explained later, the AGV process flow uses a useful feature of AGV control point connections. This feature causes the set of control point connections in your model to be represented as a partitioned list. Thus, to retrieve a connected control point or object, the process flow can simply pull from the current work point's partition of the associated list. Below is an example list associated with the NextWorkPoint connection. Each partition represents the owner of the connection(s), and the entries of that partition are the connections themselves. For example, in the list above, ControlPoint36 has a NextWorkPoint connection to ControlPoint9 . This feature makes querying control point connections as simple as pulling from a list, enabling easy access to control point connections from a process flow. Also of note in the figure above is that ControlPoint9 and ControlPoint10 each have two NextWorkPoint connections. This would represent a \"branch\" in the work point loop. Potential branching is the reason why the process flow first pulls an entry off of the list, then puts it back onto the list when it resolves the next work point. When the entry is placed back on the list, it is pushed at the end of that partition, meaning that work point will not be chosen when the next AGV arrives. This default behavior allows for a round-robin effect when there are branches in the work point loop. Obviously, you can also customize this as needed. AGV with Work Forwarding The AGV with Work Forwarding process flow implements the same functionality as Basic AGV , but adds a more sophisticated mechanism for defining where AGVs can find work. This is done by further customization of the work partitioning logic in the Work Generation process. This new logic is shown below. The logic uses the WorkForwarding control point connection to \"forward\" work from the item's location to one or more other work points. This allows the AGV to \"see\" whether there is available work at a location without actually having to travel to that location. Hence you can have fewer work points in your loop, while each work point is \"aware\" of more locations to load from. To enable work forwarding: Add the AGV with Work Forwarding process flow. Attach the AGVs in your model to the process flow (and remove them from any other AGV process flows). Add a WorkForwarding connection from the control point where an item is to be picked up to a work point in the work point loop. Below is an example of how you might configure a work forwarding situation. Work Forwarding is Optional By using the AGV with Work Forwarding process flow, you're not forced to use the WorkForwarding connection for every possible load location. If you don't use it, just make sure the load point is part of the work point loop. Pay attention to the direction. You may notice that the direction of the Work Forwarding connections is reversed from the directions of the other AGV Control Point connections, this is because Work Forwarding connections are drawn from the perspective of the item pushing work, rather than from the AGV. 0/1/More WorkForwarding Connections The process flow's new Work Forwarding process demonstrates that there are 3 different possibilities for work forwarding behavior. An item's location has 0 WorkForwarding connections. An item's location has 1 WorkForwarding connection. An item's location has more that 1 WorkForwarding connection. 0 WorkForwarding Connections When an item's location has no WorkForwarding connections, the logic works the same as it did in the Basic AGV . It assumes the item's location is the work point, and pushes to that partition. 1 WorkForwarding Connection When an item's location has 1 WorkForwarding connection, the logic substitues the single connected control point for the item's location, and pushes the item to that connected control point's partition. More than 1 WorkForwarding Connection When an item's location has more than one WorkForwarding connection, the logic will actually push the item to the list partition of all of the connected work points. Then, when an AGV at one of those work points assigns itself to the item, the process will abort all of the other list pushes, essentially removing the item from those partitions. This means that a job for transporting an item in your system can be \"visible\" from multiple work points in your loop. This gives incredible flexibility in defining when and where AGVs are assigned to which items. AGV with Basic Parking The AGV with Basic Parking process flow supplements AGV with Work Forwarding with two additional features: AGVs can park and wait for work to arrive at their current work point. AGVs can load more than one item at a time if you give them a Capacity greater than one. Basic Parking This process flow adds decision logic to the AGV's main control loop associated with parking. If the AGV can't find something to do, and it is empty, then it will check if there is an available ParkPoints connection. Again, it uses the list feature, wherein it pulls from a list partition associated with the ParkPoints connection. If it finds one, then the AGV will travel to that parking location, and wait until work arrives at that work point . To add parking functionality to your model: Add the AGV with Basic Parking process flow. Attach the AGVs in your model to the process flow (and remove them from any other AGV process flows). Add a ParkPoints connection from a work point in your loop to one or more control points where you would like AGVs to park. Below is an example of how you might connect parking locations. Some important things to note: An AGV will always go to an available park point if it is empty and doesn't find something to do at that work point. The AGV will wait for work to arrive at that work point . These implications mean that you need to be smart about designing your work point loop, the number of parking locations available at each work point, and how you define work forwarding. For example, if you have a single parking area that can hold all of your AGVs, then all work should be forwarded to at least the work point associated with that parking area. If not, then you could get into a situation where all of your AGVs are parked while none of them can see new work arriving, because those locations don't forward to the park area work point. Alternately, you can limit parking area capacity. For example, you can have single parking locations located near or at many different work points in your facility. The benefit of this is that you have AGVs that automatically distribute themselves to different parking locations, and are therefore close to the pickup locations when work arrives. The downside could be that, if you don't do liberal work forwarding, and you get a wave of jobs from the same location, you could have a single or just a few AGVs handling all of the work, while other AGVs are parked because they don't see that work. Whatever the benefits or downsides of your parking strategy, this process flow provides you with a simple launch point that supports parking. You can customize from here if needed. For example, you could improve the decision process for when an AGV should park, and how it is activated after it parks. Multi-Item Capacity The AGV with Basic Parking process flow also adds the ability to load multiple items at a time, when you change the AGVs' Capacity property to be greater than one. This change primarily adds more sophisticated Loading and Unloading processes. When an item is loaded, instead of immediately proceeding to unload it, the process will push the item to a Loaded Items internal list. If the AGV has more capacity to load another item, it will jump back into its main control loop, moving to the next work point, and so on. If, on the other hand, the AGV has reached its capacity, it will jump into the Unloading process. Here it finds the best item to unload by pulling from the local Loaded Items list, prioritizing the closest unload locations. Then it unloads at that location. The AGV will also do opportunistic unloading as part of its main control loop. When it arrives at a work point, if it finds that it has loaded an item that is destined for that work point, it will unload to that location. UnloadToEmpty The process flow also adds a process flow variable called UnloadToEmpty . It is a boolean value (1 or 0). If you set the value to 1, then when the AGV starts to unload it will continue unloading until it is empty. You can define this variable by clicking in a blank area of the process flow and defining the value in the Process Flow Variables pane in Properties. AGV with Heuristic Parking The AGV with Heuristic Parking process flow supplements AGV with Basic Parking with two additional features: It uses a heuristic to determine whether the AGV should park at a given location. It implements battery tracking, and will park and recharge if it gets below a user-defined threshold. Parking Heuristic The heuristic the process flow uses is to count up the total number of active items in the system, and compare it to the total active AGV capacity in the system. The number of active items is the number of items that have requested transport but have not yet been delivered. The active AGV capacity is the sum of all the item capacities of all of the currently active AGVs (AGVs that are not parked) in the system. When an AGV arrives at a work point that has parking locations, and does not find something else to do, it will compare the active items to the active AGV capacity . If the active AGV capacity , minus the AGV's capacity, is still greater than or equal to the number of active items, then the AGV can park. If it is less than the number of active items, then the AGV must stay active. The idea is that you want to generally keep enough AGVs active to handle all currently outstanding jobs. The process flow also uses the same heuristic in activating AGVs from being parked. When a new item arrives for transport, the process flow will check the number of active items against the active AGV capacity, and if AGV capacity is less than needed, it will attempt to activate a parked AGV. Battery Tracking This process flow also adds battery tracking. Here you define BatteryRechargeThreshold and BatteryResumeThreshold , in percent of battery capacity. When the AGV gets below BatteryRechargeThreshold , it will immediately find a parking location, park there, and recharge. Once it has reached BatteryResumeThreshold , it can then be made available for activation. Note that the battery tracking is primarily implemented as an example for you to customize. It assumes that all parking locations are recharge locations, which is likely not the case in a real life system. Advanced AGV The Advanced AGV supplements AGV with Heuristic Parking with two additional features: Enabling multiple dynamically chosen pickup locations at the same load location. Enabling multiple dynamically chosen dropoff locations at the same unload location. Pickup Points This process flow adjusts the Work Generation process to implement pickup points. When an item is pushed to the AGVWork list, the process, in addition to doing the standard partitioning logic, will also check to see if the item is at a location that contains one or more PickupPoints connections. If so, the process will find an available pickup point (one not already used by another item), and move the item into that control point. To add pickup point functionality to your model: Add the Advanced AGV process flow. Attach the AGVs in your model to the process flow (and remove them from any other AGV process flows). Add one or more PickupPoints connections from a work point in your loop to one or more control points where you would like items to be picked up from. Below is an example of how you might connect pickup points. Dropoff Points The process flow also adjusts the Unloading process. When an AGV begins to unload an item, it checks if the destination location has any DropoffPoints connections. If so, it will dynamically select an available dropoff point, travel to that point, and unload the item. Once it has unloaded the item, it will begin a Retrieval Process . The idea is that there would be some time between the AGV unloading the item, and the drop-off point becoming available again (somebody comes and removes it from the dropoff point, or it is automatically removed). By default, this is simply a delay time that you can define in the DropoffRetrievalTime process flow variable. However, you can customize this process as needed. To add dropoff point functionality to your model: Make sure you've added the Advanced AGV process flow. Attach the AGVs in your model to the process flow. Add one or more DropoffPoints connections from a destination control point to one or more control points where you would like AGVs to drop off items. Below is an example of how you might connect dropoff points. Types of Control Point Connections Control points are the basic building blocks of logic in an AGV network. However, the real logic of control points depends on the nature of its connections to other control points and 3D objects. Be aware that control points can connect to more than one object as needed and that you can customize control point behavior to meet your model's needs. Control points have the following possible connection types: Type Description Appearance Location Location control points are for connecting fixed resources to an AGV network. Once a fixed resource is connected to a location control point, it can send and receive flow items through the control point. Pick Up Points Pick up points can be connected to location points to create a specific point where AGVs can load flow items. The location control point will route flow items to those points when it receives them from an upstream fixed resource. Drop Off Points Drop off points can be connected to location points to create a specific point where AGVs can unload flow items. The location control point will route AGVs to drop off items at one of those points and then send it to a downstream fixed resource. Park Points Park points can be connected to a control point that has been set as the entry point for an AGV. When the simulation model starts, an AGV will be sent to this park point and the AGV will enter the network at this point. AGVs can also charge their batteries at park points when their batteries are running low. Work Forwarding Although seldom used, these kinds of connections can act as a kind of decision point where an AGV could decide where to go next to look for work. Imagine that you have a loop of control points that may or may not contain work for an AGV. If there is work to be done on this loop, the AGV should be routed to those control points. If there is not available work, the AGV should skip the loop and continue on in the AGV network. You would create look for work connections from the control points inside the loop that connect back to the upstream control point where the AGV will check for work. Be aware that these kinds of control points aren't necessary if you are using the AGV process flow template. Next Work Point You'll need to have a series of Next Work Points connections in your AGV network if you want to create a system in which AGVs loop around the system looking for work. These connections tell AGVs where their next destination should be if they are looking for work. When an AGV reaches the upstream control point, it will check for work at that control point. If there is no available work, it will travel to the downstream control point."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/WorkingWithTasks/AGVNetworks/AddingElevatorsAGVs/AddingElevatorsAGVs.html",
        "title": "Adding Elevators to AGV Networks",
        "content": "Introduction to Adding Elevators to AGV Networks Some AGV systems will require AGVs to use elevators to travel to multiple floors. In the following example, AGVs transport items to three different upper floors using elevators to move between floors: If you are simulating a business system in which AGVs will travel on elevators to multiple floors, you will need to complete the tasks explained in the rest of this topic. These tasks are presented in the suggested order in which you would need to complete them. Creating Multiple Floor Layouts The first step will create a layout with multiple floors. You can possibly create a model in which the floors are stacked on top of each other in the simulation model, as shown in the following image: You could alternatively just locate the upper floors in different sections of the model while still keeping them on the same plane as the ground floor, as shown in the following image: The stacked floor model has the advantage of looking a little more realistic. However, keeping the floors on the same plane has the advantage of being much easier to work with. You could also consider building the floors on the same plane to start and then moving the floors into a stacked position toward the end of the simulation project. See Creating Model Layouts for more information about working with multi-level simulation models. Types of Elevator Control Point Connections As was discussed in Building AGV Network Logic , control points are the basic building blocks of logic in an AGV network. AGV elevator systems use control points with the following possible connection types: Type Description Appearance Elevator Floor CP Elevator floor control points become the point where AGVs enter and exit the elevator on each floor. When an AGV passes over an elevator floor control point, it will appear inside the elevator. When an AGV exits an elevator, it will appear on the elevator floor control point. Elevator Redirect CP Elevator redirect control points handle requests for elevator transport. When an AGV passes over the redirect control point, it will attempt to acquire an elevator for transport. If one is available, it will then proceed on the path until it reaches an elevator floor control point. If an elevator is not available, it will wait at this control point until an elevator is free. Elevator Entry CP Elevator entry control points connect to elevator redirect control points. If an elevator is not available when an AGV passes over an upstream elevator control point, it can travel to the elevator entry control point to wait until the elevator is available. Adding Elevators and Dispatchers to 3D Models Elevators can be found under the Task Executer group in the Library. Add an elevator to your model using the same method that you would use to add any 3D object to a model. If you need to add multiple elevators to the same area, you will need to add a dispatcher as well: From the Library under the Task Executer group, add a Dispatcher to the elevator area. Create port connections (A-connects) going from the Dispatcher to each Elevator in the area. Setting up the AGV Elevator Process Flow Template At some point, you should add and set up the AGV Elevator process flow template: On the main toolbar, click the Process Flow button to open a menu. Point to Add a Task Executer Sub Flow and then select AGV Elevator . In the newly created process flow template, click a blank area to ensure nothing is selected. In Properties under the Process Flow Instances find the Attached Objects (instances) box. Click the Sampler button to enter sampling mode. In the 3D model, click each Elevator to attach it to the process flow template. Dispatchers Don't Need to Be Attached If you're using a dispatcher to control the elevators, you don't need to attach it to the process flow. You only need to attach the elevators. Adding and Connecting Elevator Control Points After you've got your floor plan and AGV network laid out and you've connected the elevators to the process flow, you'll need to add control points to direct the AGV to the elevator. Depending on your simulation model, you might need to set up three different types of control point connections in your AGV elevator system, as discussed in the following sections. Elevator Redirect Connections Elevator redirect control points handle requests for elevator transport. When an AGV passes over the redirect control point, it will attempt to acquire an elevator for transport. If one is available, it will then proceed on the path until it reaches an elevator floor control point. If an elevator is not available, it will wait at this control point until an elevator is free. To set up a redirect control point: Add a control point roughly near the entry point for the elevator area. Ideally, it should be the first control point the AGV will pass over when it enters the elevator area. Press and hold the A key to enter connection mode. When you are in connection mode, your mouse pointer will change to a plus sign with a chain link symbol next to it: Click the control point that you added in the earlier step. You will notice as you move your mouse that a yellow line will appear between the control point you clicked and your cursor. Click the elevator to which the AGV should be redirected to open a menu. Select ElevatorRedirectCP . A purple line will appear connecting the control point and the elevator. If There Are Multiple Elevators If you are using multiple elevators, you should connect the control point to the dispatcher, rather than the elevators. Don't forget to ensure the dispatcher is connected to the elevators as well. See Adding Elevators and Dispatchers to 3D Models for more information. If you are using a model in which the upper floors will be on the same plane as the ground floor, click the redirect control point on the upper floor to select it. In Properties, under the Labels group, click the Add button to open a menu. Select Add Number Label to add a new label. Name the label floorZ . Set the value as the z-height the elevator should raise to when sending an AGV to this floor. When the elevator sends an AGV to this floor, it will raise the elevator to the z-height you specified in this label. Elevator Floor Connections Elevator floor control points become the point where AGVs enter and exit the elevator on each floor. When an AGV passes over an elevator floor control point, it will appear inside the elevator. When an AGV exits an elevator, it will appear on the elevator floor control point. To set up an elevator floor connection: Add a control point to the area on the AGV network where the AGV should enter and exit the elevator. Press and hold the A key to enter connection mode. When you are in connection mode, your mouse pointer will change to a plus sign with a chain link symbol next to it: Click the control point that you added in the earlier step. You will notice as you move your mouse that a yellow line will appear between the control point you clicked and your cursor. Click the elevator to which the AGV should be redirected to open a menu. Select ElevatorFloorCP . An orange line will appear connecting the control point and the elevator. If There Are Multiple Elevators If you are using multiple elevators, you can either connect all elevators to the same control point or connect each elevator to its own control point. When deciding whether to use control points for each elevator, you should consider whether the distance traveled could affect statistics or whether the visuals might appear strange. The AGV will enter any elevator from its connected elevator floor control point and so it will function correctly either way. Dispatchers do not need to be connected to the elevator floor control points. Elevator Entry Connections Elevator entry connections are optional. If an elevator is not available when an AGV passes over an upstream elevator control point, it can travel to the elevator entry control point to wait until the elevator is available. To set up an elevator entry connection: Add a control point to the area where the AGV should wait for an elevator to be free. Press and hold the A key to enter connection mode. When you are in connection mode, your mouse pointer will change to a plus sign with a chain link symbol next to it: Click the control point that you added in the earlier step. You will notice as you move your mouse that a yellow line will appear between the control point you clicked and your cursor. Click the elevator floor control point to open a menu. Select ElevatorEntryCP . A yellow line will appear connecting the two control points. Creating AGV Paths to Additional Floors In finding travel routes between locations, the AGV network needs to be able to find a travel path from one floor to another. For that reason, you need to create a two-way AGV path that connects the AGV network on the ground floor to each of the AGV networks on the upper floors, as shown in the following image: Adding these paths enables the AGV network to route the AGVs to the different floors. However, the elevator process flow should redirect the AGVs to elevators before they actually travel on those paths. In order to do this, you must place a control point with an ElevatorRedirectCP connection somewhere in front of the path that connects floors, so that the elevator process flow can catch the AGV and redirect it. If the AGV does end up traveling on this path instead of using one of the elevators during a simulation run, it means that you haven't placed your ElevatorRedirect control points in the proper locations. The path needs to be two-way so that the AGV can navigate back and forth between the floors. You also need to make sure that the AGV will pass over an elevator redirect control point before it reaches the connecting path. Otherwise, the AGV will travel on the connecting path rather that using the elevator. You can probably avoid this problem by creating the connecting path from a point on the AGV network that is relatively close to the elevator's position in the 3D model. For example, in the following image, the AGV will pass over the redirect point and will be sent to the elevator before traveling on the connecting path:"
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/WorkingWithTasks/AGVNetworks/CustomizingAGVTravelTasks/CustomizingAGVTravelTasks.html",
        "title": "Customizing AGV Travel Tasks",
        "content": "Overview and Key Concepts Flexsim's AGV module gives you great flexibility in how to direct AGV travel operations. While AGVs primarily travel to Control Point destinations on the AGV path network, you can customize this functionality as needed. First, you can define an offset distance, along the path of the destination control point, that the AGV should travel to. Second, you can define an offset distance, along the AGV's \"train body\", that you want the AGV to travel to. This can be defined directly with an agv body offset distance, and/or by defining one of the AGV's trailers as the object \"relative to which\" the AGV should travel. All of this customization is done using some otherwise-unused parameters of the TASKTYPE_TRAVEL task, as explained below. If you are defining your task sequence logic in Process Flow, you can use the AGV Travel task sequence activity to define these custom parameters of a travel task. By using these two offset mechanisms, either separately or in combination, you can more easily simulate complex travel operations that require traveling to any point on the AGV path network, not just to control points. This is especially useful in simulating operations like train coupling and uncoupling in train yards. Defining Destination Path Offset When giving an AGV a travel task , you can define a target offset along the destination path. This offset is relative to the destination control point, and progresses along the path's primary direction . You define this offset through the travel task 's Var 2 parameter. Pass in the desired offset distance as a number, and the AGV will travel so that it arrives with its center location offset by that distance from the destination control point. If you are defining this through a process flow, you can use a AGV Travel activity. Defining Destination AGV Body Offset When giving an AGV a travel task , you can define a target offset along the AGV's \"train body\". This offset progresses forward along the AGV's train body, in that it represents a distance from the center of the agv, moving along any trailers that are attached to the AGV. A positive offset defines a target ahead of the AGV, whereas a negative offset defines a target behind the AGV. You define this offset through the travel task 's Var 3 parameter. Pass in the desired offset distance as a number, and the AGV will travel so that it arrives with this offset body location location at the target destination. You can also specify an enumerated AGV.BodyOffset for this value, and the AGV will automatically resolve the associated offset distance. If you are defining this through a process flow, you can use an AGV Travel activity. Defining the Destination Relative to a Trailer You can also define a travel destination \"relative to\" one of the AGV's trailers. This can technically already be done using the AGV Body Offset option, but defining a \"relative to\" object can bypass a potentially more complex body offset calculation. Further, the AGV Body Offset works in combination with the \"relative to\" trailer, so that you can use them both to, for example, travel to a target relative to the back or front of a given trailer, as opposed to its center. You define the \"relative to\" trailer through the travel task 's Involved 2 parameter. Pass in the target trailer object, and the AGV will travel so that it arrives with that trailer's center at the target destination (assuming 0 added AGV body offset distance). If you are defining this through a process flow, you can use a AGV Travel activity. In defining the \"relative to\" object it is helpful to be familiar with how you access an AGV's trailers. See the AGV interface reference for more information. Below are examples of defining the AGV body offset and \"relative to\" trailers. Deceleration and End Speed Usually when you give an AGV a task to travel to a destination, you want the AGV to end that travel task fully decelerated to a stop. However, in some cases you may want to end a travel task while still moving, for example if you want to make dispatching decisions on-the-fly. In this case you can define a non-zero end speed for the travel task. Doing this will actually shift earlier the end time of the travel task, as well as the position of the AGV at the time it finishes. In other words, instead of ending on the destination control point while still moving, the travel task will end while the AGV is still approaching the control point, at the defined end speed. If you don't immediately give the AGV any subsequent travel tasks, then the AGV will decelerate down to stopped, arriving at the control point AFTER the travel task has finished. If, however, you immediately give the AGV a new travel task, it will continue to the new task, starting at the end speed of the previous task, traveling through the original destination control point. The AGV system's default end speed behavior does not technically follow FlexSim's standard for TASKTYPE_TRAVEL tasks. FlexSim's standard travel task specification says an end speed of 0 means to end at the task executer's max speed. The reasoning is that travel tasks are often followed by offset tasks (load, unload). You don't want the task executer to decelerate to stop, then immediately start from 0 to do offset travel. So, the \"default\" end speed of 0 should mean that a travel task should end with the task executer still moving, since the task executer will continue to an offset task. In the AGV system, however, an end speed of 0 means an end speed of 0. This is inconsistent with the standard. This inconsistency between the AGV system and FlexSim's standard was generally not a problem, because in the initial versions of the AGV system, AGVs could not perform offset travel. Even now, AGVs do not perform offset travel by default. However, since AGVs do now include the ability to perform offset travel if you specifically add offset travel logic , the inconsistency is more apparent. To resolve this, you can check the Zero Travel End Speed Means Max Speed box in the AGV Network properties General tab. This will bring the AGV system inline with the standard travel mechanism."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/WorkingWithTasks/AGVNetworks/AddingOffsetTravel/AddingOffsetTravel.html",
        "title": "Adding AGV Offset Travel",
        "content": "Overview and Key Concepts The AGV system enables you to define custom offset travel operations. This is useful especially in warehousing situations, when AGVs may pick and place at many points along a rack. It may be tedious to place a control point at every possible pick/place location along the rack. Alternately, if a single rack represents the destination to place an item, even when you do define specific dropoff/pickup slots, the actual bay that an item should be placed in is not always chosen until the AGV arrives at the rack. The AGV system lets you dynamically determine offset destinations. As part of an offset travel operation, you can send the AGV to any point on the AGV path system, not just directly to control points. Setting Up Offset Travel To setup AGV offset travel: Make sure the AGVs you have connected to the AGV network, have their Travel Offsets setting set to Use navigator for offset travel . In the Toolbox , open the AGV Network properties window. Select the Triggers tab, then press the Add button and select On AGV Offset Travel from the drop-down menu. Sending to a Dynamic Location on the Path What you do next is dependent on how you want your AGV to perform the offset travel. If you want the AGV to travel to a dynamic location along the destination path (the \"Many Possible Locations\" scenario described above), then do the following: In the Triggers tab, under On AGV Offset Travel , press the Add button and choose Send AGV to Closest Point along Control Point Path . Click off of the popup, then press OK to close the AGV Network properties window. This will cause the AGV to travel to an offset distance along the destination control point's path. Sending to the Closest Control Point If you want the AGV to travel to the control point closest to the offset location (the \"Late Slot Assignment\" scenario described above), then do the following: In the Triggers tab, under On AGV Offset Travel , press the Add button and choose Send AGV to Closest Connected Control Point . Click off of the popup, then press OK to close the AGV Network properties window. In the 3D model, add DropoffPoints connections to the points that may be dropoff points, and add PickupPoints connections to the points that may be pickup points. If a point may be both, connect that point with both connection types. This will cause the AGV to travel to the connected control point that is closest to the target offset location. Configuring Travel End Speed When you first set up offset travel, you will notice that AGVs will decelerate to a stop at the destination control point before performing the offset travel operation. If you want them to end their initial travel task at full speed before continuing to offset, see Customizing AGV Travel Tasks > Deceleration and End Speed for more information."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/WorkingWithTasks/AGVNetworks/SimulatingTrains/SimulatingTrains.html",
        "title": "Simulating Trains",
        "content": "Overview and Concepts In addition to the ability to simulate high fidelity automated guided vehicle systems, FlexSim's AGV module also includes a capability to attach trailers to AGVs. When attached, trailers will travel behind (or in front of) their driver AGVs, and their motion will be articulated on the path of travel. Using this trailer attachment behavior, you to can represent the articulated motion necessary for modeling train yards, train travel networks, etc. While, in the context of train simulation, the term AGV is somewhat of a misnomer, nevertheless, the AGV system provides all the behavior you need to build sophicated train simulation models. The animation below shows a very simple example of an AGV that attaches to a trailer, moves the trailer to a different location on the network, and then detaches from that trailer. This topic will introduce the essential elements of the AGV system that you'll need to know to start building train simulation models. Drivers and Trailers In the AGV module, all objects that can travel on paths are separated into drivers and trailers . The driver AGV is the object that owns all of the information about where the AGV is on the path, how much of the path it takes up, and how many trailers are attached to it. A \"trailer\" is an object that is attached to the AGV driver, either behind or ahead of it. Each trailer will track the motion of the AGV that it is attached to. In other words, the AGV driver drives the motion of all of its trailers. AGV drivers are usually themselves task executers . In other words, you can treat an AGV driver like any task executer by giving it task sequences, etc. However, AGV drivers can subsequently become trailers to other AGV drivers. When an AGV becomes an attached trailer to another AGV driver, in can no longer execute task sequences. Instead, task sequences should be given to its driver. Non-task executer trailers can also be promoted to drivers, although perhaps the term owner is more appropriate here. This happens when one or more trailers is uncoupled from their driver AGV, and the uncoupled trailer is not a task executer. When a driver is not a task executer, it cannot be given task sequences. Instead, it only owns the information about where it is on the path system, and what trailers are attached to it. In order to make a non-task executer driver/owner move, you have to attach it to another AGV driver that is a task executer, then give that driver task sequences. Whenever an AGV driver is given a task sequence telling it to travel to a control point, by default it will travel so that the AGV driver's center arrives at the control point. Trailers ahead of the AGV will be pushed past the control point, and trailers behind it will stop short of the control point. Attaching, Detaching, Coupling, Uncoupling There are four different methods for controlling the makeup of an AGV train, namely attaching, detaching, coupling and uncoupling. A full reference for these methods is provided in the AGV API reference. This topic will merely give a synopsis of these different methods. You can easily add each of these functionalities in process flow, as follows: Add a Custom Code activity to your process flow. In the Custom Code activity's quick properties, press the Add button. In the drop-down, navigate to the menu Control > AGV . Select the desired functionality. Attaching a Trailer Attaching a trailer will attach an individual trailer to an AGV driver. It is used primarily to attach an off-network object (a flow item or other object that the AGV network was previously unaware of). You specify mainly whether to attach the object ahead of or behind the driver AGV, and the desired gap between it and the next-closest trailer/driver. See AGV.attachTrailer() for more information Detaching a Trailer Detaching a trailer will detach an individual trailer from an AGV driver. Once detached, the object is an \"off-network\" object. In other words, the AGV network will no longer track where that object is on the network. Detach a trailer (as opposed to uncoupling a train ) if you are about to destroy an object. See AGV.detachTrailer() for more information Coupling a Train Coupling a train is similar to attaching a trailer , with a few key differences. Coupling a train is meant to be much simpler for you as a user, with a lot of the more difficult work being handled behind the scenes. It takes a single parameter, namely a trailer to couple to. If the trailer is an \"off-network\" object (it is not another driver AGV or AGV trailer), then the functionality will forward to attaching a trailer, but will automatically calculate the gap and behind/ahead aspect, based on the position of the object relative to the AGV's current train. If the trailer is another AGV driver or trailer, then coupleTrain() will figure out where on the network that train is, and attach the entire train (the AGV driver and all of its trailers) to this AGV driver's set of trailers. The ahead/behind and gap variables will again be determined based on where the trailer is on the path compared to where the current AGV is on the path. See AGV.coupleTrain() for more information Uncoupling a Train Uncoupling a train is similar to detaching a trailer , with a few key differences. This functionality primarily takes a trailer . That trailer becomes the \"split point\" at which the AGV train should be uncoupled. Starting at that trailer and proceeding away from the AGV driver object, a new AGV train of trailers will be created. This train will become its own AGV driver. Note that, unlike detaching a trailer, here the AGV network will still keep track of where the new train is on the network. The trailer will become its own driver AGV. If this driver is a task executer, then you can give the new driver task sequences to move on the network. If you want the new \"driver\" AGV to be a different object than the trailer that is the detach point, then pass this object in as the optional New Driver parameter. See AGV.uncoupleTrain() for more information Overflowing As noted in the AGV Driver section, when an AGV is sent to a control point destination, if it has trailers ahead of it, it will push those trailers past the destination. In some cases you need to define how the pushed trailers should continue when they run off the end of their current path. You can define this using the AGV.overflowCP property. Before you send the train to its destination, set this property to a control point that is past the destination control point, and the pushed trailers will be routed toward that control point when they are pushed past the destination control point. Custom Destinations By default, an AGV will travel so that its center arrives at the target destination control point. However, you can customize this as needed. You can send the AGV to some offset along the destination path, and/or you can send one of the AGV's trailers to the destination, as well as many other possible configurations. See Customizing AGV Travel Tasks for more information"
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/WorkingWithTasks/AGVNetworks/Troubleshooting/Troubleshooting.html",
        "title": "Troubleshooting AGVs",
        "content": "This topic provides suggestions for troubleshooting common AGV problems. Navigation Errors Sometimes when you are working with AGVs you will get a navigation error that looks like the following: This error is caused because the task executer (TaskExecuter1 in the screenshot above) is at a location on the network that cannot reach the target destination. This may be caused by problems in the way you have defined your paths (one-way paths that should be two-way paths, etc.). However, sometimes, even when you've supposedly defined your paths properly, this error may still show up. Showing AGV Routing Accessibility When you get navigations errors, you can show routing accessibility information for control points in the AGV system. This lets you easily troubleshoot navigation errors. To do this: Find the destination control point that the task executer cannot find a path to. In the example screenshot above, this would be the control point connected to Source1 . Right-Click on that control point and choose Show AGV Routing Accessibility . Various path transfers will be highlighted in blue. These are points on the network that CAN reach the target control point. If a task executer cannot reach the control point, then the path transfers around it will not be blue. You can then follow the assumed path from that task executer to the destination. At the point where transfers change from black to blue, that is the point where there is some break in the path links such that the task executer cannot reach the destination. Getting Routing Table Information You can also hover the cursor over various control points and path transfers. This will show route cost information for traveling from the hovered point to the destination control point. Each line of the displayed text represents an entry in a routing table. The AGV system must calculate multiple of these routing tables because different situations may call for different routes. For example, an AGV's speed profile may be different when it is loaded versus when it is empty. Accordingly, if you have configured the AGV network to find the fastest route instead of the shortest route, then an AGV may travel a different route when it is empty versus when it is loaded. Each unique route must be calculated and stored independently. The AGV system will dynamically calculate, and cache, routes as they are needed in the simulation run. This means the number of route cost entries you see when you hover over a path point may grow as the simulation progresses. Each routing table entry displays a tuple key for that table, the calculated cost to travel to the destination, and a \"next rule\", which is a rule defining where to go next from this point to get to the destination. When you hover over a path transfer, it will also show, for each entry, the Path that the routing table entry is associated with. A path transfer actually has two \"sides\", so it will have two entries in the routing table: one determining where to go when an AGV is traveling on one path, and another for when the AGV is traveling on the other path. This is most important in looking at the rule information. A next rule means that, when on the given path, the AGV should continue on the path to get to the destination. When the rule is tnext , it means the AGV should transfer onto the other path to get to the destination. Refreshing Path Links In the course of building your model, sometimes AGV paths will lose, or not properly create, links to their neighbors. This can cause the navigation errors mentioned above. You can manually refresh these links through a path's right-click menu. Once you've found the point where navigation is blocked, you can right click on the path and refresh its path links. This will make the network re-analyze the geometry of that, and potentially other, paths, and will re-link the path with its neighbor paths, allowing the AGV system to properly routing AGVs to their destinations. Troubleshooting AGV Accumulation Behavior Many users will see the option for accumulation and think this is the perfect solution for what they want to do. The truth, however, is that using accumulation, while making many simulation scenarios easier, can also introduce new complexities and potential problems. This doesn't mean you shouldn't use accumulation. Most encountered problems are easily fixed with the right know-how. Rather, you should just make sure you have a good understanding of how accumulation works before deciding to use accumulation. First, generally you should not use accumulation for spur paths. These are paths where the AGV will enter, load or unload, then switch directions to exit on the same path that it entered. Accumulation doesn't really make sense in a spur because, if two AGVs must avoid each other inside a spur, you've probably already done something wrong by letting them both in. Instead of accumulation, you should implement other mutual exclusion mechanisms, e.g. using control areas or process flow, to only allow one AGV into the spur at a time. If you've implemented this one-at-a-time mutual exclusion, then accumulation is not needed anyway. Also, for two-way through paths, you must be careful in using accumulation. Again you must implement some additional method, either through control areas or process flow, to prevent AGVs going in opposite directions from getting onto the same path. Another complexity with using accumulation is that it creates a new allocation scheme, one that is different than, but will operate in tandem with, the standard allocation logic used for control points and control areas. Consequently, in some situations the two allocations schemes will \"fight\" with each other, and cause deadlock in the system. This is especially more probable in close-quarter intersection areas that use control areas to mutually exclude traffic. An example problem situation is shown in the following figure. In this situation, AGV_7 has allocated the intersection after the control area, but has yet to allocate the control area itself. This creates a serious problem because AGV_9, the other AGV at the bottom center of the screen, will allocate the control area first. Then the two AGVs will get into a deadlock because AGV_7 can't allocate the control area owned by AGV_9, and AGV_9 can't allocate the intersection owned by AGV_7. As mentioned before, this is caused because two different allocation schemes are in play here, namely the allocation of control areas vs. the allocation of intersections on accumulating paths. When allocating control areas, the AGV allocates when it pre-arrives at the previous control point. It will drive up to the closest control point, then allocate (in an all-or-nothing fashion) the next control point on its path, as well as all control areas on its path to that next control point. Thus the timing of when the AGV allocates the control area is based on the position of the control point leading up to the control area. Accumulating intersection allocation, on the other hand, is determined based on the position of the intersection and the settings of the associated Accumulation Type, defined in AGV network properties. In the situation shown above, AGV_7 would use the \"On Path Long\" setting, whose default says the AGV should be able to stop with its leading edge at least one meter short of the intersection if it can't allocate that intersection. This determines the point at which the AGV will attempt to allocate the intersection. In the example situation, AGV_7 allocates the intersection first because the control point is pretty close to the control area, so it reaches the point where it needs to allocate the intersection before it reaches the point where it needs to allocate the control area. On the other hand, AGV_9's control point is situated a little farther away from the control area, so it will allocate the control area before it allocates the intersection. This causes the deadlock. Solutions When encountering issues like this, there are two primary solutions you can try. First, you can create a special accumulation type that is specifically designed for close-quarter intersections. This accumulation type would ensure that control areas are always allocated before intersections. Here you would simply create a new accumulation type in the AGV network properties. Then for each intersection stop point, base it on the center of the AGV, with a distance of 0, meaning the AGV's center must stop 0 meters short of the intersection if the AGV can't allocate it. Once you've done that, make all the paths in that small area use that accumulation type. The second solution to try is to simply not use accumulation in those close-quarter areas. Just go to each path in the intersection and make its accumulation setting \"No Accumulation.\" This will make it so the control area is the sole mutually excluding element in the area. Then you don't have to worry about the right order of allocation. Here you'll want to make sure that the deallocation of the control area is not too early. You want the AGV to at least allocate the first intersection on an accumulating path ahead of it before it deallocates the control area. That shouldn't be too difficult. If it doesn't do it already, you can either lengthen the deallocation distance for that control area's deallocation type, or you can put down a control point at the beginning of the next accumulating path, then make the control area's deallocation type \"Deallocate at Next Control Point.\" As a general rule of thumb, accumulation works very well in areas of a model where there are long sections of path with relatively few intersections. On the other hand, in areas where there are lots of close-quarter intersections, it can be easier and less problematic to turn off accumulation, bound the areas with control points, and then limit traffic inside them with control areas."
    }
]