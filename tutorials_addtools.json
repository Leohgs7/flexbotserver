[
    {
        "url": "https://docs.flexsim.com/en/25.2/Tutorials/AdditionalTools/Tutorial1Conveyors/ConveyorsOverview/ConveyorsOverview.html",
        "title": "Tutorial 1 - Conveyors",
        "content": "This tutorial will give you a good introduction to some of the key features of the conveyor objects in FlexSim. You'll learn how to build conveyor systems that can sort, merge, build slugs, and how to create a power and free system. You'll also learn how to integrate your conveyor system with the Process Flow tool. Your Visuals Will Be Different Since the conveyor tutorials were first written, the conveyor visuals have changed. By default, conveyors are automatically rendered as roller conveyors. The screenshots will be updated in a future release of FlexSim, but everything other than the visuals will function normally. Tasks Covered This tutorial will cover the following tasks: Task 1.1 Sorting Systems In this task, you'll build a simulation model that uses three different methods to sort flow items: 1) conditional sorting, 2) destination-based sorting, and 3) sorting to downstream fixed resources. Task 1.2 Merging, Area Restriction, and Slug Building In this tutorial task, you'll add a merging lane and then later change the diverting lanes to build slugs of items that will be released once certain conditions are met. You'll also learn the different ways to use area restriction and merge controllers to control when flow items merge. In the last two steps, you'll learn how to reduce gapping in merging lanes. Task 1.3 Adding and Removing Gaps In this task, you'll learn a few tips and tricks for adding and removing gaps in your conveyor system. It will explain how to angle conveyors and how to use decision points with a merge controller to reduce gapping. It will also demonstrate how to use area restriction to add gaps and how to use the Process Flow tool to improve throughput. Task 1.4 Power and Free Systems In this task, you'll learn how to make your conveyor system look and function more like a power and free system. Power and free conveyor systems typically use a series of overhead trolleys that are propelled by dogs that continually move through the conveyor system. For More Information These tasks will cover the topics included in the chapter entitled Connecting 3D Object Flows ."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/Tutorials/AdditionalTools/Tutorial1Conveyors/1-1Sorting/1-1Sorting.html",
        "title": "Tutorial Task 1.1 - Sorting Systems",
        "content": "Task Overview In this task, you'll build a simulation model that uses three different methods to sort flow items: Conditional Sorting This simple conveyor sorting system will divert flow items based on a simple true or false condition. In this system 30% of the flow items will meet the condition and will be diverted to an alternate conveyor line. Destination-Based Sorting Next, you'll modify the first conveyor system so that flow items will be diverted to a particular conveyor line where the line's conveyor port ranking matches the flow item's type. Fixed Resource Sorting Lastly, you'll add a way to sort flow items to different downstream fixed resources based on the flow item's type. Step 1 Create a Conditional Sorting System In this step, you'll create a sorting conveyor system that diverts flow items to two different conveyors based on specific conditions. To create this system, you'll add a decision point to the main line conveyor and connect it to a decision point on the diverting conveyor. Then you will set the decision point's On Arrival trigger to send 30% of items to the decision point on the diverting line. To create this kind of sortation system: With the Library open, drag a Source into your 3D model. Create a Straight Conveyor extending horizontally from the Source . Open the Toolbox in the right pane. Double-click Conveyor System to open a properties window. In the General tab, clear the Draw Render Mode box. Click OK to save the changes and close the window. Why Turn Off Render Mode? For the purposes of this tutorial, you'll turn off render mode so that you can see the elements on the conveyor more clearly. Switch back to the Library in the right pane. Create a second Straight Conveyor that is perpendicular to the first. Drag the second conveyor until it snaps to connect with the first conveyor, forming a T shape. How Can You Tell They've Snapped Together? You'll know the conveyors have snapped together because you'll see a break in the edge of the first conveyor and a transfer between the two conveyors. (Transfers look like a small white box on the edge of both conveyors.) Drag a Sink from the Library and position it at the end of the first conveyor. Repeat this step for the second conveyor. Create port connections (A-connects) from the Source to the first conveyor and from the conveyors to their respective Sinks . Drag a Decision Point from the Library and place it on the first conveyor at the first junction on the conveyor where items could be diverted to different conveyor lines. Drag another Decision Point from the Library and place it at the beginning of the second conveyor line. This is the conveyor line to which you will divert 30% of the products. Make an input/output port connection ('A' connect) from the sending Decision Point on the first conveyor to the receiving Decision Point on the second conveyor. Click the sending decision point to highlight it. In the Properties window, expand the Triggers section. Click Add and select On Arrival . Click the Add button next to the On Arrival trigger and select Send Item from the menu. In the Send Item dialog box, delete what is in the Condition box and replace it with the following expression: bernoulli(30, 1, 0) . Leave the default settings in the Destination box for now. Click OK to apply the changes. How Will this Work? The Condition property needs to return a true or a false value (1 being true, false being 0). When it returns a true value, it will send the flow item to whatever is listed in the Destination property. Every time a flow item arrives on the decision point (causing the On Arrival trigger to fire), it will use the expression in the Condition property to determine where it should send the flow item. In this case, the bernoulli distribution will randomly return a value of 1 (true) approximately 30% of the time, and 0 (false) 70% of the time. When the value is 1 (true) it will send the flow item to the second decision point, which is connected to the output port of the first decision point. Click the Source to highlight it. In Properties under the Source section, click in the Inter-Arrival Time box to edit it. Type 2 . Run the simulation to test it. As the simulation runs, approximately 30% of the flow items should get diverted to the second conveyor: You can create different conditions that need to be satisfied in order for the items to get sent to the destination, such as a condition that checks the value of a label on a flow item. For example, the condition could be an expression such as item.Weight > 10 . This expression would check a label named Weight on the flow item. If the value of the label is greater than 10, the item will be sent to the specified destination. Step 2 Change it to a Destination-Based Sorting System In the previous step, you created a sorting system that was focused on whether a particular condition is met or not. In this step, you will modify the system's logic to send flow items to a conveyor that matches a value of the flow item's ProductType label. To create this logic, you will add some additional conveyors and connect the decision point on the main line conveyor to multiple decision points on diverting conveyors. Then you will set the source to randomly assign a value between 1 and 5 to a label called ProductType and assign each number a unique color. Then you will add the Send Item Behavior on the On Arrival trigger to the decision point on the main line. The Destination field on the Send Item Behavior will determine which lanes the items will be diverted to based on their item product type. Decision Point Can Be Any Distance for Routing The conveyor system has an automatic route-finding mechanism. In other words, the decision point to which you send an item can be anywhere in the conveyor system, as long as it's reachable from the item's current position. It will send the item using the shortest route to the destination. To create this kind of sortation system: Disconnect the two Sinks from the conveyor (press and hold the Q key as a shortcut). Click the second conveyor in your model. Copy (Ctrl+C) the conveyor and paste it (Ctrl+V) to make 4 copies of the conveyor. Snap the 4 copies to the first conveyor, spacing them equally. Feel free to resize the first conveyor to make it longer if needed. You can also use the Join Conveyor tool in the Library to connect the last conveyor if needed. Drag 3 more Sinks from the Library into the model and position each one at the end of a conveyor. Add port connections (A-connects) between each conveyor and each Sink . Drag 4 more Decision Points from the Library and position each one at the beginning of each conveyor except the last one. Add port connections (A-connects) from the first decision point to each of the new decision points. Pay Attention to Decision Point Rankings In this example, the order in which you connect the decision points matters because the rank of the output port connection will determine where the item is routed. Items with an item product type of 1 will be routed to the Output Port 1, and item with a product type of 2 will be routed to Output Port 2. See Port Rankings for more information. To view or change Output Port rankings, click on the first decision point, then in Properties expand the Ports section. Select Output Ports from the Ports menu. Re-rank the Output Ports if necessary. Also, if you need to know the name of each decision point, click on a decision point and view its name in Properties. By default, they are named DP1, DP2, etc. based on the order in which they were added to the model. Click the Source to highlight it. In Properties, under the Triggers section, click the Add button to open a menu. Select On Creation . Click the Add button next to the On Creation trigger to open a menu. Point to Data , then select Set Label . In the Set Label picklist options in the Label box type \"ProductType\" to assign a label named ProductType to flow items as they are created. In the Value box, type the statistical distribution duniform(1,5) to randomly assign the flow items a product type of 1 through 5. Now you'll add a second picklist option to the On Creation trigger. With the Set Label options still open, click the Add button at the bottom of this box to open a menu. Point to Visual , then Set Object Color . In the Set Object Color picklist options, in the Color box, type Color.byNumber(item.ProductType) to assign different item types a color based on the numeric value in the ProductType label. How Will this Work? This expression checks the number value of the label named ProductType on the item. It will then assign a color to the item based on its number value. Red is 1, green is 2, etc. Click on the first Decision Point to highlight it. In Properties, open the Triggers section. In the On Arrival trigger, click the Edit Properties button next to Send Item to open the picklist properties. Click the arrow next to the Condition box to open a menu and select Always . The box will now display true , which means that any item arriving at the decision point will always be sent. Click the arrow next to the Destination box type the expression current.outObjects[item.ProductType] , which means that it will send the item to a port based on the number listed in the ProductType label. How Will this Work? This expression checks the number value of the label named ProductType on the item. It will then send the item to the decision point with an output port number that matches its number value. Items with a ProductType of 1 will be routed to the decision point connected to output port 1, Type 2 will get routed to output port 2, etc. Items with a ProductType of 5 will continue down the rest of the conveyor without getting diverted. Run the simulation to test it. As the simulation runs, you'll notice that items are diverted down different conveyor lines based on their color (ProductType): Step 3 Add a Fixed Resource Sorting System In this step, you will add an additional sorting method that sorts flow items to downstream fixed resources based on their product type. You'll start by changing the source's properties so that it will create 6 different product types of items (instead of just 5). Then, you'll add two queues to the last conveyor line and connect a decision point that will send flow items to one of them. When sending items to multiple downstream fixed resources, you connect the decision point on the conveyor to exit transfers (rather than to other decision points). Items sent to an exit transfer will go to the object connected to that exit transfer. To create this sortation system: Click the Source to highlight it. In Properties, under the Triggers section, next to the On Creation box, click the Edit Properties button to open the picklist properties. Click the arrow next to the Set Label picklist to expand it. In the Value box, change the expression to duniform(1,6) so that it will create an additional item Type. Delete the Sink on the last conveyor. Drag two Queues from the Library and place them side by side at the end of the last conveyor. Create a port connection (A-connect) from the last conveyor to the first Queue . You should now see an exit transfer on the last conveyor with a port connection to the first queue. This time, when you create a second port connection (A-connect) from the last conveyor to the second Queue , make sure that you create the port connection in a position that is far away from the first exit transfer. You want to create two different exit transfers, one for each queue. Feel free to reposition the exit transfers if needed, but make sure that the second exit transfer is further down the conveyor line than the first one. Create a port connection (A-connect) from this conveyor's Decision Point to the exit transfer connected to the first queue. Click on the Decision Point on the last conveyor to highlight it. In the Properties window, expand the Triggers section. Click Add and select On Arrival . Click the Add button next to the On Arrival trigger and select Send Item from the menu. In the Condition box, write the expression item.ProductType == 5 to send items with a ProductType of 5 to the first output port. How Will this Work? This expression checks the number value of the label named ProductType on the item. If the ProductType is equal to 5 (which returns a true value), it will then send the item to the exit transfer connected to the output port. If it is not equal to five, it will send it on to the next downstream queue instead. The Send Item function on Decision Points requires strict connections. Therefore, to prevent routing errors, drag one more Decision Point and place it on the last conveyor so that there are now two decision points. Create a port connection (A-connect) from the first Decision Point on the main conveyor to the new Decision Point you just added. Run the simulation to test it. As the simulation runs, you'll notice that items with an ProductType of 5 or 6 are diverted two one of the queues based on their color (ProductType): Conclusion In the next tutorial task, you will learn how you can modify this system to merge conveyor lanes. Continue on to Tutorial Task 1.2 - Merging, Area Restriction, and Slug Building ."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/Tutorials/AdditionalTools/Tutorial1Conveyors/1-2Merging/1-2Merging.html",
        "title": "Tutorial Task 1.2 - Merging, Area Restriction, and Slug Building",
        "content": "Task Overview Merge conveyors can organize items flowing from multiple infeed conveyor lines. The most common purpose of merging is to combine items from multiple conveyor lines into a single line, which then sends the items downstream for further processing. In this tutorial task, you'll continue using the model you built in the previous task. You'll add a merging lane and then later change the diverting lanes to build slugs of items that will be released once certain conditions are met. You'll later add a merge controller that will make the conveyors release their slugs round robin. When you're finished, your model will function similar to the following image: Preventing Merge Jams When you run your simulation model, you might find that flow items on your conveyors occasionally get jammed. You can usually fix this problem by increasing the distance on the merging conveyor so that they have more room to merge. Step 1 Add a Merging Lane In this step, you'll change the 3D model layout to add a merging conveyor line: Using the model you created in the previous tutorial task, delete the following objects: The 2 queues at the end of the last conveyor The last conveyor (and the decision point on the last conveyor) The sinks at the end of each conveyor Make a copy of the horizontal conveyor and place the copy at the bottom of the diverting conveyors. Make sure the diverting conveyors snap together to the new conveyor. For clarity, rename the conveyors as follows: Conveyor New Name The horizontal conveyor at the top MainConveyor The horizontal conveyor at the bottom MergingConveyor First diverting conveyor Slug1 Second diverting conveyor Slug2 Third diverting conveyor Slug3 Fourth diverting conveyor Slug4 Slug-Building Conveyors From this point on, the tutorial will refer to these conveyors as the slug-building conveyors rather than the diverting conveyors. Add a Sink to the right end of the merging conveyor and create a port connection (A-connect) from the conveyor to the sink. Click the Source to highlight it. In Properties, under the Source section, change the Inter-Arrivaltime to 5 . Under the Triggers section, click the Edit Properties button next to the On Creation trigger. Click the arrow next to the Set Label picklist to open its properties. Change the Value box to duniform(1,4) so that it will only create four types of flow items. Go ahead and run the model now if you'd like to get a sense for how the system works before you've added the slug-building logic. Step 2 Add Simple Area Restriction You can possibly use area restriction to control the flow of items in a conveyor system. In this step, you'll restrict access to the merging conveyor so that only one flow item can enter the conveyor at a time. When to use Area Restriction Area restriction is a simplistic merging mechanism. It is often used in non-critical areas of a facility where optimizing throughput is not essential. Instead, the main goal is to prevent boxes from colliding and potentially getting knocked off the conveyor. In real conveyor systems, it often involves setting up simple photo eyes (or sensors) and controlling motors so that only one merging conveyor feeds the merge at a time. This kind of system prevents the collisions of items from different merging lanes. If optimizing throughput is important, you will want to use the merge controller mentioned later on in this tutorial. To create this logic, you'll create a decision point that uses a picklist option called Acquire Restricted Area on the On Arrival trigger. Using this logic, the decision point will request access to the merging conveyor (the restricted area) for every arriving flow item. If the requested area is not available, the decision point will hold the flow item until the area becomes available. You'll add decision points to the end of each slug-building conveyor (Slug1, Slug2, etc.) and copy this logic to them. Lastly, you'll add a decision point to the end of the merging conveyor. Once you connect this decision point to the other decision points, it will be able to control the restricted area. You'll add a picklist option Release Restricted Area to this decision point that will fire any time a flow item passes over it. It will send a message to the upstream decision points to release the next flow item in line. To create this logic: Drag 4 Decision Points from the Library and position them at the end of each slug-building conveyor (Slug1, Slug2, etc.). Make Sure the Decision Points Don't Overlap Make sure the decision points don't hang over the edge of the conveyor and overlap with a transfer or the merging conveyor. If the decision point is too close to the edge, it could detain items from the merging conveyor by accident. This would cause the conveyor system to back up because the flow item won't be able to release the restricted area. Ctrl click on all four of the new Decision Points to select them in red. Click one of the new Decision Points to select it in yellow. In the Triggers Properties panel, click the Add button to open a menu. Select On Arrival . Next to the On Arrival box, click the Add button to open a menu. Point to Area Restriction , then select Acquire Area . You'll use the default settings, so merely confirm that the settings match the following image: How Will This Work? The decision point will request access to the restricted area from the decision point that is connected to its first output port. The term current refers to the current decision point. The term outObjects accesses the object(s) connected to current object's output ports. The number [1] is the output port number. Drag one more Decision Point from the Library and position it at the end of the merging conveyor. Create port connections (A-connects) from the decision points on the slug-building conveyors to the decision point on the merging conveyor. Deselect all 4 decision points by holding shift and clicking on a blank space in the model. Click on the newly created Decision Point on the end of the merging conveyor to highlight it. In Properties, under the Triggers panel, click the Add button to open a menu. Select On Arrival . Next to the On Arrival box, click the Add button to open a menu. Point to Area Restriction , then select Release Area . You'll use the default settings, so merely confirm that the settings match the following image: Reset and run the simulation model. Notice that only one item can enter the merging conveyor at a time. Other Ways to Accomplish Area Restriction You might find that it is better to create an area restriction system by using the Process Flow tool instead. For example, a process flow could create a token for any flow item that arrives at an upstream decision point and attempt to acquire a resource (which will represent the merging conveyor). The downstream decision point could then signal the process flow that a flow item has passed over it and that it should release the resource. Using a process flow could help you have more control over how many flow items can enter the restricted area at a time. It could also allow you to build more sophisticated logic for determining which flow items should be released into the restricted area first. Step 3 Create a Slug-Building Conveyor Notice how in the simulation model you built in the previous step, items began to accumulate on some of the conveyors. Eventually, this accumulation of items would probably cause the conveyors to get backed up and jammed. Another solution to increase throughput is to use a merge controller to coordinate the merge. The merge controller explicitly builds slugs of target quantities in the merge lanes, and then releases them in a coordinated fashion. Slugs are a queue of accumulated items on a conveyor that will eventually be released downstream as a single group. Building slugs of items can maintain high rates of throughput while keeping equipment speeds as slow as possible. In FlexSim, you can design a conveyor that builds slugs and waits to release them based on a specific set of criteria such as: What percentage of the conveyor must be filled before a slug is ready for release The number of items that must be on a conveyor before a slug is ready for release The amount of time that must elapse in building the slug before a slug is ready for release In this step, you'll learn how to build and release slugs based on the number of accumulated items, but hopefully it will also be clear how to adapt this system to use one of the other slug-building methods. These conveyors will build slugs of at least four items. Once the slug has at least four items, the conveyor will release the slug to the merging conveyor. To create this slug-building system: Delete the 5 decision points you added in the previous step (the ones at the end of the slug-building conveyors and the merging conveyor). In the 3D model, click the Slug1 conveyor to select it. In Properties , in the Conveyor Behavior panel check the Slug Builder check box. Confirm that the Item Count check box is checked. Type 4 in the box next to it. Add a Slug Builder Property Table and copy these settings to all the other conveyors. Try running the model and notice that the conveyors will build a slug of 4 items before releasing them. Step 4 Add a Merge Controller You'll notice that sometimes slugs get released simultaneously. At this point the slug-building lanes are completely independent of each other. Each lane builds a slug and then immediately releases it. Consequently, released slugs will run into each other on the merge lane. This would not be ideal in a real system because the boxes would bump into each other and potentially get knocked off the conveyor. FlexSim does not implement the conveyor system using a physics engine that could bump items off a conveyor. Instead, boxes simply wait on the slug build lane until there is an available slot to enter the merge lane. Either way, this is not ideal. To get the simulation to work the way it should work in a real system, you need a merge controller to coordinate the releasing of slug lanes to avoid collision on the merge lane. In this step, you'll add a merge controller that will control how the slugs are released. For this example, you'll set the merge controller to use a strict round robin ordering system (slugs can only be released in a specific order, one after another). You'll need to add a decision point to the merging conveyor in order for the merge controller to work effectively. When a slug clears the decision point, it will tell the merge controller than the merging conveyor is ready to accept another slug. To add a merge controller to your conveyor system: Drag a Decision Point from the Library and place it near the end of the merging conveyor lane. Drag a Merge Controller from the Library and put it next to the end of the merging conveyor. Create a port connection (A-connect) from the Merge Controller to the decision point on the merging conveyor. Create additional port connections (A-connects) from the Merge Controller to each of the slug-building conveyors (Slug1, Slug2, etc.). Click the Merge Controller to highlight it. Under the Merge Controller section Click the arrow next to the Release Strategy box to open a menu. Select Round Robin . Depending on the order in which you connected the conveyors to the merge controller, you might need to reorganize the conveyors listed in the Lane Clear Table so that it will merge the Slug4 lane first, then the Slug3 lane, etc. (You might also need to expand the column sizes so that you can read the full conveyor names.) To change the release order, right-click the lane you want to move and select the appropriate movement form the table. Use the Lane Clear Table to Prevent Merge Jams In the Merge Controller's Properties, the Edit Lane Clear Tables button will bring up the Lane Clear Table The primary purpose of the Lane Clear Table is to prevent merge jams and shorten the gaps between slug releases. In this step, you're using it to control the round robin order, which is an alternate use for the Lane Clear table. Run the simulation. Notice that the fourth lane will get released first, then the third lane, and so forth. Even if a lane is ready for release, it will need to wait for its turn in the round robin schedule. Conclusion Now that you've learned some of the techniques for creating effective merging conveyor systems, you'll learn how to add and remove gaps in between flow items in a conveyor system. Gapping will be covered in the next tutorial. Continue on to Tutorial Task 1.3 - Adding and Removing Gaps ."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/Tutorials/AdditionalTools/Tutorial1Conveyors/1-3AddingGaps/1-3AddingGaps.html",
        "title": "Tutorial Task 1.3 - Adding and Removing Gaps",
        "content": "Task Overview This tutorial task will demonstrate several methods to both add and remove gaps in between flow items on conveyors. Using Inline Transfers to Remove Gapping In the first step, you'll see how changing the angle of the merging conveyor can remove the gapping in between flow items. Adding Additional Decision Points to Remove Gapping In the second step, you'll add additional decision points to help the merge controller increase the rate between slug releases. Using Area Restriction to Add Fixed Gapping In the third step, you'll learn how to use the pre-programmed Area Restriction picklist to add gaps in between flow items. Using Area Restriction to Add Variable Gapping In the last step, you'll use Area Restriction to add gaps in between flow items based on the size of the flow item. Step 1 Remove the Gaps Between Items in a Slug Usually the primary reason why you want a slug-building conveyor system is to reduce gaps between flow items, which increases your system's overall throughput. In the model you built in the previous tutorial task, you may have noticed that a small gap appears between each flow item as slugs move onto the merging conveyor during a simulation run. These gaps could reduce the throughput of the system and you might want to try to eliminate them. In this step, you'll change the 3D layout of the conveyor system so that the merging conveyor is at an angle. You'll learn how to use the Join Conveyors tool to make this process easier. One thing to be aware of is that even when you change the angles of the merging conveyors in your simulation model, your conveyors might still put small gaps in between the flow items. In this case, it could be caused by your angle settings on the transfer objects connecting the two conveyors. Your angle settings will determine whether FlexSim treats a transfer like a side transfer or an inline transfer. See Working With Transfer Objects for more information. In order to prevent possible problems, you'll also create a new global transfer type that increases the Max Angle property in this step. This property increases the threshold for which transfers are treated as inline transfers. This last step isn't necessary but is useful to be aware of when troubleshooting your own merging conveyor systems. To create this conveyor system: Click the merging conveyor to select it. Move the conveyor head (the right end) so that the conveyor is roughly at a 60 degree angle. Reposition the ends of the slug-building conveyors so that they nearly touch the merging conveyor. You might also want to reposition the sink and the decision point on the merging conveyor. Click the Join Conveyors tool in the Library to enter joining mode. Click the first slug-building conveyor and then click the merging conveyor lane (slightly to the right of the first conveyor) to create a curved connection between the two conveyors. Repeat this step for each slug-building conveyor. Ensure There is Adequate Spacing Make sure there is enough space in between the merge points for slugs to completely pass through. You might need to space the conveyors a little further apart in order to prevent jams. Open the Toolbox. Click the Add button to open a menu. Point to Conveyor System , then click Transfer Type to open the transfer properties window. In the name box at the top, change the transfer type name to SlugTransfer . The Following Steps Are Optional The following steps are optional. They demonstrate how to change the maximum angle of a transfer, which sometimes causes gapping problems. These steps are here merely to teach you how to troubleshoot a common gapping issue in your future conveyor projects. In the Max Angle box, type 60 to increase the angle. Press the OK button to save the changes. Notice that the SlugTransfer type now shows up in the Toolbox (under Conveyor System, then Transfer Types). Click the transfer between the diverting conveyor and the merging conveyor to highlight it. In Properties, click the Transfer Type menu and select SlugTransfer . Repeat steps 9-10 for each diverting conveyor. Run the simulation model. Now the flow items should smoothly transfer without any gapping. Step 2 Increase the Rate at Which Slugs Are Released At this point in the simulation model, there are still fairly large gaps between the various slugs as they merge onto the conveyor. In this step, you'll learn a few tricks to increase the rate at which slugs are released by reducing the gapping even more. One of the ways you can increase the rate at which slugs released is to increase the number of decision points on the conveyor and connect them to the merge controller. Increasing the decision points gives the system more sensors to gauge where slugs are on the merging conveyor line and whether there is enough room to release a slug. The merge controller will then be able to release slugs more frequently. You'll also use the round robin if available strategy to increase the rate at which slugs are released. To increase the rate at which slugs are released: Drag out 3 Decision Points and add one beside every exit transfer on the merging line. For clarity, rename the decision points on the merging conveyor as follows: Decision Point New Name The decision point closest to the end of Slug1 Point1 The decision point closest to the end of Slug2 Point2 The decision point closest to the end of Slug3 Point3 The decision point closest to the end of Slug4 Point4 Create a port connection (A-connect) from the Merge Controller to each new Decision Point . You Might Need to Disconnect and Reconnnect Point4 In order to get the merge controller to refresh the names in the table, you might need to disconnect and reconnect it from Point4. Click the Merge Controller to highlight it. In Properties under the Merge Controller tab, click the arrow next to the Release Strategy and select Round Robin If Available . Also Check the Lane Clear Table The Lane Clear Table (accessed by clicking the Edit Lane Clear Tables button in Properties) should have automatically updated to include the new decision points. Notice each one should now have their own row on the table. Slug4 should only require the last decision point (Point4) to be clear before these slugs are released, Slug3 should require the last two decision points to be clear, and so forth. Click the Source to highlight it. In Properties, under the Source section, change the Inter-Arrivaltime to 2.5 . Run the simulation model. The slugs should now release slightly faster than they did before, reducing the gap between items. Also, now your throughput has nearly doubled. Step 3 Add Gaps Between Items After the Merge Now that the items have been sorted by their product type and merged onto a single conveyor, you'll add some gapping to the merging conveyor line so that the flow items have standardized spaces in between them. In this step, you'll create a conveyor at the end of the merging conveyor. Then, you'll add two photo eyes to the gapping conveyor. On each photo eye, you'll use the Area Restriction picklist options to add a gap in between flow items that is equivalent to the gap between the photo eyes. To create this gapping logic: Disconnect (press and hold the Q key) the Sink from the merging conveyor. Add a straight conveyor running perpendicular from end of the merging conveyor. Make it fairly long in length. For clarity, rename this conveyor GappingConveyor . Use the Join Conveyor tool to connect the merging conveyor to the gapping conveyor. Move the Sink to the end of the gapping conveyor and connect it to the conveyor using an input/output connection (A-connect). Drag 2 photo eyes from the Library and position them near each other in the middle of the conveyor. Pay Attention to the Distance Between Photo Eyes The distance between the photo eyes will determine the length of the gap between the flow items. Create a port connection (A-connect) between the two photos eyes. Click the upstream photo eye to highlight it. In Properties, under the Photo Eye section, clear the Require Gap to Clear checkbox. In the Triggers section, click the Add button to open a menu. Select On Block . Next to the On Block trigger, click the Add button to open a menu. Point to Area Restriction and select Acquire Area . You'll use the default settings, so merely confirm that the settings match the following image: Click off of the popup to apply and save the changes. Click the downstream photo eye to highlight it. In the Triggers section, click the Add button to open a menu. Select On Clear . Next to the On Clear trigger, click the Add button to open a menu. Point to Area Restriction and select Release Area . You'll use the default settings, so merely confirm that the settings match the following image: Click off of the popup to apply and save the changes. Reset and run the simulation model. The photo eyes should add a small gap between the flow items. Step 4 Add Variable Gapping Imagine you wanted to add gaps of varying size in between items. For example, imagine that rather than having a fixed item gap, the size of the gap was determined by the size of the flow item instead. This step will demonstrate how to add that kind of variability to the gapping. You'll start by setting the source to create flow items with variable sizes. Then, you'll remove one of the photo eyes, and set the remaining photo eye to use both the Acquire Area and Restricted Area picklist options. You'll set the delay time on the release area picklist to base the time on the x-size of the flow item. To create this variable gapping logic: Click the Source to highlight it. In Properties, under the Triggers section, find the On Creation trigger you made previously. Next to the On Creation trigger, click the Edit Properties button to open the picklist properties. Click the Add button at the bottom of the properties window. Point to Visual , then select Set Rotation, Size, or Location . Click the Set menu and select Size . In the X Size box type uniform(0.2,1) . Type the same thing in the Y Size and Z Size box. Right now you have two photo eyes on your gapping conveyor. Delete the second one (the downstream one). Click the remaining photo eye to highlight it. In Properties, find the Triggers section. Next to the On Block trigger, confirm that this trigger is using the Acquire Restricted Area picklist option. Click the Edit Properties button to open the picklist properties. In the Area Owner box, type current . Then close the box to save the changes. Add an On Clear trigger. Next to the new trigger, click the Add button to open a menu. Point to Area Restriction , then select Release Area . Click the arrow next to the Delay Time box to open a menu. Select Time to Convey Item X Size from the menu. Reset and run the simulation model. The items with smaller widths will have smaller gaps than items with larger widths. Step 5 Control the Merge With Process Flow In this step, you'll use a template in the Process Flow tool to reduce gapping and improve the overall throughput in the system. Process Flow templates are pre-built process flows that act as a starting point for creating your own custom logic for 3D objects. These templates are self-documented, which means that each template includes detailed, step-by-step explanations of how the logic works. You can use the default logic in the template or modify the template to make your own custom logic. In this step, you'll learn how to link a merge controller to a merge controller process flow. When you first open the merge controller process flow, you'll see a section titled How-To . This section gives instructions about how to link a merge controller to the template. This tutorial will skip some of the processes listed in the template's description (because you've already done them) and will do some of the steps out of order, but the basic process will be roughly the same. First, you'll attach the merge controller to the process flow. Then, you'll set the target gap between slug lanes in the template's process flow variables. (See Process Flow Variables for more information.) To create this process flow: On the main toolbar, click the Process Flow button to open a menu. Point to Add an Object Process Flow , then select Gap-Optimizing Merge Controller . Click a blank area of the process flow to ensure nothing is selected. In Properties in the Process Flow Instances group, find the Attached Objects (instances) property. Click the Sampler button to enter sampling mode. Click the Merge Controller in the 3D model to sample it. It should now be listed as one of the attached objects in the process flow. In Properties under the Process Flow Variables group, find the Target Merge Gap box. Change the target gap to 0.75 . In the 3D model, delete the photo eye on the gapping conveyor. Delete the following decision points on the merging conveyor: Point1 Point2 Point3 Click the Merge Controller to highlight it. In Properties, under the Merge Controller section, in the Release Strategy box, delete all text and type 0 . Click on the Source to bring up its Properties on the right. Under the Source section, change the Inter-Arrivaltime to 1.5 . Reset and run the simulation model. Now the gap between slug releases is even smaller, increasing the system's throughput even more: Conclusion Now that you've learned some of the techniques for adding and removing gaps from conveyor systems, it's time to move onto working with other kinds of systems. In the next tutorial task, you'll learn how to create power and free conveyor systems. Continue on to Tutorial Task 1.4 - Power and Free Systems ."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/Tutorials/AdditionalTools/Tutorial1Conveyors/1-4PowerAndFree/1-4PowerAndFree.html",
        "title": "Tutorial Task 1.4 - Power and Free Systems",
        "content": "Task Overview In this tutorial task, you'll convert the simulation model into a power and free conveyor system. Power and free conveyor systems typically use a series of overhead trolleys that are propelled by dogs that continually move through the conveyor system. They are ideal for moving any type of load over large distances, differing elevation levels, and complex paths. In this task, you'll learn how to make your conveyor system look and function more like a power and free system. When you're finished, your final simulation model should look similar to the following image: Cautions About Simulating Power and Free Systems The simulation you build in this lesson will not explicitly simulate the carriers in a power and free system. Carriers are the objects that latch onto the dogs of the power and free chain. Usually there are a fixed number of carriers in a system, and they loop around within it. The items that need to be moved in the system are loaded onto available carriers, which then take them to their desired destination. Admittedly, not simulating the carriers in a power and free system can be justifiably considered a critical oversimplification. Varying the total number of carriers in a system, and their proper distribution, can have huge impacts on overall throughput. However, since the purpose of this tutorial is just to learn how to use FlexSim's power and free features, carriers will be left out. This simulation model will assume that carriers are available to pick up items when they are needed. In FlexSim, enabling power and free operation for a given conveyor or conveyors essentially causes them to enforce fixed interval movement. This means that items will only move at points on the conveyor where simulated dogs are located. If you want to simulate carriers, simply make the items that are moved directly into the conveyor system be the carriers. Create a fixed number that enter when the simulation starts, and then loop them around the system. Then move other items (the \"loads\") into and out of those carriers at various points in the system, simulating the actual movement of value-added material through the system. Step 1 Update the 3D Model Power and free conveyor systems usually suspend large items from the underside of the conveyor. For that reason, you'll raise the height of the entire conveyor system in this step. You'll also remove the merge controller and add the conveyor motor object to the model. One of the advantages of power and free conveyor systems is they can usually be controlled with a single motor, so this single motor will power all the conveyors. To make these changes to the 3D model: In the Toolbox, under the Process Flow group, right-click the Gap-Optimizing Merge Controller process flow to open a menu. Select Delete to delete the process flow. In the 3D model, delete the following objects: The merge controller The gapping conveyor The join conveyor that connected the merging conveyor to the gapping conveyor The decision point on the merging conveyor Move the sink up near the end of the merging conveyor. Reconnect the merging conveyor with the sink (A-connect from the merging conveyor to the sink). Add four Decision Points to the center of each slug-building conveyor. Click any conveyor to select it. In Properties, change the Z property (which affects the height) to 2.00 for both the Start and End of the conveyor. You can also just change the Z of the Location which will change both Start and End values at the same time. Repeat the previous step for all the conveyors in the model. Isn't There a Shortcut for This? There are shortcuts that enable you to quickly import properties from one 3D object to another. See Copying Properties to Multiple Objects for some shortcuts. However, it is probably better in this case to do each conveyor manually in order to prevent problems with the height alignment of the decision points on the conveyors. In the Library under Conveyors , drag a Motor to the model and place it anywhere. Create port connections (A-connects) from the Motor to every conveyor in the system, including the four curved conveyors. A fast way to do this would be to press Ctrl+click on each Conveyor to select them in red. Once they're all selected, make one A-connection from any selected conveyor to the Motor . This will create a connection for every selected conveyor to the Motor . To deselect the conveyors, simply press Shift+click in a blank space on the 3D model. When you're finished, your model should look approximately like the following image: Step 2 Update the Decision Points In this simulation model, you want to divert the flow items to a specific conveyor for painting. Each flow item will be painted a specific color based on its item type. Since the conveyor already sends items to a specific conveyor based on the value of the ProductType label, you don't need to program that logic. Instead, you'll set the decision points in the middle of each conveyor to delay the item for 10 simulation seconds. At the end of this time, the flow item will change color, representing its paint job. Aren't the Flow Items Already Assigned a Color? Currently the source assigns each flow item a color based on its ProductType label when it first creates the flow item. You'll remove the color functionality in a later step so that each flow item begins the same color until it is painted. Press Ctrl+click to select each of the 4 Decision Points on the Slugs. In Properties, under the Triggers group, click the Add button to add an On Arrival trigger. next to the On Arrival box, click the Add button to open a menu. Point to Stop/Resume , then Stop Item and Delay . With the Stop Item and Delay picklist options open, in the Delay box type 10 . In the Triggers group, click the Add button to open a menu. Select On Continue . Next to the On Continue box, click the Add button to open a menu. Point to Visual , then Set Object Color . With the Set Object Color picklist options open, in the Color box type Color.byNumber(item.ProductType) . Press Shift+click in a blank space on the 3D model to deselect the Decision Points . Select each Decision Point to ensure it has the 2 triggers we added. Consider saving your simulation model. Step 3 Update the Conveyors Power and free conveyors usually have a thin width and occasionally are painted in bright colors. They also typically move at speeds that are slower than other conveyors because they tend to carry such heavy loads. In this step, you'll update all your conveyors so their properties match that of a power and free system. To update our conveyors: Press Ctrl+click each of the conveyors in the model to select them all. In Properties, in the Conveyor Behavior group, click in the Speed box and change it to 5.00 . Then click the m/s link next to this box to open two menus. Click the second menu and change it to meters per minute . Check the Fixed Interval Movement (Power and Free) checkbox. Leave the other settings at their default. On the Conveyor group, in the Width box, type 0.25 . Still in the Conveyor group, find the Visualization property. The drop-down box next to it should say RollerConveyor . Next to that, click the Edit Properties button to open the properties. Under the Side Skirt section, click on the Side Skirt Color drop down and select the orange color. Click the OK button and to close the window. When you're finished, your model should look approximately like the following image: Step 4 Change Flow Item Properties and Movement Most power and free conveyor systems are designed to carry heavy loads. In this step, you'll create a large flow item that will travel along the power and free conveyor system. Then you'll set the Source to add this type of flow item to the conveyor system. Since power and free systems tend to operate more slowly, you'll also set the source to release the flow items less frequently. Lastly, you'll set the first decision point on the conveyor to translate this new flow item. The word translate in this context means to change the position of the flow item relative to the conveyor. In this case, you'll set the decision point to translate the flow item so that it travels underneath the conveyor, which is typical for power and free systems. To make these modifications to the model: In the Toolbox, click the arrow next to the FlowItem Bin to expand the list of flow items. Double-click the Cylinder flow item to open it in the Flow Item Bin. In Properties, change the X-size to 1 . Change the Y-size and Z-size to 1 as well. Click the Model tab to return to the 3D Model. Click the Source to open its properties on the right. Under the Source section, open the FlowItem Class menu and select Cylinder . Check the Arrival at time 0 checkbox. In the Inter-arrival Time box, type 100 . Under the Triggers section, next to the On Creation trigger, click the Edit Properties button . Next to the Set Object Color , click the Remove button to delete this picklist. Do the same thing to remove Set Size so our objects stay the dimensions we set earlier. Click the first Decision Point on the first conveyor (the one closest to the source) to bring up its properties on the right. In Properties, under the Triggers group, next to the On Arrival trigger, click the Edit Properties button to open the picklist options. Underneath the Send Item box, click the Add button to open a menu. Point to Movement , then select Translate Item . In the Conveyor Up box, type -item.size.z . What Does This Expression Mean? This expression causes the conveyor to translate the item by its negative Z-size in the Conveyor Up direction, meaning down on the conveyor. In this particular case, the Z-size of all the flow items will be the same number; it will always be 1.00 since that's the Z-size you set for the cylinder in the FlowItem Bin in step 3. So, you could put -1 in this box instead. However, using this expression makes the system able to adapt to flow items with varying sizes if needed. Click the Translate menu and select Over Time . In the Time box, type 0 . Run the simulation model and watch as large flow items slowly travel along the power and free conveyor to a painting station based on their item type. Notice that lines move across each conveyor system in sync with the motor. These lines represent the movement of dogs throughout the power and free system. Most power and free conveyors move at slow speeds because of the heavy loads they transport. For that reason, be aware that the following image is shown at a faster simulation run speed: Conclusion This concludes the conveyor tutorial. For a deeper discussion of how to use conveyors in FlexSim, consider reading the chapter about conveyors entitled Connecting 3D Object Flows ."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/Tutorials/AdditionalTools/Tutorial2StatsCollector/StatsCollectorOverview/StatsCollectorOverview.html",
        "title": "Tutorial 2 - The Statistics Collector",
        "content": "This tutorial will provide an overview of the main features and capabilities of the Statistics Collector. You'll learn how to use the Statistics Collector to listen to events and set up data tables. You'll also learn how to create charts that can better visualize the data from the Statistics Collector. For each task in this tutorial, you will start by opening a pre-built model. This model is installed on your computer when you install FlexSim. From your computer's Documents folder, you can find the model in the FlexSim 2021 Projects/tutorials/FlexSim21.0 folder. The model is called StatisticsCollectorTutorialModel.fsm . Each of the tasks in this will teach you how to make a statistics collector table, as well as a chart that displays the data in that table. Tasks Covered This tutorial will cover the following tasks: Task 2.1 Build an Average Content Collector In this task, you'll get introduced to the basic features and functionality of statistics collectors. You'll specifically learn how to add events to a collector and how to set up a data table. You'll also learn how to link a statistics collector to a Bar chart to visualize the data it records during a simulation run. Task 2.2 Build an Output Collector In this task, you'll learn how to connect events to columns. You'll also learn about using an On Reset event to order rows in the table correctly. You'll also link that collector to a Table chart to display its data. Task 2.3 Build a Content vs Time Collector In this task, you'll learn how to finish rows, and how to record time in a statistics collector. You'll also link that collector to a time plot to display its data. Task 2.4 Build an Orders In Progress Collector In this task, you'll learn how to use additional labels on the data entity. You'll also link that collector to a table chart to display its data. Task 2.5 Build an Orders By Size Collector In this task, you'll learn how to use conditions on events, and how to sort new rows into the table. You'll also link that collector to a time plot to display its data. Task 2.6 Build a Pick Time By Type Collector In this task, you'll learn how to use row labels. You'll also link that collector to a box plot to display its data. Task 2.7 Build an Average Content By Type Collector In this task, you'll learn how to use Tracked Variables on row labels to calculate average values. You'll also link that collector to a bar chart to display its data. Task 2.8 Build a Content By Type Over Time Collector In this task, you'll learn how to use row labels to store data, even after finishing a row. You'll also link that collector to a time plot to display its data. Task 2.9 Build an Output By Hour By Type Collector In this task, you'll learn how to use timer events to create per-hour statistics. You'll also learn about the collector.getAllRowValues() method. You'll also link that collector to a time plot to display its data. For More Information These tasks will cover the topics included in the chapter entitled Getting Data from Your Model ."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/Tutorials/AdditionalTools/Tutorial2StatsCollector/2-1AverageContentCollector/2-1AverageContentCollector.html",
        "title": "Tutorial Task 2.1 - Build an Average Content Collector",
        "content": "Task Overview For this task, we will be using a model that came with your installation of FlexSim. You can find the model file in your Documents , in the FlexSim 2021 Projects/tutorials/FlexSim21.0 folder. This model is a simple packing and shipping facility. Orders for pallets of shipment come in. Operators then pack the pallets accordingly in each of the three stations, and then the pallets are shipped out. In this tutorial task, you'll get introduced to the basic setup of a statistics collector, and a basic look at some of the features in the Statistics Collector tool. When you are finished with the tutorial, you should have a custom statistics collector that will gather data in a table. You'll also learn how to link dashboard charts to a statistics collector's data table to visualize the data. Step 1 Opening and saving the model with a new name In this step, you'll open the model that serves as the starting point for all tasks in this tutorial. Then you'll save it with a new name in a different directory. In the main toolbar, click the open button to open the model open dialog. Navigate to your Documents folder, then to the FlexSim 2020 Projects folder. From there, navigate to the tutorials folder, then to the FlexSim20.1 folder. Open the model called StatisticsCollectorTutorialModel.fsm . In the main menu, open the File menu, and choose Save Model As... to open the model save dialog. Navigate to the FlexSim 2020 Projects folder in your Documents folder. Save the file as StatsCollectorTutorialModified.fsm . You only need to do this step once for all of the tasks in this tutorial. If you want to do the tutorials again, you can always save a new copy of the installed tutorial model. Step 2 Creating a Basic Statistics Collector In this step you'll create and setup a basic statistics collector. You'll be telling it what events to listen to, and what data to gather as a result. To set up the statistics collector: Click on the Toolbox tab on the left side of the screen. Click the button to bring up the picklist options, and add a new tool. Select the Statistics option, and then the Statistics Collector option to create a new statistics collector tool. This will automatically open the properties window for the newly created statistics collector. Click in the top field of the newly opened properties window, and type StationAvgContent In the open Event tab of the properties window click the button to open the picklist option to add a new event for the statistics collector to listen to. Select the Create an event on reset option . Events and Statistics Collector Tables Events are moments of activity in the model. It could be when an item enters or exits a queue, when an operator loads an item. Or even simply when the user resets the model. The Statistics Collector listens to events, to know when to collect data or build columns and rows for its table. Statistics Collectors are based upon tables of data, organized into rows and columns, it is from this collected data that we can build charts. Click the Name box, and type the name On Reset Make sure there is a space between On and Reset. If you name the event OnReset (without a space), the Statistics Collector will not function properly. Be sure to add a space between On and Reset. Click on the sampler tool next to the Row Value(s) box. Navigate to the 3D Model, and with the sampler tool selected, click on Station 1 , and select Station 1 option from the picklist. The Row Value(s) field should now read /Station1 . Click on the Columns tab in the properties window. Click the button and choose the Add Column option. Click on the name box and rename the column to be Station. Click on the arrow next to the Row Add Value box, point to IDs , and then choose the ID of Row Value option. Click the Apply button. If you reset the model, you can now right click on the StationAvgContent collector under the Statistics Collectors section in your Toolbox tab, and select the View Table option. You can now see the table is populated with a column and row Explanation Events All Statistics Collectors work by listening to events. This is how Statistics Collectors observe the model. When any of the events happen, the Statistics Collector will update its table somehow. In this case, you listened to the event that happens when the model is reset. Event Row Values When you specify which event to listen to, you must also specify a Row Value . When the event happens, it yields the specified row value. The statistics collector keeps an internal list of row values. If an event yields a row value that isn't on the list, then the statistics collector will add a new row to its table, and connect the row value to the new row. In this case, when the model is reset, the Station event yielded Station1 as a row value. Since there wasn't a row for that value, the statistics collector added a new row for that value. Column Row Add Value When the statistics collector adds a row, it looks at each column. If that column has a Row Add Value , then the statistics collector will record the Row Add Value in that column in the new row. In this case, the Station column record the ID of the row value. Recall that the row value is Station1, in the model. The data Entity When an event happens, the statistics collector creates an entity called data . The data entity records information about the event that you can reference when you update column values. In this task, you used data.rowValue , which references the Row Value for the event that happened. Statistics Collector IDs If you want to display an object in a statistics collector table, the best way is to use an ID. An ID is a number that is unique to the object. You can use the Display Format to show the object's path, instead of the number. When you picked the ID of Row Value option, the Display Format was set to Object for you. Why Use IDs? The main advantage of an ID is that you can control how much of the path of the object is displayed, without changing how much memory the table requires. This can be helpful if you are showing activities in multiple process flows, or objects within visual tools. It is a best practice to use the ID of an object, rather than using its name or path directly. Step 3 Getting the Average Content After following the steps below you will be able to see the table values for each of the stations average content. To add this functionality: In the stats collector properties window, under the Columns tab, click the button and choose the Add column option. Click on the Name box and rename the column to be AvgContent Click next to Update Timing and set it to When the value is acessed . Click on the arrow next to the Value box to bring up the picklist option, select the Object Statistics category, and the Statistics by Object option. This will bring up an options selection window. Click on the arrow next to the Object box, and select data.rowValue from the options. The Statistics field should be set on Content as the default, but if it isn’t select Content from the picklist. In the Type field, select Average from the picklist options. Click the Apply button. Reset and run the model. If you view the table of the statistics collector now, you should see the second column’s cell will be populated by the average content of Station 1 as the model runs. In the model the stations have already been put together into a Group. If you look under the Toolbox tab under the Groups category, you will see a group called Stations . To add the other stations onto the statistics collector do the following: In the statistics collector properties window, navigate to the Events tab. Be sure that the On Reset event is selected. Click the arrow next to the Row Value(s) to bring up the picklist option. Select the All Members of Group option , and choose the Stations group selection. It will look like this when you are finished: Now if you reset and run the model again, you can view the table and see the other stations listed as well. Explanation Column Update Timing In this step, you added a column, and set its update timing to Update when accessed . This update timing is good for values that change continuously, like the average content of an object. When you access or view a table with this kind of column in it, the statistics collector will make sure those values are up to date. The statistics collector assumes that all other columns are already up to date. Multiple Row Values in an Event In this step, you changed the On Reset event to yield an array of all the objects in the Stations group. When an event yields an array of values, the statistics collector will make sure there is a row for each value in the array. Step 4 Adding a Chart In this final task of the task, you will connect your StationAvgContent collector to a simple bar chart in a dashboard, to display the data that it's collecting. To do this: Click the Dashboards button at the top of the screen, and select the Add a Dashboard option. In the Properties on the right, click on the box Dashboard Name . Rename the Dashboard to be AverageStationContent . While the dashboard view is active, navigate to the library on the left. Find the option Bar Chart under the Base Chart Types category, and drag a bar chart into the dashboard window. This will create a new blank chart, and open its properties window Click on the Data Source field, and select the StationAvgContent collector from the options. Once selected you will now see that the Bar Title and Bar Label fields are active. Click the Bar Title field and select Station . Below in the Bar Columns area, make sure that the AvgContent box is checked, and that Stations is unchecked. Navigate to the Settings tab, and uncheck the Show Percentages . (We would like the chart to show the actual content value instead.) Now reset and run the model until there is content in each station. You will see that the Stations will now record the average content in the bar chart. In the next task we will use the statistics collector to find the output of each of the stations."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/Tutorials/AdditionalTools/Tutorial2StatsCollector/2-2StationOutputCollector/2-2StationOutputCollector.html",
        "title": "Tutorial Task 2.2 - Build an Output Collector",
        "content": "Task Overview In this tutorial you will create a Statistics Collector that record the output of the Stations. This tutorial is based on the same model that was used in the Tutorial 1 of this series. For information on how to load the model, please refer to that tutorial: Tutorial 2.1 - Step 1 After following this tutorial, you should have a new Statistic Collector and chart that looks like the following. Step 1 Setting up the Statistics Collector In this step you will create and setup a new statistics collector. To do this: Navigate to the Toolbox tab on the left side of the screen. Click the button to create a new tool. Go to the Statistics selection, and select the Statistics Collector option. It should open a new properties window for the new statistics collector. Click the top field of the properties window, and rename the statistics collector to StationOutput In the Events tab, click the sampler button, and then click on Station1 in the 3D view. Point to the Stations option, and then choose On Output Change . In the properties window, click the triangle next to the Row Value(s) and choose Event object (current) . Navigate to the Columns tab in the properties window and click the button to add a new column to the StationOutput collector’s table. Click on the Name box and rename the column to be Station . Next to the Row Add Value box select the arrow to open the picklist options. Select the IDs category and select the ID of Row Value option. Click on the button again to add a new column. Click on the Name box and rename this column to Output Click on the Row Add Value box, and type 0 . In this case we want the value for the Output to be 0 when the Row is added, but we will get the actual output of the station in the Event Value box. Click on the Event Value box and type data.newValue . This will use the label that was created on the On Output Change event parameters, which looks at what the new value for the event is when it fires. In this case, it is the station’s output. To make the Column/Event connection, Click on the Stations - On Output Change option in the Event/Column Connections field, and then check the Output box in the field where it says Specify which columns this event updates Finally we can click on the Storage Type field and select the Integer option. Click the Apply button. Reset and run the model. If you right click on the StationOutput collector object in your Toolbox tab, and select View Table , you will be able to see the statistic collector’s table update for each station. Explanation Listening to a Group The statistics collector can listen to a group of objects. If any of the objects in the group fire the event, the statistics collector will respond to that event. In this task, you listened to the On Output Change event of all the objects in the Stations group. This means that if any Station fires its On Output Change event, then the statistics collector will respond. Event Parameters When you listen to an object event, that event may have parameters. In this example, you listened to the On Output Change event, which has two parameters: the new and old values of the output statistic. These parameters are assigned as labels on the data entity. In this task, you used data.newValue in the value of the Output column. newValue is a parameter of the On Output Change event, and is assigned a label on the data object. Using current In the statistics collector, the keyword current refers to the object that fired the event. When any of the stations fire their On Output Change event, current will refer to the station that fired the event. Connecting Events and Columns You can connect an event to one or more columns. When the event fires and yields its row value, then the statistics collector will make sure there is a row for that value. Then, for each connected column, the statistics collector will record the Event Value for that column on the current row. In this task, you connected the On Output Change event to the Output column. When a station's output changes, the statistics collector will make sure there is a row for that station, and then it will write the new output value in the Output column. Storage Types The statistics collector allows you to control how much memory is required per column. In this task, you set the Storage Type to Integer. This means that the field will only be able to store integer values, but it will require less memory than a Double column. Step 2 Setting the Display Order of the Stations Right now, the statistics collector adds a row for each station when its output changes for the first time. This means the order of rows in the table depends on how the model runs. To fix this: Navigate again to the Statistic Collector’s properties window, and go to the Events tab. Click the button to add a new event, and select the Create an event on reset option. Click on the Name box and rename the event to Stations - On Reset Click on arrow next to the Row Value(s) box, then select the All Members of a Group option, and then select the Stations group. Click the Apply button. If you reset and run the model now, you can view the table and should now see that the StationOutput collector's table has ordered the stations correctly. Explanation When the Stations - On Reset event fires, it yields an array containing all objects in the Stations group. These objects are in the order shown in the Group properties window. Later, when the Stations - On Output Change event fires, there is already a row for the station, so the Statistics Collector doesn't add a new row. However, that event is connected to the Output column, so the Output column on the station's row is updated. Step 3 Adding a Table Chart to the Dashboard Next we will add a simple table chart to display the output in the dashboard. When finished the table should look something like this. To create the chart: Click the Dashboards button at the top of the screen, and select the Add a Dashboard option. In the Properties on the right, click on the box Dashboard Name . Rename the Dashboard to be StationOutput . While the Dashboard view is active, navigate to the library on the left. Find the option Table Chart under the Base Chart Types category, and drag a table chart into the dashboard window. This will create a new blank chart, and open its properties window In the properties window, click on the Data Source field, and select the StationOutput collector from the options. In the Include field, make sure the Station and the Output boxes are checked. Object Order In step two of this task we changed the order of the stations in the table. This order is reflected in the charts as well since the data is based off of the statistics collector table. You can try switching the order of objects in the Stations group to see how it affects the order in the table and charts. If you reset and run the model you can now see that the table chart will track the station output. You may need to run the model at a higher speed to see this happen. In the next task we will use the Statistics Collector to display the stations content over time."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/Tutorials/AdditionalTools/Tutorial2StatsCollector/2-3ContentVsTimeCollector/2-3ContentVsTimeCollector.html",
        "title": "Tutorial Task 2.3 - Content Over Time",
        "content": "Task Overview In this tutorial we will look at how to collect data from a Process Flow activity, and how to create a time plot. In this tutorial we will be creating a Statistic Collector that will collect data for the content of the Stations over time. This tutorial is based on the same model that was used in the Tutorial 1 of this series. For information on how to open the model, please refer to that tutorial: Statistics Tutorial 1 - Create a Basic Statistics Collector Step 1 Setting up the Statistics Collector In this step we will set up the statistics collector tool. To do this: Click on the Toolbox tab on the left of the screen and click the button to add a new tool. Navigate to the Statistics section and select Statistics Collector . This will open a properties window. Click on the field at the top and rename the statistics collector to ContentVsTime . For this tutorial we are going to look at an event from an activity in the Process Flow tool that operates the logic of this model. Make sure the Process Flow window is open. You can find it by clicking on the Process Flow button at the top of the screen, navigate to the General section, and select Process Flow . With the Process Flow window open, go back to the Statistics Collector properties window on the Events tab. Click on the Sampler button below the tab, then navigate to the Process Flow activity called Get Station . From the picklist that opens, select the option On Content Change . This activity is collecting tokens representing orders coming in and requesting a station to be packed in. By listening to the content change of tokens in this activity we are listening to the number of orders waiting to be packed. Click the triangle next to the Row Value(s) and choose Event object (current) . Finally, check the Finish involved rows after the event box. Click on the Columns tab. Click the button to add a new column to the ContentVsTime collector. In the Name field, rename this column to Time . Click the arrow next to the Row Add Value field select Time and then select Model Date/Time . Now click the button once again to add another column. In the Name field, rename this column to Content . In the Row Add Value field type data.newValue . Set the Storage Type property to Integer . Click the Apply button. You can right click on the ContentVsTime collector in your tools and select the View Table option. If you reset and run the model now, you will see the table populate as the content of the Get Station activity changes. You may have to run the model for some time to see the results. Explanation Finishing a Row In this task, you checked the Finish involved rows after this event box. This means that after the statistics collector has responded to the event (by possibly adding rows and/or updating columns), it will finish the row. Finishing the row means that the statistics collector will do three things: It will update any columns that update when they are accessed, It will disconnect the row in the table from the row value, and It will remove the row value from its list of row values. This means that each time the Get Station activity fires its On Content Change event, the statistics collector will add a new row for the activity, recording the Row Add Value for each column. Then it will finish the row, so that next time the event fires, the statistics collector will add a new row for the activitiy. Step 2 Creating a Chart Now you will create a chart to show the change in the activity’s content over time. To do this: Click the Dashboards button at the top of the screen and select the Add a Dashboard option. In the Properties on the right, click on the field Dashboard Name . Rename the Dashboard to be ContentVsTime . While the dashboard view is active, navigate to the library on the left. Under the Base Chart Types section, find and drag a Time Plot chart onto the dashboard. This will open the new chart’s properties window. Click on the Data Source field and select the ContentVsTime collector from the options. You will notice that the chart automatically will try to use the column values we created for the x and y axes of chart. We are going to leave the default values of Time as the X Values , and Content as the Y Values . If these fields did not set automatically make sure they are set accordingly now. Click on the Settings tab. Click on the Draw Style field and select the option Stair Step , instead of the default Points. Now click the Apply Button. If you reset and run the model now, you will be able to see the chart show a time plot of our ContentVsTime collector. As before you may have to run the model for some time to see the results. In the next task you will learn how to use a statistics collector to record the total content of many process flow activities."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/Tutorials/AdditionalTools/Tutorial2StatsCollector/2-4OrdersInProgress/2-4OrdersInProgress.html",
        "title": "Tutorial Task 2.4 - Orders In Progress",
        "content": "Task Overview This tutorial will look further in depth at how to use Process Flow activities and events to gather specific data. Specifically, you will be gathering data on the number of orders that are in progress in the model. This is like other “work in progress” measurements, or WIP, but this will primarily be looking at the orders themselves from the arrival of an order, to its fulfillment. You will be measuring this by looking at the number of tokens in each set of activities within Process Flow, which will use the statistics collector’s internal events to count and measure. This tutorial is based on the same model that was used in the Tutorial 1 of this series. For information on how to load the model, please refer to that tutorial: Statistics Tutorial 1 - Create a Basic Statistics Collector Step 1 Setting up the Statistics Collector To begin you must first create and set up the statistics collector. To do this: Click on the Toolbox tab on the left of the screen and click the button to add a new tool. Navigate to the Statistics section and select Statistics Collector . This will open a properties window. Click on the field at the top and rename the statistics collector to OrdersInProgress . Open the Process Flow view if it isn’t open already. (To do this, click on the Process Flow button at the top, and select the General directory and then select Process Flow .) Back in the statistics collector properties window, click on the Sampler button to sample for a new event. With the sampler active, navigate to the Process Flow window and click on the activity Get Station . From the menu that opens, select the On Entry event. Now do the same again do add another event: Click on the Sampler button, then navigate in the Process Flow window to the Sink activity at the end of the same the flow. Select the On Entry event once again. Click on the Get Station - On Entry event to select it, and then click on the button near the Additional Labels field. Select the option Add label for this event… In the nearby Name field, name the label Delta In the Value field type 1 . In the Row Value(s) field type 1 . This is simply a filler value, the value simply should not be empty because you want the statistics collector to record the row itself. Now click on the Sink - On Entry event. Click on the button near the Additional Labels field and select the option Add label for this event… In the Name field, name this label to Delta also. In the Value field type a -1 this time. Once again, in the Row Value(s) field type 1 . What are these labels? The statistics collector is going to measure now when tokens arrive in the first activity, which is when the order is in the system, and when the token leaves the same flow. The additional labels feature in the statistics collector allows you to record additional information at each event, in this case you’ll use the labels to keep track of the current number of tokens in progress. Now click on the Columns tab in the properties window. Click the button at the top to add a new column. In the Name field, name the column OrdersInProgress . In the Row Add Value field type 0 . (This is because you want the base value of the content to start at 0.) Then click on the arrow next to the Event Value field and select the Data category and the Increment Data Value option. This will bring up a new field sub window. In the Increment By field type data.Delta . (This means that the column value is going to be adding and subtracting 1 each time a token enters then leaves, because of the Delta label values that you set.) Click on the Storage Type field and select Integer , since for this collector you are dealing with whole numbers as the number of tokens in progress. Finally, you need to connect the events to the OrdersInProgress column. Click on each event in the Event/Column Connections field, and make sure that under the section that says Specify which columns this event updates that the OrdersInProgress checkbox is checked. Click the Apply button. Now if you view the table of the OrdersInProgress collector as the model runs, you will be able to see the OrdersInProgress column updating with the content of tokens in progress. (You can view the table by right clicking on the OrdersInProgress collector in your Toolbox tab and selecting the View Table option. You may notice that the table doesn’t populate until the first event fires. It remains blank until that first token goes through the first activity. If, however, you’d like the model to start the value at 0, perhaps for charting purposes, then you can add another event to the statistics collector to populate the table at 0 from the start. To do this: Open the OrdersInProgress collector’s properties window. In the Events tab click the button near the top. Select the option Create an event on reset . With the On Reset event selected, click on the Row Value(s) field and type 1. Click the Apply button Now if you reset and run the model, you will see that the OrdersInProgress value starts at 0 at the beginning of the model’s run time. Step 2 Creating a Chart Now you will chart the statistics collector table in the Dashboard with just a simple Table Chart. First, click the Dashboards button at the top of the screen and select the Add a Dashboard option. In the Properties on the right, click on the field Dashboard Name . Rename the dashboard to be OrdersInProgress . While the dashboard view is active, navigate to the library on the left. Under the Base Chart Types section, find and drag a Table Chart onto the dashboard. This will open the new chart’s properties window. Click on the Data Source field and select the OrdersInProgress collector from the options. Check the OrdersInProgress box in the Include section. Click the Apply Button. If you reset and run the model, you can now see the OrdersInProgress value increment and decrement as tokens come through the process. That is the conclusion to this tutorial, in the next tutorial you will learn to measure the number of orders in the model, each by the size of the pallet that is being packed."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/Tutorials/AdditionalTools/Tutorial2StatsCollector/2-5OrdersBySize/2-5OrdersBySize.html",
        "title": "Tutorial Task 2.5 - Orders By Size",
        "content": "Task Overview In this tutorial you will again use the statistics collector to gather statistics that would not be gathered in the default settings of the model. In this case, you will get statistics on the number of orders processed but broken out based on the number of items in each order. You’ll have statistics on the throughput of orders based on size. You will do this by utilizing labels from within the statistics collector events. This tutorial is based on the same model that was used in the Tutorial 1 of this series. For information on how to load the model, please refer to that tutorial: Statistics Tutorial 1 - Create a Basic Statistics Collector Step 1 Setting up the Statistics Collector To set up the statistics collector: Click on the Toolbox tab on the left of the screen and click the button to add a new tool. Navigate to the Statistics section and select Statistics Collector. This will open a properties window. Click on the field at the top and rename the statistics collector to OrdersBySize . Open the Process Flow view if it isn’t open already. (To do this, click on the Process Flow button at the top, and select the General directory and then select Process Flow .) One thing to note in the process flow is the Set Order Size activity. Here you can see that there is a label, OrderSize , being set on the order tokens. You will use this label in the statistics collector as part of the data. Back in the statistics collector properties window, click on the Sampler button to sample for a new event. With the sampler active, navigate to the Process Flow window and click on the Sink activity. From the menu that opens, select the On Entry event. In the Row Value(s) field type data.token.OrderSize . This will use the previously mentioned OrderSize label on the token and create a unique row for each different size of order that comes through. Additionally, imagine that you only want data on order sizes that are considered “small.” This is where you can use the Condition field to filter out some results from the Row Value. For the sake of this tutorial you are only looking for orders with a size of 4 or less. Click on the Condition field and type data.token.OrderSize <= 4 . Now click on the Columns tab, and click the button to create a new column. In the Name field, name this column OrderSize . In the Row Add Value field type data.rowValue . Click the Storage Type field and select the Integer option. Click the button to add another column. Name this column Output In the Row Add Value field type 0 . Because you want the Output value to start at 0 at the beginning. Click the arrow next to the Event Value field and select the Data option and the Increment Data Value option. In the sub window field that opens, the default increment value should be 1 , if it is not make sure it is 1 before closing it. In the Event/Column Connections field, select the Sink - On Entry event, then check the Output box in the field that says Specify which columns this event updates . Click on the Storage Type field and select the Integer option. Click the Apply Button. Now if you right-click on the OrdersBySize collector in the Toolbox and select the View Table option you can see the table for the collector. You should be able to now see the table populate with the data on output based on order size. You may have to speed up the model runtime to see the changes. You may notice that the table is not ordered. The first row that comes in will be based on the first order that enters the system. If you want to order the table by order size, you can use the Row Sorting feature in the statistics collector properties. To do this: In the statistics collector properties window, click on the Row Options tab. Click on the + button underneath Row Sorting . This will create a new field. By default the Sort By field should say data.rowValue , if it does not, enter that now. Click the Apply button. Once again if you reset and run the model, you should now see that statistics collector table will be sorted by order size now. Row Sorting It’s important to note that row sorting will only work with row values that are static and not dynamic within the model. Since Order Size is a categorical value and is not going to change the row during the run time, it would work as a sorting metric. However, the Output column values change, therefore they could cause potential issues when sorting. Step 2 Creating a Chart Now you will add a chart to chart the data collected by the OrdersBySize collector. To do this: First click the Dashboards button at the top of the screen and select the Add a Dashboard option. In the Properties on the right, click on the field Dashboard Name. Rename the dashboard to be OrdersBySize . While the dashboard view is active, navigate to the library on the left. Under the Base Chart Types section, find and drag a Bar Chart onto the dashboard. This will open the new chart’s properties window. Click on the Data Source field and select the OrdersBySize collector from the options. Click on the Data Format field and select the One bar per row option. Click on the Bar Color field and select OrderSize . Click on the Bar Size field and select Output Click on the Settings tab. Uncheck the Show Percentages box. Check the Show Zero Columns box. Click on the Text tab. Check the OrderSize box in the Show Column Headers field to make sure the OrderSize text is visible. Click the Apply button. Now if you reset and run the model you will be able to see the chart utilizing the OrderBySize collector’s data during the runtime of the model."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/Tutorials/AdditionalTools/Tutorial2StatsCollector/2-6PickTimeByType/2-6PickTimeByType.html",
        "title": "Tutorial Task 2.6 - Pick Time By Type",
        "content": "Task Overview In this task, you will create a Statistics Collector that records the time required for an operator to pick each item. A pick is the time it takes an operator to travel to an item, load it, and unload it at their station: This task is based on the same model that was used in the Task 1 of this series. For information on how to open the model, please refer to that task: Statistics Tutorial 1 - Create a Basic Statistics Collector Step 1 Add Events to the Statistics Collector In this step you will add events to the statistics collector. To do this: Click on the Toolbox tab on the left of the screen and click the button to add a new tool. Navigate to the Statistics section and select Statistics Collector . This will open a properties window. Click on the field at the top and rename the statistics collector to PickTimeByType . Be sure the ProcessFlow view is open, and that the Travel to Item and Unload Item activities are visible. On the Events tab, click the sampler button . Then click on the Travel to Item activity , and choose the On Entry option. In the Row Value(s) field, type the following code: data.token In the top left of the Events tab, click the sampler button . Then click on the Unload Item activity, and choose the On Exit option. In the Row Value(s) field, type the following code: data.token Check the Finish involved rows after this event box. Explanation So far, you have seen that a row value is connected with a row in the table. In addition to the row itself, each row value is connected to a set of labels. These labels are called Row Labels . Row labels allow you to have values associated with each row, but that aren't necessarily visible in the table. Row labels are usually set using the On Row Adding and On Row Updating triggers. They are usually used as part of a column's value. In this step, you listened to two events. These two events signify the beginning and end of a single pick. Both events use the token that is going through the associated activities as the row value. This means the table will have one row per token. The second event finishes the row. This statistics collector will use the first event to create a row, and use a row label to record when that row was created. In this way, each row can store the pick start time, without showing it in the table. The statistics collector will use the second event to record the duration between the first and seond events. Step 2 Add Columns to the Statistics Collector In this step, you will add columns to the Statistics Collector. To do this: Click on the Columns tab. Click the button once again and choose Add column . In the Name field, rename this column to Type . Set the Row Add Value to the following code: data.token.Item.Type . Set the Storage Type property to Integer . Click the button once again and choose Add column . In the Name field, rename this column to PickTime . Set the Event Value to the following code: Model.time - data.row.PickStartTime In the Event.Column Connections area, select the Unload Item - On Exit event. Then check the box for the PickTime column. Explanation In this step, you added two columns: Type and PickTime. The Type column is straightforward; when a new pick begins, a new row is added to the table, and this column will record the Type of the item being picked. In the next step, you will create a row label called PickStartTime , and set its value when the row is added. The PickTime column won't be set until the second event fires. At that point, this column will be set to the difference between the current time and the PickStartTime label. Step 3 Add Triggers to the Statistics Collector In this step, you will add triggers to the Statistics Collector. To do this: Click on the Triggers tab. Click the plus button and choose On Row Adding . Click the plus button in the On Row Adding trigger and choose Set Row Label . Set the name of the label to \"PickStartTime\" . Set the value of the label to Model.time Click off the popup to close it. Click the Apply button. You can right click on the PickTimeByType collector in the Toolbox and select the View Table option. If you reset and run the model, you will see the table record the output by type each hour. You may wish to run the model as fast as possible to see the data populate. Explanation The statistics collector listens to the On Entry of the Travel to Item activity. When that event happens, it yields the token as the row value. The statistics collector adds a row for that token, and records the Type value. In addition, the statistics collector records the current time on a label called PickStartTime . Since each row has its own labels, each row records when it was added in that row's PickStartTime label. The statistics collector also listens to the On Exit of the Unload Item activity. When that event happens, it yields the token as the row value. Since there is already a row for that token, the statistics collector doesn't need to add a new row. However, the PickTime column is connected to this event, so the statistics collector updates the value of that column. That column value uses the current time and the PickStartTime row label to calculate the pick time. This second event also finishes the row. Finishing the Row Can Reduce Memory Use When you finish a row, the labels for that row are deleted. While you would get the same table without finishing the row, the statistics collector would keep track of the labels for every row, instead of just the unfinished rows. Step 4 Creating a Chart Now you will create a chart to show the data in the statistics collector as a box plot. To do this: Click the Dashboards button at the top of the screen and select the Add a Dashboard option. While the dashboard view is active, navigate to the library on the left. Under the Base Chart Types section, find and drag a Box Plot chart onto the dashboard. This will open the new chart’s properties window. Click on the Data Source field and select the PickTimeByType collector from the options. Set the Values property to the PickTime column. In the Color Split By area, check the Type column box. Click on the Settings tab. Check the Show Points box. Click on the Text tab. Check the Custom Title box, and set the custom title to Pick Time by Type . In the Show Column Headers area, check the box for the Type column. Click on the Colors tab. Click the Edit Values button, and choose Remove all colors . Click the plus button three times to add three colors. Click the Apply Button. If you reset and run the model now, the box chart will show the data in the statistics collector. As before you may have to run the model for some time to see the results."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/Tutorials/AdditionalTools/Tutorial2StatsCollector/2-7AvgContentByType/2-7AvgContentByType.html",
        "title": "Tutorial Task 2.7 - Average Content By Type",
        "content": "Task Overview In this task, you will create a Statistics Collector that records the average content in inventory by type: This task is based on the same model that was used in the Task 1 of this series. For information on how to open the model, please refer to that task: Statistics Tutorial 1 - Create a Basic Statistics Collector Step 1 Add Events to the Statistics Collector In this step you will add events to the statistics collector. To do this: Click on the Toolbox tab on the left of the screen and click the button to add a new tool. Navigate to the Statistics section and select Statistics Collector . This will open a properties window. Click on the field at the top and rename the statistics collector to AvgContentByType . On the Events tab, click the plus button and choose Create an event on reset Remove the number from Name of the event, so it reads On Reset . Click the triangle button next to the Row Value(s) property and choose From Global Table column . In the popup, be sure the Table property is set to ProductInfo . Set the Column property to Type . Click outside the popup to close it. In the top left of the Events tab, click the sampler button . Then click on the Storage System in the Toolbox. Choose the On Slot Entry option. In the Additional Labels area, click the plus button , and choose Add label for this event... . Set the Name of the label to Delta . Set the Value of the label to 1 . In the Row Value(s) field, type the following code: data.item.Type In the top left of the Events tab, click on the sampler button Then click on the Storage System in the Toolbox. Choose the On Slot Exit option. In the Additional Labels area, click the plus button , and choose Add label for this event... . Set the Name of the label to Delta . Set the Value of the label to -1 . In the Row Value(s) field, type the following code: data.item.Type Explanation In this step, you listened to an On Reset event that yields all Type values as its row value. This means that On Reset, the Statistics Collector will add one row per Type. You will later use this event to create one label per row that calculates the average content for each type. In addition, you listened to the On Slot Entry and On Slot Exit events, which happen as items enter and exit inventory. You will later use these events to update the average content for each type. Step 2 Add Columns to the Statistics Collector In this step, you will add columns to the Statistics Collector. To do this: Click on the Columns tab. Click the button once again and choose Add column . In the Name field, rename this column to Type . Click the arrow next to the Row Add Value field, point to Data , and choose Row Value . Set the Storage Type property to Integer . Click the button once again and choose Add column . In the Name field, rename this column to AvgContent . Set the Update Timing property to When the value is accessed . Click the arrow next to the Value field. Point to Data , and choose Tracked Variable Row Label . Set the Name field to \"Content\" . Set the Value field to Average . Click off of the popup to close it. Explanation In this step, you added two columns: Type and AvgContent. The Type column is straightforward; on reset, when each row is added to the table, this column will record the Type associated with each row. The AvgContent column will show a continuous value, so it updates whenever the table is accessed. In the next step, you will create a Tracked Variable for each row called Content. This column shows the average of that value. Step 3 Add Triggers to the Statistics Collector In this step, you will add triggers to the Statistics Collector. To do this: Click on the Triggers tab. Click the plus button and choose On Row Adding . Click the plus button in the On Row Adding trigger and choose Add Tracked Variable Row Label . Set the name of the label to \"Content\" . The other settings can be left at their default values. Click off of the popup to close it. At the top of the Triggers tab, Click the plus button and choose On Row Updating . Click the plus button in the On Row Updating trigger and choose Increment row label . In the popup, set the Increment field to \"Content\" . Set the increment amount to data.Delta? . Using ? With Labels You can use a ? to indicate that if the label isn't there, FlexScript can assume a null value. You'll need this because the On Reset event doesn't set the Delta label. Click off the popup to close it. Click the Apply button. You can right click on the AvgContentByType collector in the Toolbox and select the View Table option. If you reset and run the model, you will see the table record the average content by type. You may wish to run the model as fast as possible to see the data populate. Explanation When the model is reset, the statistics collector gets all Type values listed in the ProductInfo table, and creates a row for each one. In addition, the statistics collector initializes a Tracked Variable for each row. A Tracked Variable is a special kind of value; you can get and set it like a normal label value. However, it also calculates the average of the values that you set it to. In this case, that average is time-weighted, which makes it perfect for calculating average content. When an item enters the Storage System, the statistics collector creates the data entity and adds two important labels: The item label (an event parameter label) records which item entered. The Delta label (an additional label) records a value of 1 . This event returns the type of the item as the Row Value. This event doesn't update the table directly. However, in the On Row Updating trigger, this event does increment the value of the Content label. When an item exits the Storage System, the same process happens, except that the Content label is decremented, rather than incremented. When you view the table, the AvgContent column is updated, displaying the current value of the average content. Step 4 Creating a Chart Now you will create a chart to show the data in the statistics collector as a bar chart. To do this: Click the Dashboards button at the top of the screen and select the Add a Dashboard option. While the dashboard view is active, navigate to the library on the left. Under the Base Chart Types section, find and drag a Bar Chart chart onto the dashboard. This will open the new chart’s properties window. Click on the Data Source field and select the AvgContentByType collector from the options. Set the Data Format to One bar per row . Set the Bar Size to the AvgContent column. Set the Bar Color to the Type column. In the Split By area, check the Type column box. Click on the Settings tab. Clear the Show Percentages box. Click on the Text tab. Check the Custom Title box, and set the custom title to Average Content . In the Show Column Headers area, check the box for the Type column. Click on the Colors tab. Click the Edit Values button, and choose Remove all colors . Click the plus button three times to add three colors. Click the Apply Button. If you reset and run the model now, the bar chart will show the data in the statistics collector. As before you may have to run the model for some time to see the results."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/Tutorials/AdditionalTools/Tutorial2StatsCollector/2-8ContentByTypeVsTime/2-8ContentByTypeVsTime.html",
        "title": "Tutorial Task 2.8 - Content By Type Over Time",
        "content": "Task Overview In this task, you will create a Statistics Collector that records the content in inventory by type over time: This task is based on the same model that was used in the Task 1 of this series. For information on how to open the model, please refer to that task: Statistics Tutorial 1 - Create a Basic Statistics Collector Step 1 Add Events to the Statistics Collector In this step you will add events to the statistics collector. To do this: Click on the Toolbox tab on the left of the screen and click the button to add a new tool. Navigate to the Statistics section and select Statistics Collector . This will open a properties window. Click on the field at the top and rename the statistics collector to ContentByTypeOverTime . On the Events tab, click on the sampler button . Then click on the Storage System in the Toolbox. Choose the On Slot Entry option. In the Additional Labels area, click the plus button , and choose Add label for this event... . Set the Name of the label to Delta . Set the Value of the label to 1 . In the Row Value(s) field, type the following code: data.item.Type Check the Finish involved rows after this event box. In the top left of the Events tab, click on the sampler button Then click on the Storage System in the Toolbox. Choose the On Slot Exit option. In the Additional Labels area, click the plus button , and choose Add label for this event... . Set the Name of the label to Delta . Set the Value of the label to -1 . In the Row Value(s) field, type the following code: data.item.Type Check the Finish involved rows after this event box. Explanation In this step, you listened to the On Slot Entry and On Slot Exit event. In both cases, you added a label to both events called Delta. Delta will be used later to increment or decrement the content, as items enter or exit inventory. Both events also use the item's Type label as the row value. Step 2 Add Columns to the Statistics Collector In this step, you will add columns to the Statistics Collector. To do this: Click on the Columns tab. Click the button and choose Add column . Set the column's Name to Time . Click the arrow next to the Row Add Value field select Time and then select Model Date/Time . Click the button once again and choose Add column . In the Name field, rename this column to Type . Click the arrow next to the Row Add Value field, point to Data , and choose Row Value . Set the Storage Type property to Integer . Click the button once again and choose Add column . In the Name field, rename this column to Content . Set the Event Value field to data.row.Content . Set the Storage Type property to Integer . In the Event/Column Connections area, select the Storage System - On Slot Entry event and check the Content box to connect this event to the Content column. Select the Storage System - On Slot Exit event and check the Content box to connect this event to the Content column. Connect Both Events to the Content Column Be sure that both the StorageSystem - On Slot Entry event and the StorageSystem - On Slot Exit event are connected to the Content column. Explanation In this step, you added three columns: Time, Type, and Content. The Time and Type columns are straightforward; whenever an item enters or exits inventory, these two columns will record the current time and the Type associated with each row. The third column doesn't record a value when the row is added. Instead, it is connected to both events. Once the row has been added, then the statistics collector will fire its On Row Updating trigger, and then update the connected column. When that event happens, the Content column will record the value of Content, a row label on the data entity. One remaining task is to make sure that the Content label has the correct data, which you will do later in this task. Step 3 Set the Row Options for the Statistics Collector This step has a single step: click on the Row Options tab, and check the Keep value and labels for finished rows box. Normally, when you finish a row, the statistics collector deletes the labels connected with that row value. By checking this box, you can tell the statistics collector to keep those labels, as well as the row value. The row is still finished, however, and the row value and labels are disconnected from that row. The next time an event produces the row value, the statistics collector will add a new row, and connect the row value and the row labels to the new row. This option allow the statistics collector to remember values between events, even though both events finish the row. Step 4 Add Triggers to the Statistics Collector In this step, you will add triggers to the Statistics Collector. To do this: Click on the Triggers tab. Click the plus button and choose On Row Updating . Click the plus button in the On Row Updating trigger and choose Increment row label . In the popup, set the Increment field to \"Content\" . Set amount to increment by to data.Delta . Click the Apply button. You can right click on the ContentByTypeOverTime collector in the Toolbox and select the View Table option. If you reset and run the model, you will see the table record the content by type over time. You may wish to run the model as fast as possible to see the data populate. Explanation When an item enters the Storage System, the statistics collector creates the data entity and adds two important labels: The item label (an event parameter label) records which item entered. The Delta label (an additional label) records a value of 1 . This event returns the type of the item as the Row Value. Since the statistics collector always finishes its rows, it doesn't have a row for that row value. This means that it will always add a row for the value. However, because you checked the Keep value and labels for finished rows box, the Content label for that row is present, and remembers the previous value of Content for that row. Since the row value is the Type of the item, the Content label on this row matches the content for that Type. When the row is added, the Time and Type columns are recorded. Then, the On Row Updating trigger fires, where you incremented the Content row label by Delta. In this case, Delta is 1, so the Content increases. After the trigger fires, the statistics collector sets the Event Value of the Content column, because it is connected to the current event. In this case, the statistics collector records the value of the Content row label. When an item exits the Storage System, the same process happens, except that the Content label is decremented, rather than incremented. Step 5 Creating a Chart Now you will create a chart to show the data in the statistics collector as a time plot. To do this: Click the Dashboards button at the top of the screen and select the Add a Dashboard option. While the dashboard view is active, navigate to the library on the left. Under the Base Chart Types section, find and drag a Time Plot chart onto the dashboard. This will open the new chart’s properties window. Click on the Data Source field and select the ContentByTypeOverTime collector from the options. Set the X Values property to the Time column. Set the Y Values property to the Content column. Check the Type box in the Color Split By list. On the Settings , change the Draw Style property to Stair Step . Click on the Text tab. Check the Custom Title box, and set the custom title to Content By Type . In the Show Column Headers area, check the Type box. Click on the Colors tab. Click the Edit Values button, and choose Remove all colors . Click the plus button three times to add three colors. Click the Apply Button. If you reset and run the model now, you will be able to see the chart show a time plot of your ContentByTypeOverTime collector. As before you may have to run the model for some time to see the results."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/Tutorials/AdditionalTools/Tutorial2StatsCollector/2-9OutputByHourByType/2-9OutputByHourByType.html",
        "title": "Tutorial Task 2.9 - Output By Hour By Type",
        "content": "Task Overview In this task, you will create a Statistics Collector that records the total output of each type for each hour: This task is based on the same model that was used in the Task 1 of this series. For information on how to open the model, please refer to that task: Statistics Tutorial 1 - Create a Basic Statistics Collector Step 1 Add Events to the Statistics Collector In this step you will add events to the statistics collector. To do this: Click on the Toolbox tab on the left of the screen and click the button to add a new tool. Navigate to the Statistics section and select Statistics Collector . This will open a properties window. Click on the field at the top and rename the statistics collector to OutputByHourByType . On the Events tab, click on the Sampler button. Then click on the Storage System in the Toolbox. Choose the On Slot Exit option. In the Additional Labels field, click the button and select Add label for this event... . Set the Name of this label to Delta and set its Value to 1 . We'll use this label in a later step. In the Row Value(s) field, type the following code: data.item.Type Click the plus button in the top left of the Events tab. Choose the Create a timer event event option. Set the Name of this event to Every Hour - Finish . Click the triangle button next to the First Time property and choose the 1 Hour option. Click the triangle button next to the Repeat Interval property and choose the Every Hour option. In the Additional Labels field, click the button and select Add label for this event... . Set the Name of this label to Delta and set its Value to 0 . In the Row Value(s) field, write the following code: collector.getAllRowValues() Check the Finish involved rows after the event box. Click the plus button in the top left of the Events tab. Choose the Create a timer event event option. Set the Name of this event to Every Hour - Start . Click the arrow next to the First Time property and choose On Reset . Click the triangle button next to the Repeat Interval property and choose the Every Hour option. In the Additional Labels field, click the button and select Add label for this event... . Set the Name of this label to Delta and set its Value to 0 . Click the triangle button next to the Row Value(s) property and choose From Global Table column . In the popup, be sure the Table property is set to ProductInfo . Set the Column property to Type . Click outside the popup to close it. Explanation In this step, you listened to three events: The Storage System's On Slot Exit event, A timer event that fires after an hour, and then every hour, and A timer event that fires when the model is reset, and then every hour. The row value for the first event is a single value- the Type of the item that exited the storage system. The row value for the second is the set of all row values that are currently active in the statistics collector. The row value for the third event is all values in the Info column of the ProductInfo table. No matter which event fires, each row value is a valid Type. Each of these events has a specific purpose. The On Slot Exit event will allow the statistics collector to increment a label associated with that type. The first timer event will allow the statistics collector to display the total for the given hour and, and to finish the row. The third event will restart the entire process for the next hour. Event Ordering In this statistics collector, there are two timer events that both fire every hour. The EveryHour - Finish event will fire first because it is higher in the list. Step 2 Add Columns to the Statistics Collector In this step, you will add columns to the Statistics Collector. To do this: Click on the Columns tab. Click the button and choose Add column . Set the column's Name to Time . Click the arrow next to the Row Add Value field select Time and then select Model Date/Time . Click the button once again and choose Add column . In the Name field, rename this column to Type . Click the arrow next to the Row Add Value field, point to Data , and choose Row Value . Set the Storage Type property to Integer . Click the button once again and choose Add column . In the Name field, rename this column to Output . Set the Event Value field to data.row.Output . Set the Storage Type property to Integer . In the Event/Column Connections area, select the EveryHour - Finish event and check the Output box to connect this event to the Output column. Explanation In this step, you added three columns: Time, Type, and Output. The Time and Type columns are straightforward; at the beginning of each hour, these two columns will record the current time and the Type associated with each row. The third column doesn't record a value when the row is added. Instead, it waits for the EveryHour - Finish event. When that event happens, this column will record the value of Output, a row label on the data entity. The only remaining task is to make sure that the Output label has the correct data, which you will do in the next step. Step 3 Add Triggers to the Statistics Collector In this step, you will add triggers to the Statistics Collector. To do this: Click on the Triggers tab. Click the plus button and choose On Row Updating . Click the plus button in the On Row Updating trigger and choose Increment row label . In the popup, set the Increment field to \"Output\" . Set the amount to increment by to data.Delta . Click the Apply button. You can right click on the OutputByHourByType collector in the Toolbox and select the View Table option. If you reset and run the model, you will see the table record the output by type each hour. You may wish to run the model as fast as possible to see the data populate. Explanation When the model is reset, the EveryHour - Start event fires. It yields an array of Type values, gathered from the ProductInfo table. This adds one row per Type value to the table. The Time and Type columns are filled in, but the Output column is left blank. When an item exits inventory, the statistics collector determines its Type. Because there is already a row for that type, and because the On Slot Exit event is not connected to any columns, the table doesn't change. However, the On Row Updating event fires for the Type's row. In this trigger, you added code that increments a row label called Output. In this way, you are counting the number of outputs of a given type. Each hour, both timer events fire. The EveryHour - Finish event fires first, because it is higher in the list. This event yields all current row values as its row value, so it will update all three active rows. This event is connected to the Output column, so this column finally records the Output row label. Then this event finishes the row, so the row value is forgotten and the row labels are destroyed. Finally, the EveryHour - Start event fires again. Once again, it yields all Type values from the ProductInfo table. Since the statistics collector has forgotten these values, it adds one more row per type, and starts the whole process over again. Step 4 Creating a Chart Now you will create a chart to show the data in the statistics collector as a time plot. To do this: Click the Dashboards button at the top of the screen and select the Add a Dashboard option. While the dashboard view is active, navigate to the library on the left. Under the Base Chart Types section, find and drag a Time Plot chart onto the dashboard. This will open the new chart’s properties window. Click on the Data Source field and select the OutputByHourByType collector from the options. Set the X Values property to the Time column. Set the Y Values property to the Output column. Check the Type box in the Color Split By list. On the Settings , change the Draw Style property to Lines and Points . Click on the Text tab. Check the Custom Title box, and set the custom title to Output By Type . In the Show Column Headers area, check the Type box. Click on the Colors tab. Click the Edit Values button, and choose Remove all colors . Click the plus button three times to add three colors. Click off of the Quick Property panel to apply the changes. If you reset and run the model now, you will be able to see the chart show a time plot of your OutputByHourByType collector. As before you may have to run the model for some time to see the results."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/Tutorials/AdditionalTools/Tutorial3Experimenter/ExperimenterOverview/ExperimenterOverview.html",
        "title": "Tutorial 3 - Experimenter",
        "content": "This tutorial introduces the Experimenter found in FlexSim. This tool each help to answer the \"what-if\" questions for a model: What if the milling station were placed differently? What if more people were hired for a given shift? What if the order of these processes was changed? The Experimenter allows you to try many different versions of your model and evaluate the performance of each one. The Experimenter does this using Jobs. You can configure two kinds of Jobs: an Experiment Job and an Optimization Job. In an Experiment Job, you'll specify the parameter values you'd like to try in your model. In an Optimization Job, you'll specify a goal, and allow the optimization to generate parameter values, searching for the best scenario. They are both very powerful ways to learn about and improve your system. OptQuest License Using the Optimization Job requires the OptQuest license. Contact FlexSim for more information about obtaining this license. Tasks Covered This tutorial will cover the following tasks: Task 3.1 Experiment Job In this tutorial task, you'll learn how to use an Experiment Job. Task 3.2 Optimization Job In this tutorial task, you'll learn how to use an Optimization Job. For More Information For more in-depth explanations of the concepts covered in these tutorials see: Experimenter Key Concepts About Experiments Running Jobs"
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/Tutorials/AdditionalTools/Tutorial3Experimenter/3-1ExperimentJob/3-1ExperimentJob.html",
        "title": "Tutorial Task 3.1 - Experiment Job",
        "content": "Task Overview In this tutorial, you'll use an Experiment Job to specify several scenarios, and run many replications of those scenarios. For this tutorial, let us examine a very simple situation. A single worker must carry an item from a source to a processor. After the item finishes processing, the worker must carry it to a second processor that takes longer than the first. After the second processor finishes the item, the worker then carries it to the sink. Now we want to see if we can maximize the throughput of this system by adjusting (which is also tied to revenue) the position of the processors. If each processor could be moved up to three meters right or left, where should each be placed? It would be very difficult to intuitively know how to place both processors to maximize throughput. In order to solve this problem accurately, we will use the Experimenter and Optimizer. Obviously this is a drastically simplified scenario, but often in real life you have situations where you want to see how various layouts affect overall throughput. This is a very simplistic implementation of such an experiment. Step 1 Build the 3D Model In this step, you'll build a basic 3D model for this tutorial. When you're finished, your model should look similar to the following image: To build this model: Make sure your 3D model window is open and active. From the Library, drag the following 3D objects into the model: A Source A Processor A Processor A Sink A Dispatcher An Operator Click on Source1 Click on the Position button in the Properties and set the position reference to Direct Spatials. Set the location of the objects according to the table below: Object X Position Y Position Source1 0.0 0.0 Processor1 10.0 0.0 Processor2 20.0 0.0 Sink1 30.0 0.0 Dispatcher1 N/A N/A Operator2 N/A N/A Dispatcher5 and Operator7 do not need to be in a particular place, but they should not be in line with the rest of the objects. Set the following logic: Set Source1 , Processor1 , and Processor2 to Use Transport . Set the process time of Processor1 to normal(10, 2, getstream(current)) . Set the process time of Processor2 to normal(12, 3, getstream(current)) . Check to ensure your model looks similar to the image shown at the beginning of this step. Step 2 Creating Parameters To create parameters, you'll use a Model Parameters Table. Then you'll configure two parameters. Each parameter will be linked to a Processor. On reset, the processor will move so that it's x-location matches the value of the Parameter. In the Toolbox, double click on the Model Parameter Table called Parameters to open it. Click and drag the Parameter Table view to dock it to the right of the 3D view. Click on the Value cell of Parameter1. A button will appear. Click this button to open the parameter value properties. Set the Lower Bound to 7 Set the Upper Bound to 13 Click the sampler button next to the Reference field. Click on Processor1 , point to Properties and then choose SetupTime . Click the properties button next to the On Set field. Change Property to Location.X . Click on the parameter value properties to close the popup. At the top of the Parameters table, click the up button to add another parameter. Click on the Value cell for Parameter1 to select it. Press Ctrl-C to copy the value Click on the Value cell for Parameter2 to select it. Press Ctrl-V to paste the value. Click the button to open the parameter value properties for Parameter2. Set the Lower Bound to 17 Set the Upper Bound to 23 Click the sampler button next to the Reference field. Click on Processor2 , and choose Processor2 . To see how these parameters work, reset the model. Processor1 should move so it's x-location is 7, and Processor2 should move so it's x-location is 17. Edit the parameter table, and put in new values for Parameter1 and Parameter2, such as 10 and 20. When you reset the model again, the processors should move to match. Parameter Value vs Value Configuration To edit the current value of a parameter, you can set it's value directly in the table. To edit the configuration of the value (Type, bounds, On Set, etc.), you'll need to open the parameter value properties window by clicking the button. Using Parameters This tutorial demonstrates one way of using a parameter, where the parameter sets something in the model. The other approach is to configure objects to read parameter values. For more information, see the Model Parameter topic. Step 3 Creating Performance Measures In the toolbox, double click the Performance Measure Table called PerformanceMeasures. Dock it in the same pane as the Parameters table view. From there: Click the Value cell for PerformanceMeasure1 . Click the button to open the peformance measure value properties. Click the Sampler button . Click on Sink1 to sample it. Then point to Statistics and choose Input . Click outside the performance measure value properties window to close it. Now, if you run the model long enough, you should be able watch the performance measure's value increase as boxes enter the sink. Save your Progress Save the model at this point to save your progress. Step 4 Designing the Experiment Job Now that we've created the parameters and performance measures, we'll set up an Experiment Job to run replications of some scenarios. In the Statistics menu, choose Experimenter. The experimenter window will appear. It should already contain an Experiment Job called Experiment1. Check the box in the Parameters list. This will add all the parameters in the Parameters table to the experiment. Create 5 total scenarios by entering a 5 in the scenario count field. Enter scenario names and values as follows: Results Database File Path May Differ The previous image shows the path to the Results Database File. The path you see may be different. Step 5 Running the Experiment Job Go to the Run tab. Click the Run button. Each scenario will be run 5 times and the results of the performance measure will be collected at the end of each run. The status chart will show which scenarios/replications are currently being run. FlexSim will run multiple scenarios simultaneously if your computer has a multi-core cpu. Once the experiment is finished, click the button at the top. This will open a window where you can get data on the performance measures for the scenario. In this example we only have one performance measure, but if you had multiple you could see the results for each in this window. There are several options for how to display the data, including a Replications Plot, a Frequency Histogram, a Correlation Plot (for examining correlations between multiple performance measures), a Data Summary, and a Raw Data view. If the goal is to maximize throughput, then the \"Close\" scenario is the best option. Conclusion At this point, you've learned how to use an Experiment Job. In the next tutorial task, you'll learn how to use an Optimization Job. Continue on to Tutorial Task 3.2 - Optimization Job ."
    },
    {
        "url": "https://docs.flexsim.com/en/25.2/Tutorials/AdditionalTools/Tutorial3Experimenter/3-2OptimizationJob/3-2OptimizationJob.html",
        "title": "Tutorial Task 3.2 - Optimization Job",
        "content": "Task Overview The Experimenter allows you to define an Optimization Job. Unlike the Experiment Job, which explicitly defines scenarios, the Optimization Job will automatically create scenarios and then test those scenarios, trying to find a scenario that best meets an objective. All Optimization Jobs use FlexSim's optimizer, which is run by the OptQuest optimization engine. OptQuest License Using the Optimizer requires the OptQuest license. Contact FlexSim for more information about obtaining this license. Step 1 Adding an Optimization Job Go to the Jobs tab in the Experimenter window. Click the Add button in the top-left and choose Optimization from the menu. Step 2 Designing the Optimization Job Set the Stop Time to 10000 . This is how long the Optimizer will run each scenario to evaluate it. Set the Wall Time to 0 . This usually means how long the Optimizer is allowed to run in real time. The value 0 means it has no time limit. Check the top box in the Parameters tree to include both parameters. Set Max Iterations to 50 . This means the Optimizer will try no more than 50 different scenarios to find the optimal scenario. Click on the Function cell for the first objective. Click on the button that appears. Point to Performance Measures , then choose PerformanceMeasure1 . Step 3 Running the Optimization Job Go to the Run tab in the Experimenter window. Then: Use the Job combobox to select the Optimization Job. Click the Run button. The Optimization Job then begins running through the following loop: Guess values for Parameter1 and Parameter2 . Each guess becomes more and more intelligent as the optimization runs. Each guess is called an Iteration. Run a model with those values for 10000 seconds. Evaluate the performance measures. Calculate the objective function. Rank this scenario. Use the information from this scenario to create a new scenario - new values for Parameter1 and Parameter2 . Repeat from Step 2. The Optimization can make many simultaneous guesses, if you have more than one CPU available. As the Optimization Job progresses, the status chart will update and show the job's progress. Once the Optimizer evaluates 50 scenarios, a message will appear stating why the Optimizer stopped. In this case, it will say that the Optimizer reached the maximum number of iterations. If something went wrong, the message will contain information about the error. Step 4 Analyzing the Results When the optimization is finished, the Optimizer Results chart should look something like this: The best scenario is marked with a gold star. As the Optimization Job progresses, it will generally find better and better scenarios. However, it may also try new random guesses, to make sure it isn't stuck in a local optimum. Those random guesses may not perform as well. Answering the Original Question The goal of this optimization was to figure out where to put the two processors. We can now very easily find the answer to this question. Hover over the best scenario (the scenario with a gold star) on the chart; a small popup will appear. Click on this scenario to select it. Now, in the Graph Options panel, change the Y Axis to Parameter2, and the X Axis to Parameter1. The scenarios that performed the best have a high value for Parameter1 and a low value for Parameter2. Conclusion An Optimization Job is a powerful tool that allows you to try hundreds of configurations automatically, as part of a search for the best objective value. Even if there are dozens of variables with complicated interactions, the optimization can still find very good scenarios, in a short amount of time."
    }
]